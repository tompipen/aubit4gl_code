#! /usr/bin/awk -f
#	"@(#) fglpp 0.2"
#
#	fglpp - A 4gl precompiler (could have called it 'mouse4gl', though)
#
#	The 4glWorks application framework
#	Copyright (C) 1992-2002 Marco Greco (marco@4glworks.com)
#
#	Initial release: Apr 96
#	Current release: Jan 02
#
#	This library is free software; you can redistribute it and/or
#	modify it under the terms of the GNU Lesser General Public
#	License as published by the Free Software Foundation; either
#	version 2.1 of the License, or (at your option) any later version.
#
#	This library is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#	Lesser General Public License for more details.
#
#	You should have received a copy of the GNU Lesser General Public
#	License along with this library; if not, write to the Free Software
#	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

BEGIN	{

# token separator (makes HPUX awk happy)
	    FS="[ \t]*[][()\+-/=<>!,.\*][ \t]*|[ \t]+"
	    if (ARGC<4)
	    {
		print "bad # of parms"
		exit
	    }

# save include search path for later
	    for (i=4; i<ARGC; i++)
	    {
		pathsearch[i-3]=ARGV[i]
		ARGV[i]=""
	    }

# extract source, output globals and output source file names
	    pathcount=ARGC-4
	    curfile=ARGV[1]
	    gf=ARGV[2]
	    of=ARGV[3]
	    ARGV[2]=""
	    ARGV[3]=""

# initialize a number of handy variables
	    filestack[0]=curfile
	    not_a_4gl=(curfile !~ /\.4gl$/)
	    globalsdone=0
	    inglobals=0
	    nootherglobals=1
	    error=0
	    dbcount=0
	    filepoint=0
	    rowoutput=of
	    nextrowoutput=of 

# rats! Can't use pattern driven syntax
	    for (;;)

# read next line
	    {
		j=0
		while ((i=getline <filestack[filepoint])<=0)
		{
		    close(filestack[filepoint])
		    if (i && (j<pathcount) && filepoint)
		    {
			filestack[filepoint]=pathsearch[++j] "/" curfile
			continue
		    }
		    if (inglobals==filepoint)
		    {
			inglobals=0
			globalsdone=1
			nextrowoutput=of
		    }
		    if (!filepoint--) exit
		}
		rowoutput=nextrowoutput

# we have an include "filename" directive, here
		if ($0 ~ /^#include *\".*\"/)
		{
		    n=split($0, t, "\"")
		    if (!(filepoint||not_a_4gl)) print > of
		    filestack[++filepoint]=t[2]
		    curfile=t[2]
		    continue
		}

# defining some constant, here
		if ($0 ~ /^#define/)
		{
		    buff=$0
		    sub("#define[ \t]+", "")
		    sub("#.*", "")
		    term=$1
		    sub(term "[ \t]+", "")
		    defs[term]=$0
		    items[term]=NF-1
		    if (!(filepoint||not_a_4gl)) print buff > of
		    continue
		}

# for the sake of line counts, skip included comment lines...
		if ($0 ~ /^#|^--/)
		{
		    if (!(filepoint||not_a_4gl)) print > of
		    continue
		}

# ...and included empty lines
		if (!NF)
		{
		    if (not_a_4gl||!filepoint) print > of
		    continue
		}

# globals "filename" directive
		if ($0 ~ /^[^#]*globals *\".*\"/)
		{
		    if (!inglobals)
		    {
			n=split($0, t, "\"")
			if (globalsdone) $0="{" $0 "}"
			else $0="{" $0 "} globals \"" gf "\""
			filestack[++filepoint]=t[2]
			curfile=t[2]
			nextrowoutput=gf
			inglobals=filepoint
		    }
		    else error=1
		    nootherglobals=0
		}

# end globals directive
		if ($0 ~ /end *globals/)
		{
		    if (inglobals==filepoint && inglobals) 
		    {
			gsub("end *globals", "")
			inglobals=0
			nextrowoutput=of
			globalsdone=1
			close(filestack[filepoint--])
		    }
		    else error=1
		    nootherglobals=0
		}

# plain globals directive
		if ($0 ~ /[^#]*globals/)
		{
		    if (nootherglobals)
			if (inglobals==filepoint && inglobals) 
			{
			   if (globalsdone) sub("globals", "")
			}
			else error=1
		    nootherglobals=1
		}

# database directive
		if ($0 ~ /[^#]*database *[^ ]*/)
		{
		    if (inglobals==filepoint && inglobals) 
		    {
			if (globalsdone) sub("database *[^ ]*", "")
		    }
		    else error=dbcount
		    dbcount++
		}

# plain line, perform substitutions
		i=1;
		fieldlimit=0
		while (i<=NF)
		{
		    if ($i in defs)

# circular substitution, avoid infinite loops
			if ($i in entries)
			    error++
			else
			{

			    entries[$i]=i
			    if (fieldlimit)
				fieldlimit+=items[$i]
			    else
				fieldlimit=i+items[$i]
			    sub($i, defs[$i])
			    continue
			}
		    if (i++==fieldlimit)
		    {
			fieldlimit=0
			for (q in entries) delete entries[q]
		    }
		}
		if (error)
		{
		    error=0
		    print $0 " # fglpp: probable error" > rowoutput
		}
		else print > rowoutput 
	    }
	}

#at the end of the fair, terminate output globals file, if needed
END	{ if (globalsdone) print "end globals" > gf }
