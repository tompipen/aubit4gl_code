'\" @(#)$Id: fglbld2.doc,v 1.1 2002-06-16 07:36:14 afalout Exp $
'\" @(#)FGLBLD: User Guide and Reference Manual
'\" @(#)Part 2 of 5
'\" -----------------------------------------------------
'\" Definitions
.ds fB \s-2\fBFGLBLD\fP\s0
.ds iR Informix-RDS
.ds sP \s-2SPI\s0
\!!rasterize=300
\!!thickness=2
'\" -----------------------------------------------------
'\"
.PH "''\s12\fHSphinx Ltd\fP\s0''"
.PF "'\s8Sphinx\s0'Page %'\s8Version $Revision: 1.1 $ $Date: 2002-06-16 07:36:14 $\s0'"
'\"
'\" -----------------------------------------------------
'\"
.H 1 "USING FGLBLD"
\*(fB can be run in either of two ways.
Simply typing:
.eS
fglbld
.eE
runs the program and is the normal way of using it.
Alternatively, typing:
.eS
fglbld \*(iSdatabase\*(iE
.eE
will preselect the specified database.
The database can be changed within \*cfglbld\*d;
if it is not preselected (or if the preselected database cannot
be opened), it will have to be specified using either the
Database option in the main menu or before any code is generated.
.P
The main menu is illustrated in Figure 3.
.DF CB
.FG "The FGLBLD main menu."
.PS <mainmenu.pic
.DE
The SPI option generates an \*(sP;
the Popup option leads to a sub-menu which allows you to generate
two different types of popup function;
the Fetch option generates a function to select a row of data from the database;
the Modify option leads to a sub-menu which can be used for
editing, compiling and running the generated code;
the Build option rebuilds the generated application;
the Run option runs it;
the Name option allows the user to work with different generated applications;
the Database option allows the user to change the active database;
and the Exit option terminates the session with \*(fB.
There is a single hidden option: `!' provides a shell escape.
.P
Throughout \*(fB itself, the following rules apply:
.AL 1
.LI
At any point, you can type control-W and get help.
.LI
If you are entering data in a form, you can more detailed help
for the field you are in by typing control-F (or the F6 key).
.LI
If there is a popup available, you can activate it by typing
control-B (or the F5 key).
.LI
Hitting the interrupt key in a form or a popup terminates whatever
operation you were doing and returns you to what you were doing before.
Hitting the interrupt key in a menu has no effect beyond
generating annoying messages.
.LE 1
.P
A lot of the information presented in the next section (creating an \*(sP)
is also applicable to creating a popup function and creating a fetch function.
'\"
'\" -----------------------------------------------------
'\"
.H 2 "Creating an SPI"
When the SPI option is chosen, a form is displayed and has to be filled in.
.P
If no database has been specified, another, smaller window will be popped up
asking for the name of a database.
Until a database has been opened successfully, you cannot proceed further,
though an interrupt will take you back to the main menu.
The name of the database should not contain any path;
it must be accessible via the environment variable \*cDBPATH\*d.
.P
Once a database has been selected, there are a number of details that must be
specified, and also a number of options that may be specified.
The mandatory items are:
.AL i 5 1
.LI
the table name,
.LI
the primary key of table,
.LI
the menu name,
.LI
the basename of the files.
.LE 1
'\"
'\" -----------------------------------------------------
'\"
.H 3 "Specifying the table name."
The table name must be specified first; it can be entered directly, or it can
be chosen from a list by pressing the F5 key or control-B.
.P
When choosing from a list, you are offered a conditional popup which was
originally generated by \*(fB.
When the conditional popup code is entered for the first time, there are no
items in its list, so it immediately asks you to specify the criteria for
selecting the list of tables.
You can specify conditions on the table name or number; you could just hit the
\s-2ESCAPE\s0 key which would select all the tables in the database, or
you could specify that the table number should be greater than or equal to one
hundred which yields a complete list of user-defined tables, or you could
specify some other condition.
The list of tables is displayed using a \s-2DISPLAY ARRAY\s0, and you can
choose the required table (or view) by hitting \s-2ESCAPE\s0 with the cursor on
the correct row.
.P
Hitting the interrupt key will abandon the selection process and
return you to the form so that you can type a table name.
When a conditional popup is entered and there are some items in its list,
it will offer you a menu with options Query, Same and Exit.
The Query option allows you to enter new criteria for the tables to be shown;
the Same option allows you to choose from the same list as before;
and the Exit option exits the popup without selecting anything.
If the criteria ever returns an empty list of names,
you will be shown the menu again.
If the search criteria select more than thirty table names, only the first
thirty will be shown; you will have to respecify the criteria if the required
table is not in the list.
When the database changes, any previous list of table names is forgotten.
This table popup function is also used when creating a popup
function or a fetch function.
'\"
'\" -----------------------------------------------------
'\"
.H 3 "Specifying the primary key."
Once the table has been chosen, the primary key must be specified.
The column name can be entered directly, or you can choose from a
list by pressing the F5 key.
The popup is an unconditional popup this time \(em the possible
choices of column name are fixed when the table is specified.
(This too was originally generated by \*(fB, but it was modified
to take the table number as an argument so that the correct list
of columns can be generated automatically.)
If the table's primary key is a composite key,
the special value `\s-2ROWID\s0' should be entered or chosen.
This name must be entered in capital letters.
The \s-2ROWID\s0 is always a valid choice as the primary key,
but it is often convenient to use a real column that does not
allow nulls and which has a unique index as the primary key.
A typical example is a \s-2SERIAL\s0 column.
Any column name except \s-2ROWID\s0 must be entered in lower-case letters.
'\"
'\" -----------------------------------------------------
'\"
.H 3 "Specifying the menu name."
After the table and column have been specified, the menu title is entered.
This is automatically converted to upper-case letters.
The colon will be supplied by \*(i4; if you supply one too,
two colons will appear when the program is run.
'\"
'\" -----------------------------------------------------
'\"
.H 3 "Specifying the file names."
Finally, the basename of the generated files is specified.
This is restricted to seven lower-case characters because the
\*(i4 source files will be given an extra letter and `\*c.4gl\*d'
as a suffix, which uses up to 12 characters, and 2 characters
will be needed for the `\*cs.\*d' prefix supplied by SCCS, giving
a total of 14 characters which is as long a name as System V Unix allows.
All the generated files will start with the specified basename,
but the standard files which are copied into the directory will
have other names.
'\"
'\" -----------------------------------------------------
'\"
.H 3 "Specifying the options."
Frequently, this will be all the information you need to specify
because the rest of the input is supplied with default values
of `Y' that specify a fully-featured \*(sP.
However, you can elect to omit any of the sections listed below
by changing the option value to `N':
.VL 1.5i 0.0i 1
.LI "Add"
There will be no Add option in the generated menu.
.LI "Before field"
The \s-2BEFORE FIELD\s0 code in the \s-2INPUT\s0 statement will be omitted.
.LI "After field"
The \s-2AFTER FIELD\s0 code in the \s-2INPUT\s0 statement will be omitted.
.LI "Control-P"
The code which copies the value previously entered or displayed
in this field will be omitted.
.LI "Control-B"
The code which can activate a popup will be omitted.
.LI "Update"
There will be no Update option in the generated menu.
.LI "Delete"
There will be no Delete option in the generated menu.
.LI "Report"
There will be no Report option in the generated menu.
.LI "Shell escape"
There will be no hidden option to run a Unix command.
.LE 1
If both the Add and Update code are omitted, the values specified
for the before field, after field, control-P and control-B flags
are irrelevant as no input code will be generated.
It is not a good idea to omit either the before field or the
after field code.
'\"
'\" -----------------------------------------------------
'\"
.H 3 "Generating the code."
Once the \s-2ESCAPE\s0 key is hit with the data fully defined,
\*(fB will generate the code.
It does this in 9 phases:
.AL 1 5 1
.LI
Generate a default form.
If the form contains more than one screen of data, or if any of
the fields is split onto several lines, \*cfglbld.alt\*d (the
code generator script) produces a warning that the form needs editing.
.LI
Generate the default help message file.
Most of the help messages are properly helpful, but the field
level help messages for input and update are just `This is the
default help message for Table.column.'
.LI
Generate the main, globals and cursor files.
These files are simply copies of the templates.
.LI
Generate the input file.
This is generated even if no input is needed.
.LI
Generate the report file.
This too is generated even if the report is not needed.
.LI
Generate the makefile.
.LI
Generate the auxilliary files.
These files do not change from \*(sP to \*(sP and can be included
in a library if desired.
.LI
Edit the files.
This converts the template files into the operational code,
and also deletes any unwanted code.
.LI
Compile the program.
This runs \*(mK to build the \*(sP object.
.LE 1
If no errors or warning were generated, the program can now be run.
'\"
'\" -----------------------------------------------------
'\"
.H 3 "Reusing file names."
If you accidentally (or deliberately) create a new file
with the same name as some existing file, you will get one or
two cryptic messages.
If you have not previously offended like this, you will see a message
such as:
.eS
+ mv filename.4gl o.filename.4gl
.eE
If you have already committed the same offence, you will get
a message such as:
.eS
+ rm -f o.filename.4gl
+ mv filename.4gl o.filename.4gl
.eE
'\"
'\" -----------------------------------------------------
'\"
.H 2 "The Pop-up menu"
The pop-up option in the main menu leads to the sub-menu shown in Figure 4.
.DS CB
.FG "The Popup menu."
.PS <popmenu.pic
.DE
The Conditional option is used to generate a conditional popup \(em
the type which allows the user to specify what they wish to choose from.
The Unconditional option is used to generate an unconditional popup \(em
the type where the user gets no choice about what to choose from.
the Database option allows you to change the current database.
The Exit option returns you to the main menu.
'\"
'\" -----------------------------------------------------
'\"
.H 2 "Which type of popup?"
Popups let the user choose from a list of possible values.
To be effective, the list should not be so long that the user gets annoyed
with having to scroll through the list to find the required value.
.P
An unconditional popup is all that will be needed when a user
will only have to choose between a few possible values.
Unconditional popups frequently need an argument which indicates
which subset of a large number of possible values should be shown.
.P
A conditional popup is needed when there are a very large number of possible
choices and the user will need to be able to reduce the list to a more
manageable length by specifying some criteria for which rows
should be displayed.
In extreme cases, a full \*(sP could be used as a super-popup
\(em it gives the ultimate in flexibility \(em but be careful of
carrying this too far\*F.
.FS
One technical \fItour-de-force\fP consisted of an \*(sP which used
a second \*(sP as a popup; the second \*(dP itself used a third
\*(sP as a popup; and the third \*(sP used a fourth \*(sP as a popup.
The fourth \*(sP only used standard popups.
Although this worked \(em and was very powerful and versatile in
the hands of its designer \(em it was beyond the capacity of the
end users and was never used seriously.
.FE
.P
A good illustration of when to use a conditional popup and when
to use an unconditional one is in the code for \*(fB:
the table name popup is conditional, and the column name popup is unconditional.
In a database, there may be several hundred tables.
The user normally knows roughly which tables are relevant and
does not want to have to scroll through the complete list to find
the required name.
Additionally, there is a problem with writing the code: how big
should the list be?
And what happens when the actual number of tables in the database
grows too large?
A general purpose program such as \*(fB cannot just ignore this
problem, and it cannot just forget to show the extra tables to
the user because Sod's Law\*F
.FS
Sod's Law, also known as Murphy's Law, states: `If anything can go
wrong, it will'.
The first corollary is: `Even if you thought it couldn't go
wrong, Sod's Law still applies'.
.FE
dictates that the omitted tables will be the ones that \*(fB's
fussiest user will be having difficulty remembering.
Thus, for choosing tables, a conditional popup is necessary.
.P
One the other hand, once the table is chosen, there are normally
only a few columns in the table and all the columns can be shown.
In the unlikely event that some columns are omitted from the
list, it shouldn't matter since the primary key column would
normally be one of the first few columns in the table.
By allocating a list of fixed size, and by passing the table name
(or number) as an argument to the popup function, the use can
choose from a list without having to specify a query.
'\"
'\" -----------------------------------------------------
'\"
.H 2 "Creating a conditional popup function"
The Conditional option is similar to, but simpler than, the SPI option.
As with the SPI option, a form is displayed and has to be filled in.
As before, the current database is used, and if no database has
been specified yet, you will have to choose one via the popup window.
.P
When the database has been selected, there are five mandatory
pieces of information to be supplied:
.AL i 5 1
.LI
the table name,
.LI
the primary key of the table,
.LI
the menu name,
.LI
the file name,
.LI
what is being selected.
.LE 1
The mechanisms and constraints on entering the table name,
primary key, menu name and file name are almost identical to
those in the SPI option;
the only difference is that the file name may have up to 8
characters (rather than 7) because no letter is put between the
name entered in the form and the `\*c.4gl\*d' suffix.
.P
The last item is more difficult to explain.
In the generated code, there are two places where a message is
produced which refers to what the user is selecting.
For example, when the chosen table contained a list of jobs,
the two messages were:
.eS
MESSAGE "Use cursor keys to choose job: ESC to select"
MESSAGE "Some jobs not displayed"
.eE
Because \*(fB is not psychic, the user has to specify what should
be put into these messages in the fifth field, the one which is
labelled `What is being selected'.
The value entered should be the singular (e.g. `job').
If the name does not simply take an `s' to make the plural
(which is used in the second message), the source code will have
to be edited.
.P
Once these details have been specified and the \s-2ESCAPE\s0 key
has been hit, \*(fB will generate the code.
It does this in 3 phases;
.AL 1 5 1
.LI
Generate a default form.
Modify this so that there is a screen array of length one defined.
.LI
Generate the popup code.
.LI
Compile the code.
.LE 1
'\"
'\" -----------------------------------------------------
'\"
.H 2 "Creating an unconditional popup function"
The Unconditional option is almost identical to the Conditional one;
the only difference is that no menu is generated,
so no menu name is entered.
All the other comments apply as before.
'\"
'\" -----------------------------------------------------
'\"
.H 2 "Creating a fetch function"
The Fetch option is the simplest of the code generating options.
As with all the other code generating options,
you specify the table and primary key and the file
name, but with a fetch function, that is all that is specified.
The same popup facilities are available for choosing the table
and column as in the \*(sP option.
The Fetch option generates the code very quickly.
.P
There is one issue which causes trouble, namely that you need to specify a
real column as the primary key.
If the primary key for the table is composite, you will need to specify
one of those columns as the primary key and then modify the generated code
to add enough extra arguments to define the primary key completely.
This is more fiddly than difficult \(em see the section on
`Modifying a fetch function'.
'\"
'\" -----------------------------------------------------
'\"
.H 2 "The Database, Build, Run and Name options"
The database option allows you to choose a new active database.
It pops up a small window and shows you the current database.
You can enter a new database name, or leave the entry blank to
continue with the same database.
The same option is available from the Pop-up menu, and the same
code is used if one of the code generating options is chosen when
no database is active.
The name of the current database is shown on the status line of
the menu as soon as possible.
If the code is called from a menu, it is displayed immediately;
if the code is called from a form, it is only displayed after the
all the data has been entered in the form.
.P
The Name option allows you to change the name of the program
being worked on.
It is always set when you generate a new piece of code,
and it can also be set via the menu option.
It actually defines the basename of the program;
the other options will extend this name as appropriate so that
they operate on the correct files.
The name of the current program is shown on the status line of
the menu as soon as possible.
If the name is specified from a menu, it is displayed immediately;
if the name is specified as part of the data in a form,
it is only displayed after the all the data has been entered in the form.
.P
The Build option runs \*(mK to build the application.
It actually runs:
.eS
${MAKE:-make} -f \*(iSprogram\*(iE.mk ${FGLBLD_I4GL:-rds}
.eE
If the exit status from \*(mK is 0, the next option is Run;
otherwise, the next option is Modify.
Note that \*(fB does not normally create `\*c.4ge\*d' files,
though the rules in the makefile can be modified to do so very easily.
.P
The Run option effectively runs the command below:
.eS
case "$FGLBLD_I4GL" in
c4gl)   \*(iSprogram\*(iE;;
*)      ${FGLGO:-fglgo} \*(iSprogram\*(iE;;
esac
.eE
'\"
'\" -----------------------------------------------------
'\"
.H 2 "Modifying the source code"
The Modify option leads to the sub-menu shown in Figure 5.
.DS CB
.FG "The Modify menu."
.PS <modmenu.pic
.DE
If the Source option is chosen, it leads to the sub-menu shown in Figure 6.
If the Form option is chosen, the extension `\*c.4pr\*d' is added
to the program name and the editor specified by \*cDBEDIT\*d
(default \*Cvi\*D) is run to allow you to edit the file.
Similarly, if the Makefile option is chosen, the extension
`\*c.mk\*d' is added to the end of the program name and the
editor is run.
The Build, Run and Name options in this menu are identical to the
Build, Run and Name options in the main menu.
.DS CB
.FG "The Source menu."
.PS <srcmenu.pic
.DE
When the Source option is chosen, it leads to the Source File menu shown in
Figure 6.
If the Input option is chosen, the extension `\*ci.4gl\*d' is added
to the program name and the editor specified by \*cDBEDIT\*d
(default \*Cvi\*D) is run to allow you to edit the file.
Similarly, the Report, Cursor, Main and Globals options add the extensions
`\*cr.4gl\*d', `\*cc.4gl\*d', `\*cm.4gl\*d', and `\*cg.4gl\*d' and then
run the editor.
These options are used when the program name is the name
specified when an \*(sP was generated.
The Other option is used when the program name is the basename of a
popup function or a fetch function or some other piece of \*(i4
code; it adds the extension `\*c.4gl\*d' and runs the editor.
The Exit option exits from the menu without editing anything.
All the options edit a single file and then return to the Modify
menu shown in Figure 5.
'\"
'\" -----------------------------------------------------
'\"
.H 2 "Environment variables"
\*(fB code uses a large number of environment variables.
The ones which can be set by the user to affect its behaviour are:
.VL 1.5i 1
.LI \*cFGLBLDDIR\*d
This is set by the \*cfglbld\*d script.
.LI \*cFGLBLD_I4GL\*d
This governs whether \*(iR or compiled \*(i4 is used.
If it is set to \*cc4gl\*d, compiled \*(i4 is used;
otherwise, \*(iR is used.
.LI \*cFGLGO\*d
This can be set to use a custom interpreter;
one standard setting would be \*cfgldb\*d to debug programs
rather than just interpret them.
.LI \*cDBEDIT\*d
This controls the editor used.
If it is not set, \*Cvi\*D is assumed.
.LI \*cMAKE\*d
This controls the name of the \*(mK program that is run.
Some installations use alternative versions of \*(mK such as
\*Crmk\*D\*F, \*Ccake\*D, \*Cnmake\*D.
.LE 1
.FS
\*CRmk\*D is available through Sphinx.
It has a better understanding of \*(sS than standard versions of \*(mK.
Except that it does not have the concept of `\*c.KEEP_STATE:\*d',
it is as powerful as the version of \*(mK under SunOS, plus it understands
\*(sS better than that version does (but only by a small margin).
.FE
