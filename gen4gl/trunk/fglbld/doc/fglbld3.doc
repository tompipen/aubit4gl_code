'\" @(#)$Id: fglbld3.doc,v 1.1 2002-06-16 07:36:14 afalout Exp $
'\" @(#)FGLBLD: User Guide and Reference Manual
'\" @(#)Part 3 of 5
'\" -----------------------------------------------------
'\" Definitions
.ds fB \s-2\fBFGLBLD\fP\s0
.ds iR Informix-RDS
.ds sP \s-2SPI\s0
\!!rasterize=300
\!!thickness=2
'\" -----------------------------------------------------
'\"
.PH "''\s12\fHSphinx Ltd\fP\s0''"
.PF "'\s8Sphinx\s0'Page %'\s8Version $Revision: 1.1 $ $Date: 2002-06-16 07:36:14 $\s0'"
.H 1 "A GUIDED TOUR OF AN FGLBLD APPLICATION"
This section gives you a guided tour around an application generated by \*(fB.
It discusses the various files which are generated ands what is found in them,
using an example database (one which was extensively used while testing \*(fB).
.P
.nr x \n(H1+1
The next main section (Section \nx) describes how the code can be
modified to improve the appearance for the user.
.rr x
.P
There are some conventions observed by all the code generated by \*(fB which
should be pointed out.
These conform with the proposed internal standards at Sphinx, and have been
used as \fIde facto\fP standards on some projects for a considerable time.
.AL
.LI
All \*(i4 keywords are in upper-case.
.LI
All \*(i4 program variable names are in lower-case.
.LI
All references to objects within the database should have
an initial capital letter followed by lower-case letters.
.LI
Objects on the screen are referred to via the \s-2FORMONLY\s0 screen record
or via screen records starting `\*cs_\*d'.
.LI
Program records which are local variables normally consist of the prefix
`\*cr_\*d' followed by a suitable name, frequently that of a table.
.LI
Module variables (a badly documented but supported feature of \*(i4)
are used extensively to cut down on the number of global variables and the
number of globals files.
.LI
The names of module and global variables typically consist of a two character
prefix followed by an underscore and a meaningful name; the name is usually the
name of a table.
.LI
All functions generated by \*(fB have a name consisting of three characters
which are semi-mnemonic followed by an underscore and the name of the table
which the file was generated from.
.LI
All comments which are intended to be kept are enclosed in braces `\*c{}\*d'.
Any comments started by a hash `\*c#\*d' can be deleted.
.LI
Hash comments normally indicate a possible set of code which could be used in
place of (or as well as) the functional code in the function.
The \*cdefluff\*d script removes hash comments that would match the \*Csed\*D
pattern `\*c/# [A-Z]/\*d'; the actual script is more complex because it handles
both the case where the hash comes after some code and where the comment is
all there is on the line.
.LI
The code defers interrupts and monitors the state of \s-2INT_FLAG\s0 to see
whether the user has hit the interrupt key.
It also defers quit signals,
but it ignores the state of \s-2QUIT_FLAG\s0 completely.
.LI
All input is done with the \s-2INPUT WRAP\s0 option set.
.LE 1
'\"
'\" -----------------------------------------------------
'\"
.H 2 "Sample Database"
The database used for the example is called \*cconsult\*d and contains
three tables.
The first table, \fBClients\fP, briefly describes clients;
they are the people who pay for work to be done.
.DF
.FG "The CLIENTS table."
.eS S
.so clients.sql
.eE
.DE
The second table, \fBJobs\fP, describes jobs done on behalf of clients;
there may be several jobs for each client.
.DF
.FG "The JOBS table."
.eS S
.so jobs.sql
.eE
.DE
The third table, \fBTimesheet\fP, records the time spent working
on different jobs.
This version is for a single-user database so there is no
identification of the consultant doing the work.
.DF
.FG "The TIMESHEET table."
.eS S
.so times.sql
.eE
.DE
As you can see from the descriptions, the \fBTimesheet\fP table
cross-references the \fBJobs\fP table, and the \fBJobs\fP table
cross-references the \fBClients\fP table.
.P
The generated \*(sP is based on the \fBTimesheet\fP table;
it has a composite primary key so the \s-2ROWID\s0 was specified
as the primary key when the code was generated.
The menu title was `\s-2TIMESHEET\s0',
and the filename specified was `\*cts\*d'.
'\"
'\" -----------------------------------------------------
'\"
.H 2 "The GLOBALS file \*ctsg.4gl\*d"
This is essentially very simple.
It defines a working record \*cwr_timesheet\*d which is used for all input
and insert/\%delete/\%update operations,
a null record \*cnr_timesheet\*d which is initialised to nulls,
and a copy record \*ccp_timesheet\*d which contains the previous inserted
or displayed value.
The copy record is used when the program user presses control-P or F6.
There is also a control record \*cct_timesheet\*d which wraps most of the
control information needed by \*(fB into a single record.
.DF
.FG "The globals file."
.eS S
.so tsg.4gx
.eE
.DE
'\"
'\" -----------------------------------------------------
'\"
.H 2 "The MAIN file \*ctsm.4gl\*d"
This file will not be shown in full \(em it's big and boring.
It seldom needs much changing.
The cursor positioning code should not be changed without serious study.
'\"
'\" -----------------------------------------------------
'\"
.H 3 "The main program"
The default main program is very simple:
.DF
.FG "The main program."
.eS S
.so tsm1.4gx
.eE
.DE
The variable \*csccs\*d is there to allow version control information
to be embedded in the software.
It is assumed that the generated code will be installed under \*(sS.
Apart from setting options and the help file,
it defers interrupt and quit signals,
opens the window and initialises the \*(sP with \*cwop_timesheet\*d,
calls the main menu function \*cmnu_timesheet\*d,
and then closes the window and terminates the \*(sP with \*cwcl_timesheet\*d.
.P
There is probably merit in the argument which says that the window handling
should be done separately from the \*(sP initialisation and termination.
There should probably be a function \*cwhd_timesheet\*d which would do all the
window handling controlled by an argument \(em it would be a case statement
\(em and there should be another function \*cspi_timesheet\*d which controls
the initialisation and termination of the \*(sP.
This would not matter in the basic \*(sP, but would simplify the division
of labour if several \*(sPs were to be handled by one program.
'\"
'\" -----------------------------------------------------
'\"
.H 3 "The main menu"
The \*cmnu_timesheet\*d function provides the main menu.
This should not need much attention unless you wish to change an
option name or if you modify the behaviour of the Add option.
Note the systematic structure of the options.
.DF
.FG "The main menu (extracts)."
.eS S
.so tsm2.4gx
.eE
.DE
One pleasant feature of the \*(fB \*(sP is that if you use `N' for Next
once and subsequently use \s-2RETURN\s0 to continue stepping through the list,
the list flashes up the message `No more rows going forwards' and changes the
default option to Previous.
If you continue to hit the \s-2RETURN\s0 key, you will step back to the start
of the list, and the message `No more rows going backwards' will be displayed
and the direction of travel will be reversed again.
.P
There is also the facility to type `32N' to go forward 32 items in the list,
or `32P' to go back.
Overshooting the end of the list simply retrieves the last row.
The `23G' facility jumps to the 23rd record in the list,
if there are that many records.
The `F' and `L' options go to the first and last rows respectively.
'\"
'\" -----------------------------------------------------
'\"
.H 3 "The delete control function"
The \*cdel_timesheet\*d function controls what happens when a row is deleted.
It starts a transaction, fetches the current record for update and gets the
user to confirm that the record should be deleted.
The actual delete operation is done by the function \*ciud_timesheet\*d,
which also handles insert and update operations.
The D-List is updated by removing the current record and then
\*ccsr_timesheet\*d is called to sort out what should be displayed next.
.P
Note that unlike the most recent versions of \*(pF, the user does not have to
use either Next or Previous to see the next field after a delete; the next
record in the direction in which the list was being traversed is automatically
displayed after a record is deleted.
The only time this doesn't happen is if the last record in the list id deleted
and then the user is told that all the records have been deleted and is left
with Query as the next option.
.DF
.FG "The delete control function."
.eS S
.so tsm3.4gx
.eE
.DE
'\"
'\" -----------------------------------------------------
'\"
.H 3 "The update control function"
The \*cupd_timesheet\*d function controls what happens when a row is updated.
It starts a transaction, fetches the current record for update, allows the user
to modify the record (via the input code in \*cinp_timesheet\*d) and then
calls \*ciud_timesheet\*d to handle the actual update.
If necessary, the D-List record is updated, and then
\*ccsr_timesheet\*d is called to sort out what should be displayed next.
.DF
.FG "The update control function."
.eS S
.so tsm4.4gx
.eE
.DE
'\"
'\" -----------------------------------------------------
'\"
.H 3 "The insert control function"
The \*cins_timesheet\*d function controls what happens
when the Add option is chosen.
As generated, it starts a transaction and allows the user to add a sequence of
records via \*cinp_timesheet\*d.
As each record is inserted, it is left on the screen for a couple of seconds
before clearing the screen to allow the next record to be added.
There are three keys which terminate the input loop; the interrupt key,
F8 and control-E.
When the loop is terminated, so is the transaction.
The first added record is displayed via \*ccsr_timesheet\*d.
One standard modification is to remove the loop, which is simple enough.
This also requires a modification to \*cmnu_timesheet\*d;
the code there should make Add the next option.
.DF
.FG "The insert control function."
.eS S
.so tsm5.4gx
.eE
.DE
'\"
'\" -----------------------------------------------------
'\"
.H 3 "The cursor position control function"
The \*ccsr_timesheet\*d function is rather complex because it is used to
reposition the cursor in a large number of different ways.
It also has to handle the problems caused by two users working on the table at
the same time and both doing update and delete operations.
It seldom needs modification except for the code which displays the 
number of the current record and the current size of the list.
'\"
'\" -----------------------------------------------------
'\"
.H 2 "The CURSOR file \*ctsc.4gl\*d"
This file is by far the messiest because it contains all the references
to all the cursors used throughout the system.
This means it contains initialisation code, code to handle constructing the
query and fetching the data, and also some of the code to handle reports.
It contains the following functions:
.VL 1.5i 1
.LI wop_timesheet
Open the window.
Create the D-List.
Declare various cursors used elsewhere.
Initialise the null record and the control variables.
.LI wcl_timesheet
Close the window and destroy the D-List.
.LI cns_timesheet
Execute the \s-2CONSTRUCT\s0 statement to allow the user to specify a query.
Prepare and declare an appropriate cursor.
This routine is used in by both \*cqry_timesheet\*d and \*crnq_timesheet\*d.
.LI qry_timesheet
This is the control routine for the Query option and the hidden Same option.
If necessary, it calls \*ccns_timesheet\*d to construct a query, and then
calls \*cnew_timesheet\*d to generate a new list of timesheet records.
.LI new_timesheet
This routine executes the cursor which fetches the data from the database
for the main query, first destroying the D-List and then rebuilding it.
It could be improved to provide some feedback about what it is doing.
.LI iud_timesheet
This is the only function which alters the database.
It contains code to handle insert, delete and update operations.
If deletes and updates must be propagated, this is where the code can be
put, or where the necessary code should be called from.
The working record is assumed to contain the complete new image.
.LI rnq_timesheet
This function allows the user to specify a separate query from the main
list for the report facility.
It is one of the parts which is more likely to be removed.
It is a slight modification of \*cqry_timesheet\*d which does
not handle a D-List.
.LI rdf_timesheet
This is the report driver function.
It uses \*creport_destination\*d to determine where the report should go
and starts the report appropriately.
It will operate on any of a number of different sets of data,
setting the working record and then calling \*crln_timesheet\*d to
get any other data needed by the report and \*crln_timesheet\*d actually
outputs the data to the report function.
.LI gtu_timesheet
This function gets a record for update, thus locking the row to users.
It opens the update cursor and fetches the data; it cannot close the update
cursor as that would release the lock.
.LI edu_timesheet
This function closes the update cursor,
thereby releasing the record which was locked by \*cgtu_timesheet\*d.
Note that if there is a transaction log on the database, the lock is notionally
released by this routine, but if the record was changed, the record
is not actually released until the end of the transaction.
The end of the transaction happens immediately after this routine is called.
.LI get_timesheet
This function retrieves a record without locking it.
It is used for normal display purposes; before an update or delete occurs,
the record is fetched again with \*cgtu_timesheet\*d to lock it.
.LI rch_timesheet
This function is used to determine which set of data should be reported on.
.LI rln_timesheet
This function is used to process each line of data before passing it on to the
report itself.
It can be modified to select extra lookup values if necessary.
.LI wio_timesheet
This function manipulates the window used for input and display.
.LI wbd_timesheet
This function manipulates the border of the screen.
.LI wmn_timesheet
This function manipulates the menu section of the screen.
.LE 1
This code seldom needs much modification; the main changes would be in the
ordering of the data returned by the main query.
Since the main query only returns the primary key data by default,
the \s-2SELECT\s0 statement would need to be augmented by the columns on which
the data was to be sorted, and the retrieving code in \*cnew_timesheet\*d and
\*crdf_timesheet\*d would need to be modified
to handle the extra returned data.
The \s-2SELECT\s0 statement which generates the data for an `All' report
would also need to be modified.
Indeed, it can be argued that it should
also go via \*ccns_timesheet\*d passing an argument to means that
the \s-2CONSTRUCT\s0 statement should be bypassed and a null where clause
inserted; this would mean that only one piece of code would need to be modified
to ensure that the same ordering is used throughout the program.
'\"
'\" -----------------------------------------------------
'\"
.H 2 "The INPUT file"
This is normally the largest file,
and it is the one which most frequently needs editing.
.P
The file defines a number of module variables, including a record
\*cpr_timesheet\*d which is used to preserve the value which was in
the current field of the working record
before the field was entered so that the new value can be compared afterwards
if necessary, or the original value can be restored if the new value is
rejected after validation.
There is also the record \*cfc_timesheet\*d which contains field control
information.
It is used particularly when the user uses F5 (for a popup) or F6 (for
copying the previously displayed value into the current record) to ensure
that if the user was going forwards through the form, the cursor continues
forwards, and if the user was going backwards,
the cursor continues moving backwards.
This is a feature not supported by \*(pF any more.
.P
There are a variable number of routines in this file.
Assuming that there is any input code,
the following routines are always present:
.AL 1 5 1
.LI
dis_timesheet
.LI
hlp_timesheet
.LI
inp_timesheet
.LI
spf_timesheet
.LI
sdf_timesheet
.LI
wi1_timesheet
.LE 1
Additionally, there is a validation function for each column in the table
with names \*cv01_timesheet\*d, \*cv02_timesheet\*d, \*cv03_timesheet\*d, etc.
'\"
'\" -----------------------------------------------------
'\"
.H 3 "Record display function"
As supplied, the function \*cdis_timesheet\*d is trivial and simply displays
the working record to the form.
It is normally modified to do whatever lookups are necessary (using fetch
functions, of course) and then display the associated lookup data.
This function is also called by \*ccsr_timesheet\*d to display whatever row of
data it finds, which ensures uniform display behaviour.
'\"
'\" -----------------------------------------------------
'\"
.H 3 "Input support functions"
The \*chlp_timesheet\*d function is called when the user hits control-F or F7
key and it displays a field-specific help message.
.P
The function \*csdf_timesheet\*d is called whenever a record is being added
to set the default values for a record.
This could make use of any control information available to the program,
including the previous record which was added (which is available in the copy
record \*ccp_timesheet\*d).
By default, it uses the \s-2INITIALIZE\s0 statement.
(In versions of \*(fB up to and including 6.05, this routine is far from
optimal \(em there should be a record which is initialised via
\s-2INITIALIZE\s0 once, and this record should be copied into the working
record; after that, specific initialisations can be performed if necessary.)
.P
The function \*cspf_timesheet\*d should never need modifying;
it simply sets the previous field number in the field control record.
.P
The function \*cwi1_timesheet\*d is used to manipulate the input form.
'\"
'\" -----------------------------------------------------
'\"
.H 3 "The input function"
The input function \*cinp_timesheet\*d is long and repetitious
because \*(i4 forces it to be like that if it is to handle all the input
requirements sensibly.
.DF
.FG "The input function (extracts)."
.eS S
.so tsi1.4gx
.eE
.DE
The main feature of the code is that a single validation function is called
for each field for each of the \s-2BEFORE FIELD\s0 and \s-2AFTER FIELD\s0
actions, and also for the popup (control-B/F5) and copy (control-P/F6)
functionality.
This is crucial for the clean operation of the \*(sP.
In too many hand-crafted programs, the validation code for the one field
is split into three blocks, one for the \s-2AFTER FIELD\s0 clause,
one for the \s-2ON KEY (F5, CONTROL-B)\s0 clause and one for the
\s-2ON KEY (F6, CONTROL-P)\s0 clause \(em if that is provided.
This is apt to be disastrous because when some aspect of the validation changes,
one of the blocks is forgotten and the validation applied now depends on how
the data was entered by the user.
.P
By channelling all these bits through a single function (for each field),
there is some chance that consistent validation will be applied however
user enters the data.
It is, of course, possible to subvert this intention,
but on your own head be it!
.P
Note that there is an abandon input key in the form of the \s-2ON KEY
(F8, CONTROL-E)\s0 clause.
This was originally provided to solve the problem that in \*Cfgldb\*D,
an interrupt transfers control back to the debugger and does not terminate
the input statement;
similarly a quit would only transfer control, not terminate the input.
These keys provide a route to terminate the loop cleanly,
and are sufficiently useful to be retained permanently.
.P
The modifications made to this function are normally either to eliminate
calls in the \s-2ON KEY (F5, CONTROL-B)\s0 block for those fields which
will never be given a popup for the user to choose from, or to add code
for the \s-2AFTER INPUT\s0 clause (which is not provided by default)
or the extra checking spot after the \s-2INPUT\s0 statement
(which is provided).
'\"
'\" -----------------------------------------------------
'\"
.H 3 "The validation functions"
A standard, complete validation function fresh out of \*(fB is shown below.
.DF
.FG "The standard validation function."
.eS S
.so tsi2.4gx
.eE
.DE
The first thing to note is that there are a large number of hash comments,
most of which can be deleted immediately.
If the field is to acquire a popup, the skeletal popup code should be removed
and the code which is hash-commented out should be enabled.
.P
There should almost never be any code in the `AF' case.
This implies that there is some validation which should be done here
which should not be done in other circumstances \(em something which is
unlikely to be sensible.
.P
If a field should have a popup, the code below can be regarded as a
template for the validation process.
.DF
.FG "A validation function with popups."
.eS S
.so tsi3.4gx
.eE
.DE
'\"
'\" -----------------------------------------------------
'\"
.H 2 "The REPORT file"
The report file \*ctsr.4gl\*d contains just a report.
.P
The report itself is only a marginal improvement on a default report.
Consequently, it will need to be extended and written properly.
As the code suggests, there is a hook in the report which
can dynamically configure the dimensions of a report.
This facility works in compiled \*(i4 but is not available in
\*(iR (because the interpreters \*Cfglgo\*D and \*Cfgldb\*D do not compile).
The custom runner generated by \*Cmkfglgo\*D contains dummy functions
which do not reconfigure the report.
'\"
'\" -----------------------------------------------------
'\"
.H 2 "The FORM file"
The form file needs the normal tidying up that any other generated form does.
This means translating the column names into sensible labels, modifying the
layout so that things align better and so on.
It also means adding sensible attributes, especially \s-2COMMENTS\s0
for those fields with a popup so the user is reminded that there ae popups.
Note that the form provided by \*(fB has a blank line before the end of the
screen; this is necessary to avoid having comments and messages overwriting
the data on the bottom line of the form.
.P
Do not reorder the fields on the form or in the attribute section without
consulting the section on modifying the order of the fields \(em this is
a very tricky subject to deal with.
.P
By all means add lookup fields to help the user understand
the coding on the form.
One convention for these fields is to define the screen record \*cs_display\*d
which is where the relevant values are displayed by \*cdis_timesheet\*d.
'\"
'\" -----------------------------------------------------
'\"
.H 2 "The MAKEFILE"
The makefile \*cts.mk\*d can be used for either compiled \*(i4 or for \*(iR.
When you add popups and fetch functions, you should normally append the
\*(i4 file names to the list \*cFILES.o\*d with the extension `\*c.o\*d'
in place of `\*c.4gl\*d', and the form files to the list \*cFILES.frm\*d
with the extension `\*c.frm\*d in place of `\*c.4pr\*d'.
.P
If you want to put the object files into a library, you will need to
handle the library rules instead.
.P
If you ever create code which uses the globals file, do not forget to
add the dependency lines of the form shown by:
.eS
tsc.4go tsc.o:  tsg.4gl
.eE
However, before you add such a rule,
ask yourself `why does this code use the globals file at all?'
There \fIare\fP reasons for doing so, but it is seldom necessary.
'\"
'\" -----------------------------------------------------
'\"
.H 2 "The HELP file"
The help message file \*cts.msg\*d has a default message for each field
in the \s-2INPUT\s0 statement.
You should provide a sensible message in its place.
You may want to modify some of the other messages;
the language is a bit stilted in some places because it has to be
applicable to any possible table.
'\"
'\" -----------------------------------------------------
'\"
.H 2 "The auxilliary files"
Most of the other files provided by \*(fB should not need changing.
The files \*crepdest.4gl\*d and \*crepdest.4pr\*d implement
the function \*creport_destination\*d; you may wish to modify this.
Similarly, the file \*creptype.4gl\*d implements the menu which allows
you to choose which data set should be reported.
.P
The file \*ccheckint.4gl\*d is used to report that an interrupt has been
detected and will be ignored.
This is used in a number of places.
.P
When an internal error is detected, either \*cinternal_error\*d or
\*cfatal_error\*d is called (depending on whether the program can continue
sensibly or not).
These functions are contained in the file \*cinterr.4gl\*d.
.P
The file \*cshell.4gl\*d contains the code which handles shell escapes.
This could be improved; it could also be modified to apply security
restrictions on who can use the option.
The file \*cnxtfield.4gl\*d contains a standard calculation used to determine
which field the cursor should go to next.
.P
The files \*cscrndump.4gl\*d and \*cscrndump.4pr\*d are used to decide which
file a screen dump should be placed in.
.P
The file \*cstdopt.4gl\*d contains the function \*cstd_options\*d which is
conventionally used at the start of every program to set the input and output
options in the standard manner for a project, and also to check the security
clearance of the user.
This file is normally modified for each project; in particular, it uses the
environment variable BASEDIRECTORY to determine where its software is located,
and this will typically need changing to some suitable, project-specific name.
For example, this might become SPHINXDIRECTORY.
The generated code would also need to be modified to use the new name.
.P
The file \*csecurity.4gl\*d is used to check whether the user is authorised
to do a particular action.
It is used within \*cstd_options\*d only, and it works whether or not the
security table exists in the database.
The structure of the security table is assumed to be:
.eS S
.so security.sql
.eE
.P
The file \*ctranslog.4gl\*d implements the functions \*cbegin_work\*d,
\*ccommit_work\*d, \*crollback_work\*d, \*cend_work\*d and \*ctranslog\*d.
These routines enable programs running with the Informix Standard Engine
(\*Csqlexec\*D) to work regardless of whether there is a transaction log on
the database or not.
This code would need modifying to detect whether it is working with some
other engine such as Informix Turbo.
.P
The file \*cinformix.mk\*d contains the rules that \*(mK needs to understand
how to compile \*(iX files of most sorts.
If your version of \*(mK does not understand the rules, the chances are
you have a very old version and you would do better to get hold of \*Crmk\*D.
If your version of \*(mK understands lines of the form:
.eS
include ${BASEDIRECTORY}/etc/informix.mk
.eE
then it is recommended that you put a copy of \*cinformix.mk\*d in one
central directory (e.g. the project's \*cetc\*d directory) and use lines
like the one above in the makefiles.
If you think of modifying the rules to handle functions such as ensuring
that when a program is compiled, a link in a remote directory is kept up to
date, then if your version of \*(mK does not support the construct above,
get hold of a version that does.
