/*
=====================================================================
                        Source: call.rule
=====================================================================
*/


call_cmd	: FCALL call_ext {strcpy($<str>$,"CALL");}
;

call_ext :
    function_callb RETURNING variable { A4GL_debug("print_expr (3)"); 
		print_expr($<ptr>1);
		print_pop_variable($<str>3);
	}
   | GET_FLDBUF OPEN_BRACKET field_name_list_as_struct CLOSE_BRACKET RETURNING  {
        if (!isin_command("INPUT")&&!isin_command("CONSTRUCT")) {
                a4gl_yyerror("get_fldbuf can only be used in an input or construct");
                YYERROR;
        }
	print_getfldbuf(field_name_list_as_char($<field_list>3));
	}
	ibind_var_list {
		print_returning();
	}
   | FORM_IS_COMPILED OPEN_BRACKET identifier KW_COMMA CHAR_VALUE KW_COMMA CHAR_VALUE CLOSE_BRACKET {
	print_form_is_compiled($<str>3,$<str>5,$<str>7);
	}

   | INFIELD OPEN_BRACKET field_name_or_char_as_struct CLOSE_BRACKET RETURNING variable {
		print_field_func('I',field_name_as_char($<field_entry>3),$<str>6);
   }
   | pdf_functions
   | FIELD_TOUCHED OPEN_BRACKET field_name_list_as_struct CLOSE_BRACKET RETURNING variable { 
        if (!isin_command("INPUT")&&!isin_command("CONSTRUCT")) {
                a4gl_yyerror("get_fldbuf can only be used in an input or construct");
                YYERROR;
        }
	print_field_func('T',field_name_list_as_char($<field_list>3),$<str>6);
   } 


   | variable COLON identifier OPEN_BRACKET   {
	new_counter();
   	addmap("Call",$<str>1,curr_func,yylineno,infilename);
   }
   opt_func_call_args 
   CLOSE_BRACKET 
   {
	int a;
	dump_expr($<ptr>6);
	a=get_counter_val();
	drop_counter();
 A4GL_debug("Printing call_func_call...");
  	print_class_func_call($<str>1,$<str>3,$<ptr>6,a);
   }
   opt_return 
   {
	print_returning();
	/* strcpy($<str>$,$<str>5); */
   }

   | variable MEMBER_FUNCTION identifier OPEN_BRACKET   {
	new_counter();
   	addmap("Call",$<str>1,curr_func,yylineno,infilename);
   }
   opt_func_call_args 
   CLOSE_BRACKET 
   {
	int a;
	dump_expr($<ptr>6);
	a=get_counter_val();
	drop_counter();
 A4GL_debug("Printing call_func_call...");
  	print_class_func_call($<str>1,$<str>3,$<ptr>6,a);
   }
   opt_return 
   {
	print_returning();
	/* strcpy($<str>$,$<str>5); */
   }



   | identifier OPEN_BRACKET {
	new_counter();
   	addmap("Call",$<str>1,curr_func,yylineno,infilename);
   } 
   opt_func_call_args 
   {
 A4GL_debug("Got args");
   }
   CLOSE_BRACKET 
   {
	int a;
	dump_expr($<ptr>4);
	a=get_counter_val();
	drop_counter();
  	print_func_call($<str>1,$<ptr>4,a);
	if (strcasecmp($<str>1,"aclfgl_dump_screen")==0) {
		add_feature("DUMP_SCREEN");
	}
   }
   opt_return 
   {
	print_returning();
	/* strcpy($<str>$,$<str>5);  */
   }
   | SHARED char_or_var KW_IN char_or_var OPEN_BRACKET {
	A4GLSQL_set_status(0,0);
	new_counter();
	}
opt_func_call_args {
   sprintf($<str>$,"%d",get_counter_val());drop_counter();
} CLOSE_BRACKET opt_return {
        print_expr ((struct expr_str *)$<ptr>7);  
	print_call_shared($<str>4,$<str>2,atoi($<str>8));
	print_returning();
	print_end_call_shared();
}
   | KW_CHANNEL_READ OPEN_BRACKET char_or_var KW_COMMA OPEN_SQUARE ebind_var_list CLOSE_SQUARE CLOSE_BRACKET  {
                start_bind('i',$<str>3);
                $<ptr>$=get_call_shared_bound_expr("\"channel\"","\"read\"");
	} RETURNING variable {
		print_expr($<ptr>9);
		start_bind('o',$<str>11);
		print_bind_pop1('o');
		
	}
   | KW_CHANNEL_READ OPEN_BRACKET char_or_var KW_COMMA ebind_var_list CLOSE_BRACKET {
                start_bind('i',$<str>3);
                $<ptr>$=get_call_shared_bound_expr("\"channel\"","\"read\"");
	}  RETURNING variable {
		print_expr($<ptr>7);
		start_bind('o',$<str>9);
		print_bind_pop1('o');
	}
   | KW_CHANNEL_WRITE OPEN_BRACKET { new_counter(); } fgl_expr_c KW_COMMA opt_cw_func_call_args CLOSE_BRACKET opt_return {
		void *p;
		int cv;
		p=A4GL_append_expr_expr($<ptr>4,$<ptr>6);
		cv=get_counter_val();
		drop_counter();
        	print_expr ((struct expr_str *)p);  
		print_call_shared("\"channel\"","\"write\"",cv);
		print_returning();
		print_end_call_shared();
	}

   | identifier DOUBLE_COLON identifier  OPEN_BRACKET {
	sprintf($<str>$,"\"%s\",\"%s\"",$<str>1,$<str>3);
	A4GLSQL_set_status(0,0);
	new_counter();
	}
	opt_func_call_args {
   	sprintf($<str>$,"%d",get_counter_val());drop_counter();
	} CLOSE_BRACKET opt_return {
		char buff[256];
		char *ptr;
 		A4GL_debug("STR6 = %s",$<str>5);
		strcpy(buff,$<str>5);
		ptr=strchr(buff,',');
		*ptr=0;
		ptr++;
        	print_expr ((struct expr_str *)$<ptr>6);  
		print_call_shared(buff,ptr,atoi($<str>7));
		print_returning();
		print_end_call_shared();
	}
   | identifier DOT identifier  OPEN_BRACKET {
	if (!isclassvariable($<str>1)) {
		a4gl_yyerror("Not an object");
	}
	if (!isclassmember($<str>1,$<str>3)) {
		a4gl_yyerror("Not a method for the object");
	}

	sprintf($<str>$,"\"%s\",\"%s\"",$<str>1,$<str>3);
	A4GLSQL_set_status(0,0);
	new_counter();
	}
	opt_func_call_args {
   	sprintf($<str>$,"%d",get_counter_val());drop_counter();
	} CLOSE_BRACKET opt_return {
		char buff[256];
		char *ptr;
 		A4GL_debug("STR6 = %s",$<str>5);
		strcpy(buff,$<str>5);
		ptr=strchr(buff,',');
		*ptr=0;
		ptr++;
        	print_expr ((struct expr_str *)$<ptr>6);  
		print_call_shared(buff,ptr,atoi($<str>7));
		print_returning();
		print_end_call_shared();
	}
   | EXTERNAL remote_host_name COLON remote_func_name OPEN_SQUARE valid_port CLOSE_SQUARE OPEN_BRACKET
   {
   char buff[256];
   new_counter();
   sprintf(buff,"%s:%s(%p)",$<str>2,$<str>4,$<str>6);
   addmap("External",buff,curr_func,yylineno,infilename);
   } 
   opt_func_call_args 
   {
   sprintf($<str>$,"%d",get_counter_val());drop_counter();
   }
   CLOSE_BRACKET 
   {
	 A4GL_debug("print_expr (6)");print_expr($<ptr>10);
   }
   opt_return_remote
   { 
   	/* int cnt; */
	char fname[64];
	
   if (strcmp($<str>14,"WITHOUT WAITING")==0) {	
	strcpy(fname,"1,");
	strcat(fname,$<str>4);
   } else {
	strcpy(fname,"0,");
	strcat(fname,$<str>4);
   }
	
   print_call_external($<str>2,fname,$<str>6,atoi($<str>11));

   if (strcmp($<str>14,"WITHOUT WAITING")!=0) {	
	print_returning();
   }
   print_end_call_external();
  }
   
;

opt_return 	: {start_bind('i',0);strcpy($<str>$,"0");} | RETURNING ibind_var_list {strcpy($<str>$,$<str>2);
}
;

opt_return_remote 	: {start_bind('i',0);strcpy($<str>$,"0");} 
                  | RETURNING ibind_var_list {strcpy($<str>$,$<str>2);}
                  | WITHOUT_WAITING {strcpy($<str>$,"WITHOUT WAITING"); }
;


opt_func_call_args : 
		/*empty*/ {
			$<ptr>$=A4GL_new_expr("");
		}
		| func_call_args  {
			$<ptr>$=$<ptr>1;
		}
;

func_call_args	: func_arg
		{
	$<ptr>$=$<ptr>1;
}
		| func_call_args KW_COMMA func_arg {
		$<ptr>$=A4GL_append_expr_expr($<ptr>1,$<ptr>3);
}

;



func_arg 	:	fgl_expr_c 
	| KW_NULL {$<ptr>$=A4GL_new_expr("A4GL_push_null(2,0);");inc_counter();}
;

remote_host_name : CHAR_VALUE | identifier
{
sprintf($<str>$,"\"%s\"",$<str>1);
}
;

remote_func_name : identifier 
{
sprintf($<str>$,"\"%s\"",$<str>1);
} 
| identifier DOT identifier { sprintf($<str>$,"\"%s.%s\"",$<str>1,$<str>3); }
;


/* ============================= call.rule ========================== */
