:	"@(#)$Id: updnmd.sh,v 1.1 2002-11-28 06:40:47 afalout Exp $"
#
#	@(#)SQLFMT Version 14 (1998-11-04)
#
#	Update a Non-Modifiable Source Distribution data file

arg0=`basename $0 .sh`
usage="Usage: $arg0 directory nmd-file [...]"

: ${PRS:=prs}
: ${RLOG:=rlog}
export PRS RLOG

if [ $# -eq 0 ]
then
	echo "$usage" >&2
	exit 1
fi

SOURCEDIR=${1}
shift
if [ ! -d $SOURCEDIR ]
then
	echo "$arg0: $SOURCEDIR is not a directory" >&2
	echo "$usage" >&2
	exit 1
fi

tmp=${TMPDIR:-/tmp}/$arg0.$$
trap "rm -f $tmp.1 $tmp.2 $tmp.3 ; exit 1" 1 2 3 13 15

# This is an entertaining SED script.
# It takes an NMD file and creates a shell script which will
# produce a revised version of the NMD file.
# -- It recognises comment lines (which start with a #) and blank
#    lines and arranges for them to be copied to the output file.
# -- It does the same for assignments (which contain an equals sign).
# -- On other lines (which must be file descriptions), it not only
#    arranges for the line to be copied, it also arranges for the
#    current SCCS version to be determined and printed on the next
#    line in an easily recognisable format.
cat <<'EOF' >$tmp.1
1a\
version(){\
	set -x\
	case `basename $1` in\
	s.*)	$PRS -d:I: $1;;\
	*,v)	$RLOG -h $1 | sed -e '/^head: /!d' -e 's/head: //';;\
	*)		echo "<uncontrolled>";;\
	esac\
	set +x\
}
/^#/{
i\
cat <<'!'
p
i\
!
d
}
/^$/{
i\
cat <<'!'\
\
!
d
}
/=/{
p
i\
cat <<'!'
p
i\
!
d
}
i\
cat <<'!'
p
i\
!
s%\([^ 	][^[ 	]*\)[ 	][ 	]*\([^ 	][^ 	]*\)[ 	].*%echo "--@ `version XXXX\2 2>/dev/null`"%
EOF

# This is a remarkably straight-forward SED script
# -- When it encounters an end of here-document followed by
#    the start of the next here document, it deletes both lines.
#    This cuts down vastly on the number of processes which are run.
# -- It also does a substitution for XXXX, because the script which
#    put the XXXX in place was quite hard enough without having to
#    worry about whether things were escaped enough times or not.
cat >$tmp.3 <<EOF
/^!\$/N
/^!\\ncat <<'!'\$/d
s%version XXXX%version $SOURCEDIR/%
EOF

# This is another entertaining SED script.
# It takes the output from the shell script generated by running the
# first script through the second script and into the shell, and
# converts it back into an NMD file.
# -- It initialises the hold space with --@, which is a marker.
# -- For lines which start with the marker, it adds the pattern space
#    to the hold space and exchanges the hold and pattern space.  It
#    then replaces a version number followed by a newline, the marker
#    and a version number by the just the new version number, but
#    replaces a version number followed by a newline and just the
#    marker by just the version number.  This replaces the old version
#    number with the new one (when there is a new version number).
#    The line is printed and deleted.
# -- Note that this code allows for an optional single word after the
#    version number.  At the moment, the only valid value is 'binary' which
#    indicates that the file should not be version stamped by mknmd.
# -- On any line which does not start with the marker, the line is
#    copied into the hold space, and if the original hold space
#    started with the marker, the line is deleted.  Otherwise, of
#    course, it is printed.
cat >$tmp.2 <<'EOF'
1{
x
s/^/--@/
x
}
/^--@ /{
H
x
s/\([ 	]\)[0-9.][0-9.]*\n--@ \([0-9.]\)/\1\2/
s/\([ 	]\)[0-9.][0-9.]*\([ 	][ 	]*[^ 	]*\)\n--@ \([0-9.][0-9.]*\)/\1\3\2/
s/\([ 	][0-9.][0-9.]*\)\n--@ $/\1/
s/\([ 	][0-9.][0-9.]*[ 	][ 	]*[^ 	]*\)\n--@ $/\1/
p
d
}
/^--@/!{
x
/^--@/d
}
EOF

# If $DEBUG is yes, record the intermediate results.
if [ "$DEBUG" = yes ]
then
	cp $tmp.1 tmp.1
	cp $tmp.2 tmp.2
	cp $tmp.3 tmp.3
	tee4="| tee tmp.4"
	tee5="| tee tmp.5"
	tee6="| tee tmp.6"
	tee7="| tee tmp.7"
fi

# The evals are there in case $DEBUG was yes.
# The hieroglyphs on the shell line pass on any control arguments
# (like -x) to the sub-shell if they are set for the parent shell.
for file in $*
do
	eval sed -f $tmp.1 $file	$tee4 |
	eval sed -f $tmp.3			$tee5 |
	eval sh ${-+"-$-"}			$tee6 |
	eval sed -f $tmp.2			$tee7 |
	sed  -e '1s/^[ 	]*$/--@/' -e '/^--@/d'
done

rm -f $tmp.1 $tmp.2 $tmp.3
