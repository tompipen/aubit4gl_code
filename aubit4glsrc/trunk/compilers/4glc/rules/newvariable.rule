/*
=====================================================================
                        Source: newvariable.rule
=====================================================================
*/


variable: var_int
{
char buff[256];
char buff2[256];
int n;
strcpy(buff,$<str>1);
lex_printcomment("/* .. var %s*/",buff);
if (buff[0]!=' ') addmap("Use Variable",buff,curr_func,yylineno,infilename);

if (strncmp(buff," ASSOCIATE_",11)!=0) {
	convlower(buff);
}

strcpy($<str>$,buff);
debug("Checking variable '%s'",buff);
n=scan_variable(buff);

  debug("scan variable returns -> %d\n",n);

  if (n == -1&&buff[0]!=' ') {
           sprintf(buff2,"'%s' does not represent a defined variable (1)",buff);
           a4gl_yyerror(buff2);
           exit (0);
  }
  if (strstr(buff,".*") && n!=-2) {
		char *ptr;
		printf("WARNING : Using a .* on a non-record - %s\n",$<str>1);
		ptr=strstr(buff,".*");
		*ptr=0;
		strcpy($<str>$,buff);
  }
 
  mcnt = 0;
}
;


var_int :
	var | DOLLAR var {strcpy($<str>$,$<str>2);}
;

varsetidentdot : var setident DOT
;

var: 
 varsetidentdot dot_part_var { 
         sprintf ($<str>$, "%s.%s", $<str>1, $<str>2); 
         lex_printcomment("/* record building -> %s */\n",$<str>$);
         }
| 
 varsetidentdot identifier OPEN_SQUARE num_list CLOSE_SQUARE {

         int type,arrsize,size,level;
         char buff[256];
         char buff2[256];
         char arrbuff[256];

         lex_printcomment("/* OPEN_SQUARE.. */\n");

         sprintf(buff,"%s.%s",$<str>1,$<str>2);
         if (scan_variable(buff)==-1) {
           sprintf(buff2,"'%s' does not represent a defined variable (2)",buff);
           a4gl_yyerror(buff2);
           YYERROR;
         }

         lex_printcomment("/*variable with [...]*/");
         get_variable_dets (buff,&type,&arrsize,&size,&level,arrbuff);
         lex_printcomment("/* Arrsize = %d size = %d*/",arrsize,size);
	 
         if (arrsize>0)
         {
             debug("Is array...");
             sprintf ($<str>$, "%s[%s]", buff, change_arr_elem($<str>4));
             lex_printcomment ("/* array variable %s num_arr_elem=%d arrbuff=%d*/\n", $<str>$,num_arr_elem($<str>4),num_arr_elem(arrbuff));
         }
         else
         {
             debug ("Is string...");
             sprintf ($<str>$, " substr(%s , %d , %s , 0 ) /*1*/", buff,
                      (int)scan_variable (buff), $<str>4);

             addmap("Use Variable",buff,curr_func,yylineno,infilename);
             lex_printcomment ("/*character variable %s*/\n", $<str>$);
         }

         mcnt++;
}
| array_r_variable
| identifier
| assoc_var_read
;

assoc_var_read  : identifier OPEN_SHEV assoc_sub CLOSE_SHEV
{
char buff2[256];
         if (scan_variable($<str>1)==-1) {
           sprintf(buff2,"'%s' does not represent a defined variable (3)",$<str>1);
           a4gl_yyerror(buff2); 
           YYERROR;
         }

lex_printcomment("/*Associative Variable : %s*/\n",$<str>3);
sprintf($<str>$," ASSOCIATE_%s(%s,1)",upshift($<str>1),$<str>3);
};


assoc_var_write  : identifier OPEN_SHEV assoc_sub CLOSE_SHEV
{
char buff2[256];
         if (scan_variable($<str>1)==-1) {
           sprintf(buff2,"'%s' does not represent a defined variable (4)",$<str>1);
           a4gl_yyerror(buff2); 
           YYERROR;
         }
lex_printcomment("/*Associative Variable : %s*/\n",$<str>3);
sprintf($<str>$," ASSOCIATE_%s(%s,0)",upshift($<str>1),$<str>3);
};

assoc_sub : variable | CHAR_VALUE
;


dot_part_var:
 MULTIPLY | 
 identifier 
;



array_r_variable:
identifier arr_subscripts
{
  int type,arrsize,size,level;
  char buff2[256];
  char arrbuff[256];
  lex_printcomment("/*array variable nnn */");
  get_variable_dets ($<str>1,&type,&arrsize,&size,&level,arrbuff);
  lex_printcomment("/*here %s %x */",$<str>1,type);
  if (scan_variable($<str>1)==-1) {
           sprintf(buff2,"'%s' does not represent a defined variable (7)",$<str>1);
           a4gl_yyerror(buff2); 
           YYERROR;

	}


  debug("Type=%d (%d) arrsize=%d",type,type&0xffff,arrsize);

  if (strchr($<str>2,':'))  {
	char lbuff[256];
	char rbuff[256];
	char tmpbuff[256];
	char *ptr;
	strcpy(lbuff,$<str>2);
	strcpy(rbuff,strchr($<str>2,':')+1);
	ptr=strchr(lbuff,':');
	*ptr=0;
        sprintf (tmpbuff, "%s[%s]", $<str>1, change_arr_elem(lbuff));
        sprintf ($<str>$, " substr(%s,%d,%s,0) /*2*/", tmpbuff, (int)scan_variable (tmpbuff), rbuff);
  } else {
 
  if ((type & (0xffff != 0)) || (arrsize>0))
    {
      lex_printcomment("/* changing optbase for array: %s */\n",$<str>2);
      sprintf ($<str>$, "%s[%s]", $<str>1, change_arr_elem($<str>2));
      lex_printcomment ("/* array variable %s*/\n", $<str>$);
    }
  else
    {
      sprintf ($<str>$, " substr(%s,0x%x,%s,0)/*3*/", $<str>1, (int)scan_variable ($<str>1), $<str>2);
             addmap("Use Variable",$<str>1,curr_func,yylineno,infilename);
      lex_printcomment ("/*character variable %s*/\n", $<str>$);
      	dec_counter();
      	mcnt--;
    }
}

  mcnt++;
}
;




arr_subscripts : 
	OPEN_SQUARE num_list CLOSE_SQUARE {
		debug("---> Subscript or substring");
		strcpy($<str>$,$<str>2);
	}
|
	OPEN_SQUARE num_list CLOSE_SQUARE OPEN_SQUARE num_list CLOSE_SQUARE {
		debug("---> Subscript & substring");
		sprintf($<str>$,"%s:%s",$<str>2,$<str>5);
	}
;


num_list: num_list_element
{
debug("List element");
  sprintf ($<str>$, "%s", $<str>1);
}
|num_list COMMA num_list_element
{
debug("List element continues");
  sprintf ($<str>$, "%s,%s", $<str>1, $<str>3);
}

;

num_list_element: arr_expr
{
  sprintf ($<str>$, "%s", $<str>1);
};


let_variable: let_var
{
char buff[256];
strcpy(buff,$<str>1);
addmap("Let Variable",buff,curr_func,yylineno,infilename);

if (strncmp(buff," ASSOCIATE_",11)!=0) {
convlower(buff);
}
strcpy($<str>$,buff);
lex_printcomment("/* %s */\n",$<str>1);
  if (scan_variable (buff) == -1&&buff[0]!=' ')
    {
      lex_printcomment ("/*NOt a variable*/");
      sprintf(buff,"%s is not a variable",$<str>1);
      a4gl_yyerror(buff);
    }

  mcnt = 0;
};

let_var: let_array_r_variable {
		debug("Array..");
}
| let_var setident DOT let_var_dot { sprintf ($<str>$, "%s.%s", $<str>1, $<str>4); }
| let_var setident DOT identifier OPEN_SQUARE num_list CLOSE_SQUARE
{
  int a;
  int b;
  char buff[256];
  char buff2[256];
  lex_printcomment("/*array variable .let. */");

  sprintf($<str>$,"%s.%s",$<str>1,$<str>4);

         if (scan_variable($<str>$)==-1) {
           sprintf(buff2,"'%s' does not represent a defined variable (5)",$<str>$);
           a4gl_yyerror(buff2); 
           YYERROR;
         }

  debug("?1arrvar=%s",$<str>$);
  b = isarrvariable ($<str>$);
  a = scan_variable ($<str>$);

  lex_printcomment("/*a=%x b=%x */\n",a,b);

  if (b != 0)
    {
      sprintf ($<str>$, "%s.%s[%s-1] ", $<str>1, $<str>4,$<str>6);
      lex_printcomment ("/* array variable %s*/\n", $<str>$);
    }
  else
    {
      sprintf(buff,"%s.%s",$<str>1,$<str>4);
      sprintf ($<str>$, " let_substr(%s,%d,%s,0)", buff, a, $<str>6);
      addmap("Let Variable",buff,curr_func,yylineno,infilename);
      lex_printcomment ("/*character variable %s*/\n", $<str>$);
    }

  mcnt++;

}
| identifier
| assoc_var_write
;

let_var_dot :
MULTIPLY 
| identifier 
;

let_array_r_variable:
identifier arr_subscripts
{
/*OPEN_SQUARE num_list CLOSE_SQUARE*/
  int a;
  int b;
  char buff2[256];
  lex_printcomment("/*.let. array variable */");

  debug("?2 arrvar=%s",$<str>1);
  if (strchr($<str>2,':'))  {
	char lbuff[256];
	char rbuff[256];
	char tmpbuff[256];
	char *ptr;
	strcpy(lbuff,$<str>2);
	strcpy(rbuff,strchr($<str>2,':')+1);
	ptr=strchr(lbuff,':');
	*ptr=0;
        sprintf (tmpbuff, "%s[%s]", $<str>1, change_arr_elem(lbuff));
        sprintf ($<str>$, " let_substr(%s,%d,%s,0)", tmpbuff, (int)scan_variable (tmpbuff), rbuff);
  } else {
  	b = isarrvariable ($<str>1);
  	a = scan_variable ($<str>1);

         if (a==-1) {
           sprintf(buff2,"'%s' does not represent a defined variable (6)",$<str>1);
           a4gl_yyerror(buff2); 
           YYERROR;
         }


  debug("/*a=%d b=%d*/\n",a,b);

  if (b != 0)
    {
      sprintf ($<str>$, "%s[%s]", $<str>1, decode_array_string($<str>2));
      debug ("/* array variable %s*/\n", $<str>$);
    }
  else
    {
      sprintf ($<str>$, " let_substr(%s,%d,%s,0)", $<str>1, (int)scan_variable ($<str>1), $<str>2);

      addmap("Let Variable",$<str>1,curr_func,yylineno,infilename);
      debug ("/*character variable %s*/\n", $<str>$);
    }
 }
  mcnt++;

}
;



op_param_var_list: {
start_bind('f',0);
start_bind('O',0);
strcpy($<str>$,"0");}
| fparam_var_list;


fparam_var_list:	func_def_var {
start_bind('f',$<str>1);
start_bind('O',$<str>1);
sprintf($<str>$,"1");
}
	|	
fparam_var_list COMMA func_def_var {
int c;
c=add_bind('f',$<str>3);
c=add_bind('O',$<str>3);
sprintf($<str>$,"%d",c); 
}
;




ibind_var_list:	ibind_var {
lex_printcomment("/*STarted bind %s*/\n",$<str>1);
start_bind('i',$<str>1);
lex_printcomment("/*STarted bind 2*/\n");
strcpy($<str>$,"");
}
	|	
ibind_var_list COMMA ibind_var {
lex_printcomment("/* Added */\n");
add_bind('i',$<str>3);
strcpy($<str>$,"");
}
;


func_def_var : identifier | identifier DOT identifier {sprintf($<str>$,"%s.%s",$<str>1,$<str>2);}
;

ibind_var : variable  {lex_printcomment("/* Variable */\n");}
	| variable THRU variable { debug("Got an ibind thru..."); sprintf($<str>$,"%s\n%s",$<str>1,$<str>3); }
	| CHAR_VALUE 
	| real_number {sprintf($<str>$,"\"%s\"",$<str>1);}
	| INT_VALUE {sprintf($<str>$,"\"%s\"",$<str>1);}
;

obind_var_list:	obind_var  {
start_bind('o',$<str>1);
} 
	|	obind_var_list COMMA obind_var {
add_bind('o',$<str>3);
strcpy($<str>$,"");
}
;

obind_var : variable   {
	addmap("OBIND",$<str>1,curr_func,yylineno,infilename);
	}
	| variable THRU variable { debug("Got an obind thru..."); sprintf($<str>$,"%s\n%s",$<str>1,$<str>3); }
;


obind_var_let_list:	obind_let_var  {
lex_printcomment("/* start obind with  %s*/\n",$<str>1);
start_bind('o',$<str>1);
} 
	|	obind_var_let_list COMMA obind_let_var {
lex_printcomment("/* add to obind %s */\n",$<str>3);
add_bind('o',$<str>3);
strcpy($<str>$,"");
}
;

obind_let_var : let_variable   {
lex_printcomment("/* Read variable %s*/\n",$<str>1);
}
;

use_arr_var : variable {
    lex_printcomment("/* use_arr_var */\n");
    start_arr_bind('o',$<str>1);
    lex_printcomment("/* use_arr_var complete */\n");
}
;

obind_var_list_ord:	obind_var_ord  {
start_bind('O',$<str>1);
} 
	| obind_var_list_ord COMMA obind_var_ord {
               add_bind('O',$<str>3);
               strcpy($<str>$,"");
}
;

obind_var_ord : variable optional_asc_desc;

optional_asc_desc: | ASC | DESC;


array_r_varid:
identifier OPEN_SQUARE num_list CLOSE_SQUARE
{
  int type,arrsize,size,level;
  char arrbuff[256];
  lex_printcomment("/*..array_r_varid..*/");

if (get_variable_dets ($<str>1,&type,&arrsize,&size,&level,arrbuff)>=0) {
  sprintf($<str>$,"%s[%s]",$<str>1,subtract_one($<str>3));
} else {
  sprintf($<str>$,"%s[%s]",$<str>1,$<str>3);
}
}
;

init_bind_var_list:	init_bind_var {
lex_printcomment("/*STarted bind %s*/\n",$<str>1);
start_bind('N',$<str>1);
lex_printcomment("/*STarted bind 2*/\n");
strcpy($<str>$,"");
}
	|	
init_bind_var_list COMMA init_bind_var {
lex_printcomment("/* Added */\n");
add_bind('N',$<str>3);
strcpy($<str>$,"");
}
;

init_bind_var : variable  {
		strcpy($<str>$,$<str>1);
	}
	| variable THRU variable {
			sprintf($<str>$,"%s\n%s",$<str>1,$<str>3);
		}
;

/* ========================= newvariable.rule ======================= */

