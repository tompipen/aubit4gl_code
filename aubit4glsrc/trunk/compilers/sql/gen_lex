cat << EOF


%{

%}
/*
Generated by gen_lex
*/


%e 1000
%p 4000
%n 700
%k 200
%a 4000
%o 4200
%x comment
ws 	[ \t\n]*
ident [a-zA-Z]+[a-zA-Z\_0-9]* 
int_num [0-9]+
char_value \'[^\']+\'|\"\"|\"[^\"]+\"|\'\'
%option yylineno
%%

<comment>"}"    {BEGIN INITIAL;}
<comment>.      ;
<comment>[\n]   ;
"{"      { BEGIN comment; yymore(); }
--.*$  {yymore();}

EOF







grep "token" 2.reqd | awk '{print $2}' | (while read a
do
#echo $a >> /dev/tty
grep "^$a[ 	]" ../4glc/rules/data/kwords | awk '
{
    #print "/* " $0 " */"
    printf("\n");
    for (a=2;a<=NF;a++) {
        if (a!=2) printf("{ws}");
	printed=0;
	if ($a=="<ident>") {printf("{ident}");printed=1;}
	if ($a=="<int_num>") {printf("{int_num}");printed=1;}
	if ($a=="<char_value>") {printf("{char_value}");printed=1;}
	if (printed==0) {
        	printf "\"" $a "\""
	}
    }
    printf(" { a4gl_upshift(yytext); strcpy(yylval.str,yytext);  return %s;}\n",$1)
}
'




done)

cat << EOF

{ws}	;
[\n]	;
";"	{strcpy(yylval.str,";"); return SEMICOLON;}
"?"	{strcpy(yylval.str,"?"); return QUESTION_MARK;}
{ident} {strcpy(yylval.str,yytext);return NAMED;}

"!=" {  strcpy(yylval.str,yytext); return NOT_EQUAL;}
"<>" {  strcpy(yylval.str,yytext); return NOT_EQUAL;}
"<=" {  strcpy(yylval.str,yytext); return LESS_THAN_EQ;}
">=" {  strcpy(yylval.str,yytext); return GREATER_THAN_EQ;}
\"[^\"]+\" {  strcpy(yylval.str,yytext); return CHAR_VALUE;}
\"\" {  strcpy(yylval.str,yytext); return CHAR_VALUE;}
\'[^\']+\' {  strcpy(yylval.str,yytext); return CHAR_VALUE;}
\'\' {  strcpy(yylval.str,yytext); return CHAR_VALUE;}

{int_num}  {strcpy(yylval.str, yytext); return(INT_VALUE);}
[0-9]+|[0-9]*\.[0-9]+   {strcpy(yylval.str, yytext); return(NUMBER_VALUE);}

. 	{strcpy(yylval.str,yytext);return CH;}

%%
EOF


