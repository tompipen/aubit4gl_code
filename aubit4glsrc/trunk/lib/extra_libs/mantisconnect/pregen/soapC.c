/* soapC.c
   Generated by gSOAP 2.7.17 from outfile.h
   Copyright(C) 2000-2010, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC.c ver 2.7.17 2010-08-07 14:57:53 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	if ((soap->header = (struct SOAP_ENV__Header*)soap_malloc(soap, sizeof(struct SOAP_ENV__Header))))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = (struct SOAP_ENV__Reason*)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason));
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_xsd__byte:
		return soap_in_xsd__byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_unsignedByte:
		return soap_in_unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_xsd__boolean:
		return soap_in_xsd__boolean(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREcheckin:
		return soap_in_ns1__mc_USCOREissue_USCOREcheckin(soap, NULL, NULL, "ns1:mc_issue_checkin");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREcheckinResponse:
		return soap_in_ns1__mc_USCOREissue_USCOREcheckinResponse(soap, NULL, NULL, "ns1:mc_issue_checkinResponse");
	case SOAP_TYPE_ns1__mc_USCOREconfig_USCOREget_USCOREstring:
		return soap_in_ns1__mc_USCOREconfig_USCOREget_USCOREstring(soap, NULL, NULL, "ns1:mc_config_get_string");
	case SOAP_TYPE_ns1__mc_USCOREconfig_USCOREget_USCOREstringResponse:
		return soap_in_ns1__mc_USCOREconfig_USCOREget_USCOREstringResponse(soap, NULL, NULL, "ns1:mc_config_get_stringResponse");
	case SOAP_TYPE_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheaders:
		return soap_in_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheaders(soap, NULL, NULL, "ns1:mc_filter_get_issue_headers");
	case SOAP_TYPE_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse:
		return soap_in_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse(soap, NULL, NULL, "ns1:mc_filter_get_issue_headersResponse");
	case SOAP_TYPE_ns1__mc_USCOREfilter_USCOREget_USCOREissues:
		return soap_in_ns1__mc_USCOREfilter_USCOREget_USCOREissues(soap, NULL, NULL, "ns1:mc_filter_get_issues");
	case SOAP_TYPE_ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse:
		return soap_in_ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse(soap, NULL, NULL, "ns1:mc_filter_get_issuesResponse");
	case SOAP_TYPE_ns1__mc_USCOREfilter_USCOREget:
		return soap_in_ns1__mc_USCOREfilter_USCOREget(soap, NULL, NULL, "ns1:mc_filter_get");
	case SOAP_TYPE_ns1__mc_USCOREfilter_USCOREgetResponse:
		return soap_in_ns1__mc_USCOREfilter_USCOREgetResponse(soap, NULL, NULL, "ns1:mc_filter_getResponse");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREdelete:
		return soap_in_ns1__mc_USCOREproject_USCOREattachment_USCOREdelete(soap, NULL, NULL, "ns1:mc_project_attachment_delete");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREdeleteResponse:
		return soap_in_ns1__mc_USCOREproject_USCOREattachment_USCOREdeleteResponse(soap, NULL, NULL, "ns1:mc_project_attachment_deleteResponse");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREadd:
		return soap_in_ns1__mc_USCOREproject_USCOREattachment_USCOREadd(soap, NULL, NULL, "ns1:mc_project_attachment_add");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREaddResponse:
		return soap_in_ns1__mc_USCOREproject_USCOREattachment_USCOREaddResponse(soap, NULL, NULL, "ns1:mc_project_attachment_addResponse");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREget:
		return soap_in_ns1__mc_USCOREproject_USCOREattachment_USCOREget(soap, NULL, NULL, "ns1:mc_project_attachment_get");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREgetResponse:
		return soap_in_ns1__mc_USCOREproject_USCOREattachment_USCOREgetResponse(soap, NULL, NULL, "ns1:mc_project_attachment_getResponse");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfields:
		return soap_in_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfields(soap, NULL, NULL, "ns1:mc_project_get_custom_fields");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse:
		return soap_in_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse(soap, NULL, NULL, "ns1:mc_project_get_custom_fieldsResponse");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREattachments:
		return soap_in_ns1__mc_USCOREproject_USCOREget_USCOREattachments(soap, NULL, NULL, "ns1:mc_project_get_attachments");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse:
		return soap_in_ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse(soap, NULL, NULL, "ns1:mc_project_get_attachmentsResponse");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversions:
		return soap_in_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversions(soap, NULL, NULL, "ns1:mc_project_get_unreleased_versions");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse:
		return soap_in_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse(soap, NULL, NULL, "ns1:mc_project_get_unreleased_versionsResponse");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversions:
		return soap_in_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversions(soap, NULL, NULL, "ns1:mc_project_get_released_versions");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse:
		return soap_in_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse(soap, NULL, NULL, "ns1:mc_project_get_released_versionsResponse");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREdelete:
		return soap_in_ns1__mc_USCOREproject_USCOREversion_USCOREdelete(soap, NULL, NULL, "ns1:mc_project_version_delete");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREdeleteResponse:
		return soap_in_ns1__mc_USCOREproject_USCOREversion_USCOREdeleteResponse(soap, NULL, NULL, "ns1:mc_project_version_deleteResponse");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREupdate:
		return soap_in_ns1__mc_USCOREproject_USCOREversion_USCOREupdate(soap, NULL, NULL, "ns1:mc_project_version_update");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREupdateResponse:
		return soap_in_ns1__mc_USCOREproject_USCOREversion_USCOREupdateResponse(soap, NULL, NULL, "ns1:mc_project_version_updateResponse");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREadd:
		return soap_in_ns1__mc_USCOREproject_USCOREversion_USCOREadd(soap, NULL, NULL, "ns1:mc_project_version_add");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREaddResponse:
		return soap_in_ns1__mc_USCOREproject_USCOREversion_USCOREaddResponse(soap, NULL, NULL, "ns1:mc_project_version_addResponse");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREversions:
		return soap_in_ns1__mc_USCOREproject_USCOREget_USCOREversions(soap, NULL, NULL, "ns1:mc_project_get_versions");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse:
		return soap_in_ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse(soap, NULL, NULL, "ns1:mc_project_get_versionsResponse");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREcategories:
		return soap_in_ns1__mc_USCOREproject_USCOREget_USCOREcategories(soap, NULL, NULL, "ns1:mc_project_get_categories");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse:
		return soap_in_ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse(soap, NULL, NULL, "ns1:mc_project_get_categoriesResponse");
	case SOAP_TYPE_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessible:
		return soap_in_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessible(soap, NULL, NULL, "ns1:mc_projects_get_user_accessible");
	case SOAP_TYPE_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse:
		return soap_in_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse(soap, NULL, NULL, "ns1:mc_projects_get_user_accessibleResponse");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREusers:
		return soap_in_ns1__mc_USCOREproject_USCOREget_USCOREusers(soap, NULL, NULL, "ns1:mc_project_get_users");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREusersResponse:
		return soap_in_ns1__mc_USCOREproject_USCOREget_USCOREusersResponse(soap, NULL, NULL, "ns1:mc_project_get_usersResponse");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheaders:
		return soap_in_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheaders(soap, NULL, NULL, "ns1:mc_project_get_issue_headers");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse:
		return soap_in_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse(soap, NULL, NULL, "ns1:mc_project_get_issue_headersResponse");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREissues:
		return soap_in_ns1__mc_USCOREproject_USCOREget_USCOREissues(soap, NULL, NULL, "ns1:mc_project_get_issues");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse:
		return soap_in_ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse(soap, NULL, NULL, "ns1:mc_project_get_issuesResponse");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREdelete:
		return soap_in_ns1__mc_USCOREproject_USCOREdelete(soap, NULL, NULL, "ns1:mc_project_delete");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREdeleteResponse:
		return soap_in_ns1__mc_USCOREproject_USCOREdeleteResponse(soap, NULL, NULL, "ns1:mc_project_deleteResponse");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREadd:
		return soap_in_ns1__mc_USCOREproject_USCOREadd(soap, NULL, NULL, "ns1:mc_project_add");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREaddResponse:
		return soap_in_ns1__mc_USCOREproject_USCOREaddResponse(soap, NULL, NULL, "ns1:mc_project_addResponse");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREget:
		return soap_in_ns1__mc_USCOREissue_USCOREattachment_USCOREget(soap, NULL, NULL, "ns1:mc_issue_attachment_get");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREgetResponse:
		return soap_in_ns1__mc_USCOREissue_USCOREattachment_USCOREgetResponse(soap, NULL, NULL, "ns1:mc_issue_attachment_getResponse");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREdelete:
		return soap_in_ns1__mc_USCOREissue_USCOREattachment_USCOREdelete(soap, NULL, NULL, "ns1:mc_issue_attachment_delete");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREdeleteResponse:
		return soap_in_ns1__mc_USCOREissue_USCOREattachment_USCOREdeleteResponse(soap, NULL, NULL, "ns1:mc_issue_attachment_deleteResponse");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREadd:
		return soap_in_ns1__mc_USCOREissue_USCOREattachment_USCOREadd(soap, NULL, NULL, "ns1:mc_issue_attachment_add");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREaddResponse:
		return soap_in_ns1__mc_USCOREissue_USCOREattachment_USCOREaddResponse(soap, NULL, NULL, "ns1:mc_issue_attachment_addResponse");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCORErelationship_USCOREdelete:
		return soap_in_ns1__mc_USCOREissue_USCORErelationship_USCOREdelete(soap, NULL, NULL, "ns1:mc_issue_relationship_delete");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCORErelationship_USCOREdeleteResponse:
		return soap_in_ns1__mc_USCOREissue_USCORErelationship_USCOREdeleteResponse(soap, NULL, NULL, "ns1:mc_issue_relationship_deleteResponse");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCORErelationship_USCOREadd:
		return soap_in_ns1__mc_USCOREissue_USCORErelationship_USCOREadd(soap, NULL, NULL, "ns1:mc_issue_relationship_add");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCORErelationship_USCOREaddResponse:
		return soap_in_ns1__mc_USCOREissue_USCORErelationship_USCOREaddResponse(soap, NULL, NULL, "ns1:mc_issue_relationship_addResponse");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREnote_USCOREdelete:
		return soap_in_ns1__mc_USCOREissue_USCOREnote_USCOREdelete(soap, NULL, NULL, "ns1:mc_issue_note_delete");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREnote_USCOREdeleteResponse:
		return soap_in_ns1__mc_USCOREissue_USCOREnote_USCOREdeleteResponse(soap, NULL, NULL, "ns1:mc_issue_note_deleteResponse");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREnote_USCOREadd:
		return soap_in_ns1__mc_USCOREissue_USCOREnote_USCOREadd(soap, NULL, NULL, "ns1:mc_issue_note_add");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREnote_USCOREaddResponse:
		return soap_in_ns1__mc_USCOREissue_USCOREnote_USCOREaddResponse(soap, NULL, NULL, "ns1:mc_issue_note_addResponse");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREdelete:
		return soap_in_ns1__mc_USCOREissue_USCOREdelete(soap, NULL, NULL, "ns1:mc_issue_delete");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREdeleteResponse:
		return soap_in_ns1__mc_USCOREissue_USCOREdeleteResponse(soap, NULL, NULL, "ns1:mc_issue_deleteResponse");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREupdate:
		return soap_in_ns1__mc_USCOREissue_USCOREupdate(soap, NULL, NULL, "ns1:mc_issue_update");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREupdateResponse:
		return soap_in_ns1__mc_USCOREissue_USCOREupdateResponse(soap, NULL, NULL, "ns1:mc_issue_updateResponse");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREadd:
		return soap_in_ns1__mc_USCOREissue_USCOREadd(soap, NULL, NULL, "ns1:mc_issue_add");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREaddResponse:
		return soap_in_ns1__mc_USCOREissue_USCOREaddResponse(soap, NULL, NULL, "ns1:mc_issue_addResponse");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummary:
		return soap_in_ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummary(soap, NULL, NULL, "ns1:mc_issue_get_id_from_summary");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummaryResponse:
		return soap_in_ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummaryResponse(soap, NULL, NULL, "ns1:mc_issue_get_id_from_summaryResponse");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREid:
		return soap_in_ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREid(soap, NULL, NULL, "ns1:mc_issue_get_biggest_id");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREidResponse:
		return soap_in_ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREidResponse(soap, NULL, NULL, "ns1:mc_issue_get_biggest_idResponse");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREget:
		return soap_in_ns1__mc_USCOREissue_USCOREget(soap, NULL, NULL, "ns1:mc_issue_get");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREgetResponse:
		return soap_in_ns1__mc_USCOREissue_USCOREgetResponse(soap, NULL, NULL, "ns1:mc_issue_getResponse");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREexists:
		return soap_in_ns1__mc_USCOREissue_USCOREexists(soap, NULL, NULL, "ns1:mc_issue_exists");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREexistsResponse:
		return soap_in_ns1__mc_USCOREissue_USCOREexistsResponse(soap, NULL, NULL, "ns1:mc_issue_existsResponse");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREget:
		return soap_in_ns1__mc_USCOREenum_USCOREget(soap, NULL, NULL, "ns1:mc_enum_get");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREgetResponse:
		return soap_in_ns1__mc_USCOREenum_USCOREgetResponse(soap, NULL, NULL, "ns1:mc_enum_getResponse");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypes:
		return soap_in_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypes(soap, NULL, NULL, "ns1:mc_enum_custom_field_types");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse:
		return soap_in_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse(soap, NULL, NULL, "ns1:mc_enum_custom_field_typesResponse");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREview_USCOREstates:
		return soap_in_ns1__mc_USCOREenum_USCOREview_USCOREstates(soap, NULL, NULL, "ns1:mc_enum_view_states");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse:
		return soap_in_ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse(soap, NULL, NULL, "ns1:mc_enum_view_statesResponse");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstates:
		return soap_in_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstates(soap, NULL, NULL, "ns1:mc_enum_project_view_states");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse:
		return soap_in_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse(soap, NULL, NULL, "ns1:mc_enum_project_view_statesResponse");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREproject_USCOREstatus:
		return soap_in_ns1__mc_USCOREenum_USCOREproject_USCOREstatus(soap, NULL, NULL, "ns1:mc_enum_project_status");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse:
		return soap_in_ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse(soap, NULL, NULL, "ns1:mc_enum_project_statusResponse");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREaccess_USCORElevels:
		return soap_in_ns1__mc_USCOREenum_USCOREaccess_USCORElevels(soap, NULL, NULL, "ns1:mc_enum_access_levels");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse:
		return soap_in_ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse(soap, NULL, NULL, "ns1:mc_enum_access_levelsResponse");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREresolutions:
		return soap_in_ns1__mc_USCOREenum_USCOREresolutions(soap, NULL, NULL, "ns1:mc_enum_resolutions");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREresolutionsResponse:
		return soap_in_ns1__mc_USCOREenum_USCOREresolutionsResponse(soap, NULL, NULL, "ns1:mc_enum_resolutionsResponse");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREetas:
		return soap_in_ns1__mc_USCOREenum_USCOREetas(soap, NULL, NULL, "ns1:mc_enum_etas");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREetasResponse:
		return soap_in_ns1__mc_USCOREenum_USCOREetasResponse(soap, NULL, NULL, "ns1:mc_enum_etasResponse");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREprojections:
		return soap_in_ns1__mc_USCOREenum_USCOREprojections(soap, NULL, NULL, "ns1:mc_enum_projections");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREprojectionsResponse:
		return soap_in_ns1__mc_USCOREenum_USCOREprojectionsResponse(soap, NULL, NULL, "ns1:mc_enum_projectionsResponse");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREreproducibilities:
		return soap_in_ns1__mc_USCOREenum_USCOREreproducibilities(soap, NULL, NULL, "ns1:mc_enum_reproducibilities");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREreproducibilitiesResponse:
		return soap_in_ns1__mc_USCOREenum_USCOREreproducibilitiesResponse(soap, NULL, NULL, "ns1:mc_enum_reproducibilitiesResponse");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREseverities:
		return soap_in_ns1__mc_USCOREenum_USCOREseverities(soap, NULL, NULL, "ns1:mc_enum_severities");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREseveritiesResponse:
		return soap_in_ns1__mc_USCOREenum_USCOREseveritiesResponse(soap, NULL, NULL, "ns1:mc_enum_severitiesResponse");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREpriorities:
		return soap_in_ns1__mc_USCOREenum_USCOREpriorities(soap, NULL, NULL, "ns1:mc_enum_priorities");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREprioritiesResponse:
		return soap_in_ns1__mc_USCOREenum_USCOREprioritiesResponse(soap, NULL, NULL, "ns1:mc_enum_prioritiesResponse");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREstatus:
		return soap_in_ns1__mc_USCOREenum_USCOREstatus(soap, NULL, NULL, "ns1:mc_enum_status");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREstatusResponse:
		return soap_in_ns1__mc_USCOREenum_USCOREstatusResponse(soap, NULL, NULL, "ns1:mc_enum_statusResponse");
	case SOAP_TYPE_ns1__mc_USCOREversion:
		return soap_in_ns1__mc_USCOREversion(soap, NULL, NULL, "ns1:mc_version");
	case SOAP_TYPE_ns1__mc_USCOREversionResponse:
		return soap_in_ns1__mc_USCOREversionResponse(soap, NULL, NULL, "ns1:mc_versionResponse");
	case SOAP_TYPE_CustomFieldLinkForProjectDataArray:
		return soap_in_CustomFieldLinkForProjectDataArray(soap, NULL, NULL, "ns1:CustomFieldLinkForProjectData");
	case SOAP_TYPE_CustomFieldDefinitionDataArray:
		return soap_in_CustomFieldDefinitionDataArray(soap, NULL, NULL, "ns1:CustomFieldDefinitionData");
	case SOAP_TYPE_FilterDataArray:
		return soap_in_FilterDataArray(soap, NULL, NULL, "ns1:FilterData");
	case SOAP_TYPE_ProjectVersionDataArray:
		return soap_in_ProjectVersionDataArray(soap, NULL, NULL, "ns1:ProjectVersionData");
	case SOAP_TYPE_IssueHeaderDataArray:
		return soap_in_IssueHeaderDataArray(soap, NULL, NULL, "ns1:IssueHeaderData");
	case SOAP_TYPE_IssueDataArray:
		return soap_in_IssueDataArray(soap, NULL, NULL, "ns1:IssueData");
	case SOAP_TYPE_ProjectAttachmentDataArray:
		return soap_in_ProjectAttachmentDataArray(soap, NULL, NULL, "ns1:ProjectAttachmentData");
	case SOAP_TYPE_AccountDataArray:
		return soap_in_AccountDataArray(soap, NULL, NULL, "ns1:AccountData");
	case SOAP_TYPE_ObjectRefArray:
		return soap_in_ObjectRefArray(soap, NULL, NULL, "ns1:ObjectRef");
	case SOAP_TYPE_StringArray:
		return soap_in_StringArray(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ns1__CustomFieldValueForIssueData:
		return soap_in_ns1__CustomFieldValueForIssueData(soap, NULL, NULL, "ns1:CustomFieldValueForIssueData");
	case SOAP_TYPE_ns1__CustomFieldLinkForProjectData:
		return soap_in_ns1__CustomFieldLinkForProjectData(soap, NULL, NULL, "ns1:CustomFieldLinkForProjectData");
	case SOAP_TYPE_ns1__CustomFieldDefinitionData:
		return soap_in_ns1__CustomFieldDefinitionData(soap, NULL, NULL, "ns1:CustomFieldDefinitionData");
	case SOAP_TYPE_ns1__FilterData:
		return soap_in_ns1__FilterData(soap, NULL, NULL, "ns1:FilterData");
	case SOAP_TYPE_ns1__ProjectVersionData:
		return soap_in_ns1__ProjectVersionData(soap, NULL, NULL, "ns1:ProjectVersionData");
	case SOAP_TYPE_ProjectDataArray:
		return soap_in_ProjectDataArray(soap, NULL, NULL, "ns1:ProjectData");
	case SOAP_TYPE_ns1__ProjectData:
		return soap_in_ns1__ProjectData(soap, NULL, NULL, "ns1:ProjectData");
	case SOAP_TYPE_ns1__IssueHeaderData:
		return soap_in_ns1__IssueHeaderData(soap, NULL, NULL, "ns1:IssueHeaderData");
	case SOAP_TYPE_CustomFieldValueForIssueDataArray:
		return soap_in_CustomFieldValueForIssueDataArray(soap, NULL, NULL, "ns1:CustomFieldValueForIssueData");
	case SOAP_TYPE_IssueNoteDataArray:
		return soap_in_IssueNoteDataArray(soap, NULL, NULL, "ns1:IssueNoteData");
	case SOAP_TYPE_RelationshipDataArray:
		return soap_in_RelationshipDataArray(soap, NULL, NULL, "ns1:RelationshipData");
	case SOAP_TYPE_AttachmentDataArray:
		return soap_in_AttachmentDataArray(soap, NULL, NULL, "ns1:AttachmentData");
	case SOAP_TYPE_ns1__IssueData:
		return soap_in_ns1__IssueData(soap, NULL, NULL, "ns1:IssueData");
	case SOAP_TYPE_ns1__IssueNoteData:
		return soap_in_ns1__IssueNoteData(soap, NULL, NULL, "ns1:IssueNoteData");
	case SOAP_TYPE_ns1__RelationshipData:
		return soap_in_ns1__RelationshipData(soap, NULL, NULL, "ns1:RelationshipData");
	case SOAP_TYPE_ns1__ProjectAttachmentData:
		return soap_in_ns1__ProjectAttachmentData(soap, NULL, NULL, "ns1:ProjectAttachmentData");
	case SOAP_TYPE_ns1__AttachmentData:
		return soap_in_ns1__AttachmentData(soap, NULL, NULL, "ns1:AttachmentData");
	case SOAP_TYPE_ns1__AccountData:
		return soap_in_ns1__AccountData(soap, NULL, NULL, "ns1:AccountData");
	case SOAP_TYPE_ns1__ObjectRef:
		return soap_in_ns1__ObjectRef(soap, NULL, NULL, "ns1:ObjectRef");
	case SOAP_TYPE_xsd__base64Binary:
		return soap_in_xsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_PointerTons1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse:
		return soap_in_PointerTons1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse(soap, NULL, NULL, "ns1:mc_filter_get_issue_headersResponse");
	case SOAP_TYPE_PointerTons1__mc_USCOREfilter_USCOREget_USCOREissuesResponse:
		return soap_in_PointerTons1__mc_USCOREfilter_USCOREget_USCOREissuesResponse(soap, NULL, NULL, "ns1:mc_filter_get_issuesResponse");
	case SOAP_TYPE_PointerTons1__mc_USCOREfilter_USCOREgetResponse:
		return soap_in_PointerTons1__mc_USCOREfilter_USCOREgetResponse(soap, NULL, NULL, "ns1:mc_filter_getResponse");
	case SOAP_TYPE_PointerToFilterDataArray:
		return soap_in_PointerToFilterDataArray(soap, NULL, NULL, "ns1:FilterData");
	case SOAP_TYPE_PointerTons1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse:
		return soap_in_PointerTons1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse(soap, NULL, NULL, "ns1:mc_project_get_custom_fieldsResponse");
	case SOAP_TYPE_PointerToCustomFieldDefinitionDataArray:
		return soap_in_PointerToCustomFieldDefinitionDataArray(soap, NULL, NULL, "ns1:CustomFieldDefinitionData");
	case SOAP_TYPE_PointerTons1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse:
		return soap_in_PointerTons1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse(soap, NULL, NULL, "ns1:mc_project_get_attachmentsResponse");
	case SOAP_TYPE_PointerToProjectAttachmentDataArray:
		return soap_in_PointerToProjectAttachmentDataArray(soap, NULL, NULL, "ns1:ProjectAttachmentData");
	case SOAP_TYPE_PointerTons1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse:
		return soap_in_PointerTons1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse(soap, NULL, NULL, "ns1:mc_project_get_unreleased_versionsResponse");
	case SOAP_TYPE_PointerTons1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse:
		return soap_in_PointerTons1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse(soap, NULL, NULL, "ns1:mc_project_get_released_versionsResponse");
	case SOAP_TYPE_PointerTons1__mc_USCOREproject_USCOREget_USCOREversionsResponse:
		return soap_in_PointerTons1__mc_USCOREproject_USCOREget_USCOREversionsResponse(soap, NULL, NULL, "ns1:mc_project_get_versionsResponse");
	case SOAP_TYPE_PointerToProjectVersionDataArray:
		return soap_in_PointerToProjectVersionDataArray(soap, NULL, NULL, "ns1:ProjectVersionData");
	case SOAP_TYPE_PointerTons1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse:
		return soap_in_PointerTons1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse(soap, NULL, NULL, "ns1:mc_project_get_categoriesResponse");
	case SOAP_TYPE_PointerToStringArray:
		return soap_in_PointerToStringArray(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTons1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse:
		return soap_in_PointerTons1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse(soap, NULL, NULL, "ns1:mc_projects_get_user_accessibleResponse");
	case SOAP_TYPE_PointerTons1__mc_USCOREproject_USCOREget_USCOREusersResponse:
		return soap_in_PointerTons1__mc_USCOREproject_USCOREget_USCOREusersResponse(soap, NULL, NULL, "ns1:mc_project_get_usersResponse");
	case SOAP_TYPE_PointerToAccountDataArray:
		return soap_in_PointerToAccountDataArray(soap, NULL, NULL, "ns1:AccountData");
	case SOAP_TYPE_PointerTons1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse:
		return soap_in_PointerTons1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse(soap, NULL, NULL, "ns1:mc_project_get_issue_headersResponse");
	case SOAP_TYPE_PointerToIssueHeaderDataArray:
		return soap_in_PointerToIssueHeaderDataArray(soap, NULL, NULL, "ns1:IssueHeaderData");
	case SOAP_TYPE_PointerTons1__mc_USCOREproject_USCOREget_USCOREissuesResponse:
		return soap_in_PointerTons1__mc_USCOREproject_USCOREget_USCOREissuesResponse(soap, NULL, NULL, "ns1:mc_project_get_issuesResponse");
	case SOAP_TYPE_PointerToIssueDataArray:
		return soap_in_PointerToIssueDataArray(soap, NULL, NULL, "ns1:IssueData");
	case SOAP_TYPE_PointerToxsd__base64Binary:
		return soap_in_PointerToxsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_PointerToxsd__integer:
		return soap_in_PointerToxsd__integer(soap, NULL, NULL, "xsd:integer");
	case SOAP_TYPE_PointerTons1__mc_USCOREissue_USCOREgetResponse:
		return soap_in_PointerTons1__mc_USCOREissue_USCOREgetResponse(soap, NULL, NULL, "ns1:mc_issue_getResponse");
	case SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse:
		return soap_in_PointerTons1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse(soap, NULL, NULL, "ns1:mc_enum_custom_field_typesResponse");
	case SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREview_USCOREstatesResponse:
		return soap_in_PointerTons1__mc_USCOREenum_USCOREview_USCOREstatesResponse(soap, NULL, NULL, "ns1:mc_enum_view_statesResponse");
	case SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse:
		return soap_in_PointerTons1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse(soap, NULL, NULL, "ns1:mc_enum_project_view_statesResponse");
	case SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREproject_USCOREstatusResponse:
		return soap_in_PointerTons1__mc_USCOREenum_USCOREproject_USCOREstatusResponse(soap, NULL, NULL, "ns1:mc_enum_project_statusResponse");
	case SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse:
		return soap_in_PointerTons1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse(soap, NULL, NULL, "ns1:mc_enum_access_levelsResponse");
	case SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREresolutionsResponse:
		return soap_in_PointerTons1__mc_USCOREenum_USCOREresolutionsResponse(soap, NULL, NULL, "ns1:mc_enum_resolutionsResponse");
	case SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREetasResponse:
		return soap_in_PointerTons1__mc_USCOREenum_USCOREetasResponse(soap, NULL, NULL, "ns1:mc_enum_etasResponse");
	case SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREprojectionsResponse:
		return soap_in_PointerTons1__mc_USCOREenum_USCOREprojectionsResponse(soap, NULL, NULL, "ns1:mc_enum_projectionsResponse");
	case SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREreproducibilitiesResponse:
		return soap_in_PointerTons1__mc_USCOREenum_USCOREreproducibilitiesResponse(soap, NULL, NULL, "ns1:mc_enum_reproducibilitiesResponse");
	case SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREseveritiesResponse:
		return soap_in_PointerTons1__mc_USCOREenum_USCOREseveritiesResponse(soap, NULL, NULL, "ns1:mc_enum_severitiesResponse");
	case SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREprioritiesResponse:
		return soap_in_PointerTons1__mc_USCOREenum_USCOREprioritiesResponse(soap, NULL, NULL, "ns1:mc_enum_prioritiesResponse");
	case SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREstatusResponse:
		return soap_in_PointerTons1__mc_USCOREenum_USCOREstatusResponse(soap, NULL, NULL, "ns1:mc_enum_statusResponse");
	case SOAP_TYPE_PointerToObjectRefArray:
		return soap_in_PointerToObjectRefArray(soap, NULL, NULL, "ns1:ObjectRef");
	case SOAP_TYPE_PointerToPointerTons1__CustomFieldValueForIssueData:
		return soap_in_PointerToPointerTons1__CustomFieldValueForIssueData(soap, NULL, NULL, "ns1:CustomFieldValueForIssueData");
	case SOAP_TYPE_PointerTons1__CustomFieldValueForIssueData:
		return soap_in_PointerTons1__CustomFieldValueForIssueData(soap, NULL, NULL, "ns1:CustomFieldValueForIssueData");
	case SOAP_TYPE_PointerToPointerTons1__CustomFieldLinkForProjectData:
		return soap_in_PointerToPointerTons1__CustomFieldLinkForProjectData(soap, NULL, NULL, "ns1:CustomFieldLinkForProjectData");
	case SOAP_TYPE_PointerTons1__CustomFieldLinkForProjectData:
		return soap_in_PointerTons1__CustomFieldLinkForProjectData(soap, NULL, NULL, "ns1:CustomFieldLinkForProjectData");
	case SOAP_TYPE_PointerToPointerTons1__CustomFieldDefinitionData:
		return soap_in_PointerToPointerTons1__CustomFieldDefinitionData(soap, NULL, NULL, "ns1:CustomFieldDefinitionData");
	case SOAP_TYPE_PointerTons1__CustomFieldDefinitionData:
		return soap_in_PointerTons1__CustomFieldDefinitionData(soap, NULL, NULL, "ns1:CustomFieldDefinitionData");
	case SOAP_TYPE_PointerToPointerTons1__FilterData:
		return soap_in_PointerToPointerTons1__FilterData(soap, NULL, NULL, "ns1:FilterData");
	case SOAP_TYPE_PointerTons1__FilterData:
		return soap_in_PointerTons1__FilterData(soap, NULL, NULL, "ns1:FilterData");
	case SOAP_TYPE_PointerToPointerTons1__ProjectVersionData:
		return soap_in_PointerToPointerTons1__ProjectVersionData(soap, NULL, NULL, "ns1:ProjectVersionData");
	case SOAP_TYPE_PointerTons1__ProjectVersionData:
		return soap_in_PointerTons1__ProjectVersionData(soap, NULL, NULL, "ns1:ProjectVersionData");
	case SOAP_TYPE_PointerToPointerTons1__ProjectData:
		return soap_in_PointerToPointerTons1__ProjectData(soap, NULL, NULL, "ns1:ProjectData");
	case SOAP_TYPE_PointerTons1__ProjectData:
		return soap_in_PointerTons1__ProjectData(soap, NULL, NULL, "ns1:ProjectData");
	case SOAP_TYPE_PointerToPointerTons1__IssueHeaderData:
		return soap_in_PointerToPointerTons1__IssueHeaderData(soap, NULL, NULL, "ns1:IssueHeaderData");
	case SOAP_TYPE_PointerTons1__IssueHeaderData:
		return soap_in_PointerTons1__IssueHeaderData(soap, NULL, NULL, "ns1:IssueHeaderData");
	case SOAP_TYPE_PointerToPointerTons1__IssueData:
		return soap_in_PointerToPointerTons1__IssueData(soap, NULL, NULL, "ns1:IssueData");
	case SOAP_TYPE_PointerTons1__IssueData:
		return soap_in_PointerTons1__IssueData(soap, NULL, NULL, "ns1:IssueData");
	case SOAP_TYPE_PointerToPointerTons1__IssueNoteData:
		return soap_in_PointerToPointerTons1__IssueNoteData(soap, NULL, NULL, "ns1:IssueNoteData");
	case SOAP_TYPE_PointerTons1__IssueNoteData:
		return soap_in_PointerTons1__IssueNoteData(soap, NULL, NULL, "ns1:IssueNoteData");
	case SOAP_TYPE_PointerToPointerTons1__RelationshipData:
		return soap_in_PointerToPointerTons1__RelationshipData(soap, NULL, NULL, "ns1:RelationshipData");
	case SOAP_TYPE_PointerTons1__RelationshipData:
		return soap_in_PointerTons1__RelationshipData(soap, NULL, NULL, "ns1:RelationshipData");
	case SOAP_TYPE_PointerToPointerTons1__ProjectAttachmentData:
		return soap_in_PointerToPointerTons1__ProjectAttachmentData(soap, NULL, NULL, "ns1:ProjectAttachmentData");
	case SOAP_TYPE_PointerTons1__ProjectAttachmentData:
		return soap_in_PointerTons1__ProjectAttachmentData(soap, NULL, NULL, "ns1:ProjectAttachmentData");
	case SOAP_TYPE_PointerToPointerTons1__AttachmentData:
		return soap_in_PointerToPointerTons1__AttachmentData(soap, NULL, NULL, "ns1:AttachmentData");
	case SOAP_TYPE_PointerTons1__AttachmentData:
		return soap_in_PointerTons1__AttachmentData(soap, NULL, NULL, "ns1:AttachmentData");
	case SOAP_TYPE_PointerToPointerTons1__AccountData:
		return soap_in_PointerToPointerTons1__AccountData(soap, NULL, NULL, "ns1:AccountData");
	case SOAP_TYPE_PointerToPointerTons1__ObjectRef:
		return soap_in_PointerToPointerTons1__ObjectRef(soap, NULL, NULL, "ns1:ObjectRef");
	case SOAP_TYPE_PointerTostring:
		return soap_in_PointerTostring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerToxsd__byte:
		return soap_in_PointerToxsd__byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_PointerToProjectDataArray:
		return soap_in_PointerToProjectDataArray(soap, NULL, NULL, "ns1:ProjectData");
	case SOAP_TYPE_PointerToxsd__boolean:
		return soap_in_PointerToxsd__boolean(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerToCustomFieldValueForIssueDataArray:
		return soap_in_PointerToCustomFieldValueForIssueDataArray(soap, NULL, NULL, "ns1:CustomFieldValueForIssueData");
	case SOAP_TYPE_PointerToIssueNoteDataArray:
		return soap_in_PointerToIssueNoteDataArray(soap, NULL, NULL, "ns1:IssueNoteData");
	case SOAP_TYPE_PointerToRelationshipDataArray:
		return soap_in_PointerToRelationshipDataArray(soap, NULL, NULL, "ns1:RelationshipData");
	case SOAP_TYPE_PointerToAttachmentDataArray:
		return soap_in_PointerToAttachmentDataArray(soap, NULL, NULL, "ns1:AttachmentData");
	case SOAP_TYPE_PointerTons1__AccountData:
		return soap_in_PointerTons1__AccountData(soap, NULL, NULL, "ns1:AccountData");
	case SOAP_TYPE_PointerTons1__ObjectRef:
		return soap_in_PointerTons1__ObjectRef(soap, NULL, NULL, "ns1:ObjectRef");
	case SOAP_TYPE_PointerTotime:
		return soap_in_PointerTotime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_xsd__integer:
	{	char **s;
		s = soap_in_xsd__integer(soap, NULL, NULL, "xsd:integer");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_in_PointerTounsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_xsd__anyURI:
	{	char **s;
		s = soap_in_xsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
		return s ? *s : NULL;
	}
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_xsd__byte;
			return soap_in_xsd__byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_xsd__boolean;
			return soap_in_xsd__boolean(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_issue_checkin"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREissue_USCOREcheckin;
			return soap_in_ns1__mc_USCOREissue_USCOREcheckin(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_issue_checkinResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREissue_USCOREcheckinResponse;
			return soap_in_ns1__mc_USCOREissue_USCOREcheckinResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_config_get_string"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREconfig_USCOREget_USCOREstring;
			return soap_in_ns1__mc_USCOREconfig_USCOREget_USCOREstring(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_config_get_stringResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREconfig_USCOREget_USCOREstringResponse;
			return soap_in_ns1__mc_USCOREconfig_USCOREget_USCOREstringResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_filter_get_issue_headers"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheaders;
			return soap_in_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheaders(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_filter_get_issue_headersResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse;
			return soap_in_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_filter_get_issues"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREfilter_USCOREget_USCOREissues;
			return soap_in_ns1__mc_USCOREfilter_USCOREget_USCOREissues(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_filter_get_issuesResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse;
			return soap_in_ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_filter_get"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREfilter_USCOREget;
			return soap_in_ns1__mc_USCOREfilter_USCOREget(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_filter_getResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREfilter_USCOREgetResponse;
			return soap_in_ns1__mc_USCOREfilter_USCOREgetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_project_attachment_delete"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREdelete;
			return soap_in_ns1__mc_USCOREproject_USCOREattachment_USCOREdelete(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_project_attachment_deleteResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREdeleteResponse;
			return soap_in_ns1__mc_USCOREproject_USCOREattachment_USCOREdeleteResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_project_attachment_add"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREadd;
			return soap_in_ns1__mc_USCOREproject_USCOREattachment_USCOREadd(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_project_attachment_addResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREaddResponse;
			return soap_in_ns1__mc_USCOREproject_USCOREattachment_USCOREaddResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_project_attachment_get"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREget;
			return soap_in_ns1__mc_USCOREproject_USCOREattachment_USCOREget(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_project_attachment_getResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREgetResponse;
			return soap_in_ns1__mc_USCOREproject_USCOREattachment_USCOREgetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_project_get_custom_fields"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfields;
			return soap_in_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfields(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_project_get_custom_fieldsResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse;
			return soap_in_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_project_get_attachments"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREattachments;
			return soap_in_ns1__mc_USCOREproject_USCOREget_USCOREattachments(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_project_get_attachmentsResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse;
			return soap_in_ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_project_get_unreleased_versions"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversions;
			return soap_in_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_project_get_unreleased_versionsResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse;
			return soap_in_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_project_get_released_versions"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversions;
			return soap_in_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_project_get_released_versionsResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse;
			return soap_in_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_project_version_delete"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREdelete;
			return soap_in_ns1__mc_USCOREproject_USCOREversion_USCOREdelete(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_project_version_deleteResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREdeleteResponse;
			return soap_in_ns1__mc_USCOREproject_USCOREversion_USCOREdeleteResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_project_version_update"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREupdate;
			return soap_in_ns1__mc_USCOREproject_USCOREversion_USCOREupdate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_project_version_updateResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREupdateResponse;
			return soap_in_ns1__mc_USCOREproject_USCOREversion_USCOREupdateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_project_version_add"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREadd;
			return soap_in_ns1__mc_USCOREproject_USCOREversion_USCOREadd(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_project_version_addResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREaddResponse;
			return soap_in_ns1__mc_USCOREproject_USCOREversion_USCOREaddResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_project_get_versions"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREversions;
			return soap_in_ns1__mc_USCOREproject_USCOREget_USCOREversions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_project_get_versionsResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse;
			return soap_in_ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_project_get_categories"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREcategories;
			return soap_in_ns1__mc_USCOREproject_USCOREget_USCOREcategories(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_project_get_categoriesResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse;
			return soap_in_ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_projects_get_user_accessible"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessible;
			return soap_in_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessible(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_projects_get_user_accessibleResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse;
			return soap_in_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_project_get_users"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREusers;
			return soap_in_ns1__mc_USCOREproject_USCOREget_USCOREusers(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_project_get_usersResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREusersResponse;
			return soap_in_ns1__mc_USCOREproject_USCOREget_USCOREusersResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_project_get_issue_headers"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheaders;
			return soap_in_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheaders(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_project_get_issue_headersResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse;
			return soap_in_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_project_get_issues"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREissues;
			return soap_in_ns1__mc_USCOREproject_USCOREget_USCOREissues(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_project_get_issuesResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse;
			return soap_in_ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_project_delete"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREproject_USCOREdelete;
			return soap_in_ns1__mc_USCOREproject_USCOREdelete(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_project_deleteResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREproject_USCOREdeleteResponse;
			return soap_in_ns1__mc_USCOREproject_USCOREdeleteResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_project_add"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREproject_USCOREadd;
			return soap_in_ns1__mc_USCOREproject_USCOREadd(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_project_addResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREproject_USCOREaddResponse;
			return soap_in_ns1__mc_USCOREproject_USCOREaddResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_issue_attachment_get"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREget;
			return soap_in_ns1__mc_USCOREissue_USCOREattachment_USCOREget(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_issue_attachment_getResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREgetResponse;
			return soap_in_ns1__mc_USCOREissue_USCOREattachment_USCOREgetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_issue_attachment_delete"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREdelete;
			return soap_in_ns1__mc_USCOREissue_USCOREattachment_USCOREdelete(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_issue_attachment_deleteResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREdeleteResponse;
			return soap_in_ns1__mc_USCOREissue_USCOREattachment_USCOREdeleteResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_issue_attachment_add"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREadd;
			return soap_in_ns1__mc_USCOREissue_USCOREattachment_USCOREadd(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_issue_attachment_addResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREaddResponse;
			return soap_in_ns1__mc_USCOREissue_USCOREattachment_USCOREaddResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_issue_relationship_delete"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREissue_USCORErelationship_USCOREdelete;
			return soap_in_ns1__mc_USCOREissue_USCORErelationship_USCOREdelete(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_issue_relationship_deleteResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREissue_USCORErelationship_USCOREdeleteResponse;
			return soap_in_ns1__mc_USCOREissue_USCORErelationship_USCOREdeleteResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_issue_relationship_add"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREissue_USCORErelationship_USCOREadd;
			return soap_in_ns1__mc_USCOREissue_USCORErelationship_USCOREadd(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_issue_relationship_addResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREissue_USCORErelationship_USCOREaddResponse;
			return soap_in_ns1__mc_USCOREissue_USCORErelationship_USCOREaddResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_issue_note_delete"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREissue_USCOREnote_USCOREdelete;
			return soap_in_ns1__mc_USCOREissue_USCOREnote_USCOREdelete(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_issue_note_deleteResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREissue_USCOREnote_USCOREdeleteResponse;
			return soap_in_ns1__mc_USCOREissue_USCOREnote_USCOREdeleteResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_issue_note_add"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREissue_USCOREnote_USCOREadd;
			return soap_in_ns1__mc_USCOREissue_USCOREnote_USCOREadd(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_issue_note_addResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREissue_USCOREnote_USCOREaddResponse;
			return soap_in_ns1__mc_USCOREissue_USCOREnote_USCOREaddResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_issue_delete"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREissue_USCOREdelete;
			return soap_in_ns1__mc_USCOREissue_USCOREdelete(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_issue_deleteResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREissue_USCOREdeleteResponse;
			return soap_in_ns1__mc_USCOREissue_USCOREdeleteResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_issue_update"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREissue_USCOREupdate;
			return soap_in_ns1__mc_USCOREissue_USCOREupdate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_issue_updateResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREissue_USCOREupdateResponse;
			return soap_in_ns1__mc_USCOREissue_USCOREupdateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_issue_add"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREissue_USCOREadd;
			return soap_in_ns1__mc_USCOREissue_USCOREadd(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_issue_addResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREissue_USCOREaddResponse;
			return soap_in_ns1__mc_USCOREissue_USCOREaddResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_issue_get_id_from_summary"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummary;
			return soap_in_ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_issue_get_id_from_summaryResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummaryResponse;
			return soap_in_ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummaryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_issue_get_biggest_id"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREid;
			return soap_in_ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREid(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_issue_get_biggest_idResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREidResponse;
			return soap_in_ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREidResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_issue_get"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREissue_USCOREget;
			return soap_in_ns1__mc_USCOREissue_USCOREget(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_issue_getResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREissue_USCOREgetResponse;
			return soap_in_ns1__mc_USCOREissue_USCOREgetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_issue_exists"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREissue_USCOREexists;
			return soap_in_ns1__mc_USCOREissue_USCOREexists(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_issue_existsResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREissue_USCOREexistsResponse;
			return soap_in_ns1__mc_USCOREissue_USCOREexistsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_enum_get"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREenum_USCOREget;
			return soap_in_ns1__mc_USCOREenum_USCOREget(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_enum_getResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREenum_USCOREgetResponse;
			return soap_in_ns1__mc_USCOREenum_USCOREgetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_enum_custom_field_types"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypes;
			return soap_in_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_enum_custom_field_typesResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse;
			return soap_in_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_enum_view_states"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREenum_USCOREview_USCOREstates;
			return soap_in_ns1__mc_USCOREenum_USCOREview_USCOREstates(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_enum_view_statesResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse;
			return soap_in_ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_enum_project_view_states"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstates;
			return soap_in_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstates(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_enum_project_view_statesResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse;
			return soap_in_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_enum_project_status"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREenum_USCOREproject_USCOREstatus;
			return soap_in_ns1__mc_USCOREenum_USCOREproject_USCOREstatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_enum_project_statusResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse;
			return soap_in_ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_enum_access_levels"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREenum_USCOREaccess_USCORElevels;
			return soap_in_ns1__mc_USCOREenum_USCOREaccess_USCORElevels(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_enum_access_levelsResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse;
			return soap_in_ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_enum_resolutions"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREenum_USCOREresolutions;
			return soap_in_ns1__mc_USCOREenum_USCOREresolutions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_enum_resolutionsResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREenum_USCOREresolutionsResponse;
			return soap_in_ns1__mc_USCOREenum_USCOREresolutionsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_enum_etas"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREenum_USCOREetas;
			return soap_in_ns1__mc_USCOREenum_USCOREetas(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_enum_etasResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREenum_USCOREetasResponse;
			return soap_in_ns1__mc_USCOREenum_USCOREetasResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_enum_projections"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREenum_USCOREprojections;
			return soap_in_ns1__mc_USCOREenum_USCOREprojections(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_enum_projectionsResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREenum_USCOREprojectionsResponse;
			return soap_in_ns1__mc_USCOREenum_USCOREprojectionsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_enum_reproducibilities"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREenum_USCOREreproducibilities;
			return soap_in_ns1__mc_USCOREenum_USCOREreproducibilities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_enum_reproducibilitiesResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREenum_USCOREreproducibilitiesResponse;
			return soap_in_ns1__mc_USCOREenum_USCOREreproducibilitiesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_enum_severities"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREenum_USCOREseverities;
			return soap_in_ns1__mc_USCOREenum_USCOREseverities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_enum_severitiesResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREenum_USCOREseveritiesResponse;
			return soap_in_ns1__mc_USCOREenum_USCOREseveritiesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_enum_priorities"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREenum_USCOREpriorities;
			return soap_in_ns1__mc_USCOREenum_USCOREpriorities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_enum_prioritiesResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREenum_USCOREprioritiesResponse;
			return soap_in_ns1__mc_USCOREenum_USCOREprioritiesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_enum_status"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREenum_USCOREstatus;
			return soap_in_ns1__mc_USCOREenum_USCOREstatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_enum_statusResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREenum_USCOREstatusResponse;
			return soap_in_ns1__mc_USCOREenum_USCOREstatusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_version"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREversion;
			return soap_in_ns1__mc_USCOREversion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mc_versionResponse"))
		{	*type = SOAP_TYPE_ns1__mc_USCOREversionResponse;
			return soap_in_ns1__mc_USCOREversionResponse(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CustomFieldLinkForProjectData"))
		{	*type = SOAP_TYPE_CustomFieldLinkForProjectDataArray;
			return soap_in_CustomFieldLinkForProjectDataArray(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CustomFieldDefinitionData"))
		{	*type = SOAP_TYPE_CustomFieldDefinitionDataArray;
			return soap_in_CustomFieldDefinitionDataArray(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:FilterData"))
		{	*type = SOAP_TYPE_FilterDataArray;
			return soap_in_FilterDataArray(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:ProjectVersionData"))
		{	*type = SOAP_TYPE_ProjectVersionDataArray;
			return soap_in_ProjectVersionDataArray(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:IssueHeaderData"))
		{	*type = SOAP_TYPE_IssueHeaderDataArray;
			return soap_in_IssueHeaderDataArray(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:IssueData"))
		{	*type = SOAP_TYPE_IssueDataArray;
			return soap_in_IssueDataArray(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:ProjectAttachmentData"))
		{	*type = SOAP_TYPE_ProjectAttachmentDataArray;
			return soap_in_ProjectAttachmentDataArray(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:AccountData"))
		{	*type = SOAP_TYPE_AccountDataArray;
			return soap_in_AccountDataArray(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:ObjectRef"))
		{	*type = SOAP_TYPE_ObjectRefArray;
			return soap_in_ObjectRefArray(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "xsd:string"))
		{	*type = SOAP_TYPE_StringArray;
			return soap_in_StringArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CustomFieldValueForIssueData"))
		{	*type = SOAP_TYPE_ns1__CustomFieldValueForIssueData;
			return soap_in_ns1__CustomFieldValueForIssueData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CustomFieldLinkForProjectData"))
		{	*type = SOAP_TYPE_ns1__CustomFieldLinkForProjectData;
			return soap_in_ns1__CustomFieldLinkForProjectData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CustomFieldDefinitionData"))
		{	*type = SOAP_TYPE_ns1__CustomFieldDefinitionData;
			return soap_in_ns1__CustomFieldDefinitionData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:FilterData"))
		{	*type = SOAP_TYPE_ns1__FilterData;
			return soap_in_ns1__FilterData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ProjectVersionData"))
		{	*type = SOAP_TYPE_ns1__ProjectVersionData;
			return soap_in_ns1__ProjectVersionData(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:ProjectData"))
		{	*type = SOAP_TYPE_ProjectDataArray;
			return soap_in_ProjectDataArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ProjectData"))
		{	*type = SOAP_TYPE_ns1__ProjectData;
			return soap_in_ns1__ProjectData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:IssueHeaderData"))
		{	*type = SOAP_TYPE_ns1__IssueHeaderData;
			return soap_in_ns1__IssueHeaderData(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CustomFieldValueForIssueData"))
		{	*type = SOAP_TYPE_CustomFieldValueForIssueDataArray;
			return soap_in_CustomFieldValueForIssueDataArray(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:IssueNoteData"))
		{	*type = SOAP_TYPE_IssueNoteDataArray;
			return soap_in_IssueNoteDataArray(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:RelationshipData"))
		{	*type = SOAP_TYPE_RelationshipDataArray;
			return soap_in_RelationshipDataArray(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:AttachmentData"))
		{	*type = SOAP_TYPE_AttachmentDataArray;
			return soap_in_AttachmentDataArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:IssueData"))
		{	*type = SOAP_TYPE_ns1__IssueData;
			return soap_in_ns1__IssueData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:IssueNoteData"))
		{	*type = SOAP_TYPE_ns1__IssueNoteData;
			return soap_in_ns1__IssueNoteData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RelationshipData"))
		{	*type = SOAP_TYPE_ns1__RelationshipData;
			return soap_in_ns1__RelationshipData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ProjectAttachmentData"))
		{	*type = SOAP_TYPE_ns1__ProjectAttachmentData;
			return soap_in_ns1__ProjectAttachmentData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AttachmentData"))
		{	*type = SOAP_TYPE_ns1__AttachmentData;
			return soap_in_ns1__AttachmentData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AccountData"))
		{	*type = SOAP_TYPE_ns1__AccountData;
			return soap_in_ns1__AccountData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ObjectRef"))
		{	*type = SOAP_TYPE_ns1__ObjectRef;
			return soap_in_ns1__ObjectRef(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_xsd__base64Binary;
			return soap_in_xsd__base64Binary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:integer"))
		{	char **s;
			*type = SOAP_TYPE_xsd__integer;
			s = soap_in_xsd__integer(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	char **s;
			*type = SOAP_TYPE_xsd__anyURI;
			s = soap_in_xsd__anyURI(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_xsd__byte:
		return soap_out_xsd__byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_xsd__boolean:
		return soap_out_xsd__boolean(soap, tag, id, (const enum xsd__boolean *)ptr, "xsd:boolean");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREcheckin:
		return soap_out_ns1__mc_USCOREissue_USCOREcheckin(soap, tag, id, (const struct ns1__mc_USCOREissue_USCOREcheckin *)ptr, "ns1:mc_issue_checkin");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREcheckinResponse:
		return soap_out_ns1__mc_USCOREissue_USCOREcheckinResponse(soap, tag, id, (const struct ns1__mc_USCOREissue_USCOREcheckinResponse *)ptr, "ns1:mc_issue_checkinResponse");
	case SOAP_TYPE_ns1__mc_USCOREconfig_USCOREget_USCOREstring:
		return soap_out_ns1__mc_USCOREconfig_USCOREget_USCOREstring(soap, tag, id, (const struct ns1__mc_USCOREconfig_USCOREget_USCOREstring *)ptr, "ns1:mc_config_get_string");
	case SOAP_TYPE_ns1__mc_USCOREconfig_USCOREget_USCOREstringResponse:
		return soap_out_ns1__mc_USCOREconfig_USCOREget_USCOREstringResponse(soap, tag, id, (const struct ns1__mc_USCOREconfig_USCOREget_USCOREstringResponse *)ptr, "ns1:mc_config_get_stringResponse");
	case SOAP_TYPE_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheaders:
		return soap_out_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheaders(soap, tag, id, (const struct ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheaders *)ptr, "ns1:mc_filter_get_issue_headers");
	case SOAP_TYPE_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse:
		return soap_out_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse(soap, tag, id, (const struct ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse *)ptr, "ns1:mc_filter_get_issue_headersResponse");
	case SOAP_TYPE_ns1__mc_USCOREfilter_USCOREget_USCOREissues:
		return soap_out_ns1__mc_USCOREfilter_USCOREget_USCOREissues(soap, tag, id, (const struct ns1__mc_USCOREfilter_USCOREget_USCOREissues *)ptr, "ns1:mc_filter_get_issues");
	case SOAP_TYPE_ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse:
		return soap_out_ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse(soap, tag, id, (const struct ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse *)ptr, "ns1:mc_filter_get_issuesResponse");
	case SOAP_TYPE_ns1__mc_USCOREfilter_USCOREget:
		return soap_out_ns1__mc_USCOREfilter_USCOREget(soap, tag, id, (const struct ns1__mc_USCOREfilter_USCOREget *)ptr, "ns1:mc_filter_get");
	case SOAP_TYPE_ns1__mc_USCOREfilter_USCOREgetResponse:
		return soap_out_ns1__mc_USCOREfilter_USCOREgetResponse(soap, tag, id, (const struct ns1__mc_USCOREfilter_USCOREgetResponse *)ptr, "ns1:mc_filter_getResponse");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREdelete:
		return soap_out_ns1__mc_USCOREproject_USCOREattachment_USCOREdelete(soap, tag, id, (const struct ns1__mc_USCOREproject_USCOREattachment_USCOREdelete *)ptr, "ns1:mc_project_attachment_delete");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREdeleteResponse:
		return soap_out_ns1__mc_USCOREproject_USCOREattachment_USCOREdeleteResponse(soap, tag, id, (const struct ns1__mc_USCOREproject_USCOREattachment_USCOREdeleteResponse *)ptr, "ns1:mc_project_attachment_deleteResponse");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREadd:
		return soap_out_ns1__mc_USCOREproject_USCOREattachment_USCOREadd(soap, tag, id, (const struct ns1__mc_USCOREproject_USCOREattachment_USCOREadd *)ptr, "ns1:mc_project_attachment_add");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREaddResponse:
		return soap_out_ns1__mc_USCOREproject_USCOREattachment_USCOREaddResponse(soap, tag, id, (const struct ns1__mc_USCOREproject_USCOREattachment_USCOREaddResponse *)ptr, "ns1:mc_project_attachment_addResponse");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREget:
		return soap_out_ns1__mc_USCOREproject_USCOREattachment_USCOREget(soap, tag, id, (const struct ns1__mc_USCOREproject_USCOREattachment_USCOREget *)ptr, "ns1:mc_project_attachment_get");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREgetResponse:
		return soap_out_ns1__mc_USCOREproject_USCOREattachment_USCOREgetResponse(soap, tag, id, (const struct ns1__mc_USCOREproject_USCOREattachment_USCOREgetResponse *)ptr, "ns1:mc_project_attachment_getResponse");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfields:
		return soap_out_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfields(soap, tag, id, (const struct ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfields *)ptr, "ns1:mc_project_get_custom_fields");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse:
		return soap_out_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse(soap, tag, id, (const struct ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse *)ptr, "ns1:mc_project_get_custom_fieldsResponse");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREattachments:
		return soap_out_ns1__mc_USCOREproject_USCOREget_USCOREattachments(soap, tag, id, (const struct ns1__mc_USCOREproject_USCOREget_USCOREattachments *)ptr, "ns1:mc_project_get_attachments");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse:
		return soap_out_ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse(soap, tag, id, (const struct ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse *)ptr, "ns1:mc_project_get_attachmentsResponse");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversions:
		return soap_out_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversions(soap, tag, id, (const struct ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversions *)ptr, "ns1:mc_project_get_unreleased_versions");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse:
		return soap_out_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse(soap, tag, id, (const struct ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse *)ptr, "ns1:mc_project_get_unreleased_versionsResponse");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversions:
		return soap_out_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversions(soap, tag, id, (const struct ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversions *)ptr, "ns1:mc_project_get_released_versions");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse:
		return soap_out_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse(soap, tag, id, (const struct ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse *)ptr, "ns1:mc_project_get_released_versionsResponse");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREdelete:
		return soap_out_ns1__mc_USCOREproject_USCOREversion_USCOREdelete(soap, tag, id, (const struct ns1__mc_USCOREproject_USCOREversion_USCOREdelete *)ptr, "ns1:mc_project_version_delete");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREdeleteResponse:
		return soap_out_ns1__mc_USCOREproject_USCOREversion_USCOREdeleteResponse(soap, tag, id, (const struct ns1__mc_USCOREproject_USCOREversion_USCOREdeleteResponse *)ptr, "ns1:mc_project_version_deleteResponse");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREupdate:
		return soap_out_ns1__mc_USCOREproject_USCOREversion_USCOREupdate(soap, tag, id, (const struct ns1__mc_USCOREproject_USCOREversion_USCOREupdate *)ptr, "ns1:mc_project_version_update");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREupdateResponse:
		return soap_out_ns1__mc_USCOREproject_USCOREversion_USCOREupdateResponse(soap, tag, id, (const struct ns1__mc_USCOREproject_USCOREversion_USCOREupdateResponse *)ptr, "ns1:mc_project_version_updateResponse");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREadd:
		return soap_out_ns1__mc_USCOREproject_USCOREversion_USCOREadd(soap, tag, id, (const struct ns1__mc_USCOREproject_USCOREversion_USCOREadd *)ptr, "ns1:mc_project_version_add");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREaddResponse:
		return soap_out_ns1__mc_USCOREproject_USCOREversion_USCOREaddResponse(soap, tag, id, (const struct ns1__mc_USCOREproject_USCOREversion_USCOREaddResponse *)ptr, "ns1:mc_project_version_addResponse");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREversions:
		return soap_out_ns1__mc_USCOREproject_USCOREget_USCOREversions(soap, tag, id, (const struct ns1__mc_USCOREproject_USCOREget_USCOREversions *)ptr, "ns1:mc_project_get_versions");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse:
		return soap_out_ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse(soap, tag, id, (const struct ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse *)ptr, "ns1:mc_project_get_versionsResponse");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREcategories:
		return soap_out_ns1__mc_USCOREproject_USCOREget_USCOREcategories(soap, tag, id, (const struct ns1__mc_USCOREproject_USCOREget_USCOREcategories *)ptr, "ns1:mc_project_get_categories");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse:
		return soap_out_ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse(soap, tag, id, (const struct ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse *)ptr, "ns1:mc_project_get_categoriesResponse");
	case SOAP_TYPE_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessible:
		return soap_out_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessible(soap, tag, id, (const struct ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessible *)ptr, "ns1:mc_projects_get_user_accessible");
	case SOAP_TYPE_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse:
		return soap_out_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse(soap, tag, id, (const struct ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse *)ptr, "ns1:mc_projects_get_user_accessibleResponse");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREusers:
		return soap_out_ns1__mc_USCOREproject_USCOREget_USCOREusers(soap, tag, id, (const struct ns1__mc_USCOREproject_USCOREget_USCOREusers *)ptr, "ns1:mc_project_get_users");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREusersResponse:
		return soap_out_ns1__mc_USCOREproject_USCOREget_USCOREusersResponse(soap, tag, id, (const struct ns1__mc_USCOREproject_USCOREget_USCOREusersResponse *)ptr, "ns1:mc_project_get_usersResponse");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheaders:
		return soap_out_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheaders(soap, tag, id, (const struct ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheaders *)ptr, "ns1:mc_project_get_issue_headers");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse:
		return soap_out_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse(soap, tag, id, (const struct ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse *)ptr, "ns1:mc_project_get_issue_headersResponse");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREissues:
		return soap_out_ns1__mc_USCOREproject_USCOREget_USCOREissues(soap, tag, id, (const struct ns1__mc_USCOREproject_USCOREget_USCOREissues *)ptr, "ns1:mc_project_get_issues");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse:
		return soap_out_ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse(soap, tag, id, (const struct ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse *)ptr, "ns1:mc_project_get_issuesResponse");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREdelete:
		return soap_out_ns1__mc_USCOREproject_USCOREdelete(soap, tag, id, (const struct ns1__mc_USCOREproject_USCOREdelete *)ptr, "ns1:mc_project_delete");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREdeleteResponse:
		return soap_out_ns1__mc_USCOREproject_USCOREdeleteResponse(soap, tag, id, (const struct ns1__mc_USCOREproject_USCOREdeleteResponse *)ptr, "ns1:mc_project_deleteResponse");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREadd:
		return soap_out_ns1__mc_USCOREproject_USCOREadd(soap, tag, id, (const struct ns1__mc_USCOREproject_USCOREadd *)ptr, "ns1:mc_project_add");
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREaddResponse:
		return soap_out_ns1__mc_USCOREproject_USCOREaddResponse(soap, tag, id, (const struct ns1__mc_USCOREproject_USCOREaddResponse *)ptr, "ns1:mc_project_addResponse");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREget:
		return soap_out_ns1__mc_USCOREissue_USCOREattachment_USCOREget(soap, tag, id, (const struct ns1__mc_USCOREissue_USCOREattachment_USCOREget *)ptr, "ns1:mc_issue_attachment_get");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREgetResponse:
		return soap_out_ns1__mc_USCOREissue_USCOREattachment_USCOREgetResponse(soap, tag, id, (const struct ns1__mc_USCOREissue_USCOREattachment_USCOREgetResponse *)ptr, "ns1:mc_issue_attachment_getResponse");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREdelete:
		return soap_out_ns1__mc_USCOREissue_USCOREattachment_USCOREdelete(soap, tag, id, (const struct ns1__mc_USCOREissue_USCOREattachment_USCOREdelete *)ptr, "ns1:mc_issue_attachment_delete");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREdeleteResponse:
		return soap_out_ns1__mc_USCOREissue_USCOREattachment_USCOREdeleteResponse(soap, tag, id, (const struct ns1__mc_USCOREissue_USCOREattachment_USCOREdeleteResponse *)ptr, "ns1:mc_issue_attachment_deleteResponse");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREadd:
		return soap_out_ns1__mc_USCOREissue_USCOREattachment_USCOREadd(soap, tag, id, (const struct ns1__mc_USCOREissue_USCOREattachment_USCOREadd *)ptr, "ns1:mc_issue_attachment_add");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREaddResponse:
		return soap_out_ns1__mc_USCOREissue_USCOREattachment_USCOREaddResponse(soap, tag, id, (const struct ns1__mc_USCOREissue_USCOREattachment_USCOREaddResponse *)ptr, "ns1:mc_issue_attachment_addResponse");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCORErelationship_USCOREdelete:
		return soap_out_ns1__mc_USCOREissue_USCORErelationship_USCOREdelete(soap, tag, id, (const struct ns1__mc_USCOREissue_USCORErelationship_USCOREdelete *)ptr, "ns1:mc_issue_relationship_delete");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCORErelationship_USCOREdeleteResponse:
		return soap_out_ns1__mc_USCOREissue_USCORErelationship_USCOREdeleteResponse(soap, tag, id, (const struct ns1__mc_USCOREissue_USCORErelationship_USCOREdeleteResponse *)ptr, "ns1:mc_issue_relationship_deleteResponse");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCORErelationship_USCOREadd:
		return soap_out_ns1__mc_USCOREissue_USCORErelationship_USCOREadd(soap, tag, id, (const struct ns1__mc_USCOREissue_USCORErelationship_USCOREadd *)ptr, "ns1:mc_issue_relationship_add");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCORErelationship_USCOREaddResponse:
		return soap_out_ns1__mc_USCOREissue_USCORErelationship_USCOREaddResponse(soap, tag, id, (const struct ns1__mc_USCOREissue_USCORErelationship_USCOREaddResponse *)ptr, "ns1:mc_issue_relationship_addResponse");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREnote_USCOREdelete:
		return soap_out_ns1__mc_USCOREissue_USCOREnote_USCOREdelete(soap, tag, id, (const struct ns1__mc_USCOREissue_USCOREnote_USCOREdelete *)ptr, "ns1:mc_issue_note_delete");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREnote_USCOREdeleteResponse:
		return soap_out_ns1__mc_USCOREissue_USCOREnote_USCOREdeleteResponse(soap, tag, id, (const struct ns1__mc_USCOREissue_USCOREnote_USCOREdeleteResponse *)ptr, "ns1:mc_issue_note_deleteResponse");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREnote_USCOREadd:
		return soap_out_ns1__mc_USCOREissue_USCOREnote_USCOREadd(soap, tag, id, (const struct ns1__mc_USCOREissue_USCOREnote_USCOREadd *)ptr, "ns1:mc_issue_note_add");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREnote_USCOREaddResponse:
		return soap_out_ns1__mc_USCOREissue_USCOREnote_USCOREaddResponse(soap, tag, id, (const struct ns1__mc_USCOREissue_USCOREnote_USCOREaddResponse *)ptr, "ns1:mc_issue_note_addResponse");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREdelete:
		return soap_out_ns1__mc_USCOREissue_USCOREdelete(soap, tag, id, (const struct ns1__mc_USCOREissue_USCOREdelete *)ptr, "ns1:mc_issue_delete");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREdeleteResponse:
		return soap_out_ns1__mc_USCOREissue_USCOREdeleteResponse(soap, tag, id, (const struct ns1__mc_USCOREissue_USCOREdeleteResponse *)ptr, "ns1:mc_issue_deleteResponse");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREupdate:
		return soap_out_ns1__mc_USCOREissue_USCOREupdate(soap, tag, id, (const struct ns1__mc_USCOREissue_USCOREupdate *)ptr, "ns1:mc_issue_update");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREupdateResponse:
		return soap_out_ns1__mc_USCOREissue_USCOREupdateResponse(soap, tag, id, (const struct ns1__mc_USCOREissue_USCOREupdateResponse *)ptr, "ns1:mc_issue_updateResponse");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREadd:
		return soap_out_ns1__mc_USCOREissue_USCOREadd(soap, tag, id, (const struct ns1__mc_USCOREissue_USCOREadd *)ptr, "ns1:mc_issue_add");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREaddResponse:
		return soap_out_ns1__mc_USCOREissue_USCOREaddResponse(soap, tag, id, (const struct ns1__mc_USCOREissue_USCOREaddResponse *)ptr, "ns1:mc_issue_addResponse");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummary:
		return soap_out_ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummary(soap, tag, id, (const struct ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummary *)ptr, "ns1:mc_issue_get_id_from_summary");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummaryResponse:
		return soap_out_ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummaryResponse(soap, tag, id, (const struct ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummaryResponse *)ptr, "ns1:mc_issue_get_id_from_summaryResponse");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREid:
		return soap_out_ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREid(soap, tag, id, (const struct ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREid *)ptr, "ns1:mc_issue_get_biggest_id");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREidResponse:
		return soap_out_ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREidResponse(soap, tag, id, (const struct ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREidResponse *)ptr, "ns1:mc_issue_get_biggest_idResponse");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREget:
		return soap_out_ns1__mc_USCOREissue_USCOREget(soap, tag, id, (const struct ns1__mc_USCOREissue_USCOREget *)ptr, "ns1:mc_issue_get");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREgetResponse:
		return soap_out_ns1__mc_USCOREissue_USCOREgetResponse(soap, tag, id, (const struct ns1__mc_USCOREissue_USCOREgetResponse *)ptr, "ns1:mc_issue_getResponse");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREexists:
		return soap_out_ns1__mc_USCOREissue_USCOREexists(soap, tag, id, (const struct ns1__mc_USCOREissue_USCOREexists *)ptr, "ns1:mc_issue_exists");
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREexistsResponse:
		return soap_out_ns1__mc_USCOREissue_USCOREexistsResponse(soap, tag, id, (const struct ns1__mc_USCOREissue_USCOREexistsResponse *)ptr, "ns1:mc_issue_existsResponse");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREget:
		return soap_out_ns1__mc_USCOREenum_USCOREget(soap, tag, id, (const struct ns1__mc_USCOREenum_USCOREget *)ptr, "ns1:mc_enum_get");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREgetResponse:
		return soap_out_ns1__mc_USCOREenum_USCOREgetResponse(soap, tag, id, (const struct ns1__mc_USCOREenum_USCOREgetResponse *)ptr, "ns1:mc_enum_getResponse");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypes:
		return soap_out_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypes(soap, tag, id, (const struct ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypes *)ptr, "ns1:mc_enum_custom_field_types");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse:
		return soap_out_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse(soap, tag, id, (const struct ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse *)ptr, "ns1:mc_enum_custom_field_typesResponse");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREview_USCOREstates:
		return soap_out_ns1__mc_USCOREenum_USCOREview_USCOREstates(soap, tag, id, (const struct ns1__mc_USCOREenum_USCOREview_USCOREstates *)ptr, "ns1:mc_enum_view_states");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse:
		return soap_out_ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse(soap, tag, id, (const struct ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse *)ptr, "ns1:mc_enum_view_statesResponse");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstates:
		return soap_out_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstates(soap, tag, id, (const struct ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstates *)ptr, "ns1:mc_enum_project_view_states");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse:
		return soap_out_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse(soap, tag, id, (const struct ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse *)ptr, "ns1:mc_enum_project_view_statesResponse");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREproject_USCOREstatus:
		return soap_out_ns1__mc_USCOREenum_USCOREproject_USCOREstatus(soap, tag, id, (const struct ns1__mc_USCOREenum_USCOREproject_USCOREstatus *)ptr, "ns1:mc_enum_project_status");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse:
		return soap_out_ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse(soap, tag, id, (const struct ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse *)ptr, "ns1:mc_enum_project_statusResponse");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREaccess_USCORElevels:
		return soap_out_ns1__mc_USCOREenum_USCOREaccess_USCORElevels(soap, tag, id, (const struct ns1__mc_USCOREenum_USCOREaccess_USCORElevels *)ptr, "ns1:mc_enum_access_levels");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse:
		return soap_out_ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse(soap, tag, id, (const struct ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse *)ptr, "ns1:mc_enum_access_levelsResponse");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREresolutions:
		return soap_out_ns1__mc_USCOREenum_USCOREresolutions(soap, tag, id, (const struct ns1__mc_USCOREenum_USCOREresolutions *)ptr, "ns1:mc_enum_resolutions");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREresolutionsResponse:
		return soap_out_ns1__mc_USCOREenum_USCOREresolutionsResponse(soap, tag, id, (const struct ns1__mc_USCOREenum_USCOREresolutionsResponse *)ptr, "ns1:mc_enum_resolutionsResponse");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREetas:
		return soap_out_ns1__mc_USCOREenum_USCOREetas(soap, tag, id, (const struct ns1__mc_USCOREenum_USCOREetas *)ptr, "ns1:mc_enum_etas");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREetasResponse:
		return soap_out_ns1__mc_USCOREenum_USCOREetasResponse(soap, tag, id, (const struct ns1__mc_USCOREenum_USCOREetasResponse *)ptr, "ns1:mc_enum_etasResponse");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREprojections:
		return soap_out_ns1__mc_USCOREenum_USCOREprojections(soap, tag, id, (const struct ns1__mc_USCOREenum_USCOREprojections *)ptr, "ns1:mc_enum_projections");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREprojectionsResponse:
		return soap_out_ns1__mc_USCOREenum_USCOREprojectionsResponse(soap, tag, id, (const struct ns1__mc_USCOREenum_USCOREprojectionsResponse *)ptr, "ns1:mc_enum_projectionsResponse");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREreproducibilities:
		return soap_out_ns1__mc_USCOREenum_USCOREreproducibilities(soap, tag, id, (const struct ns1__mc_USCOREenum_USCOREreproducibilities *)ptr, "ns1:mc_enum_reproducibilities");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREreproducibilitiesResponse:
		return soap_out_ns1__mc_USCOREenum_USCOREreproducibilitiesResponse(soap, tag, id, (const struct ns1__mc_USCOREenum_USCOREreproducibilitiesResponse *)ptr, "ns1:mc_enum_reproducibilitiesResponse");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREseverities:
		return soap_out_ns1__mc_USCOREenum_USCOREseverities(soap, tag, id, (const struct ns1__mc_USCOREenum_USCOREseverities *)ptr, "ns1:mc_enum_severities");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREseveritiesResponse:
		return soap_out_ns1__mc_USCOREenum_USCOREseveritiesResponse(soap, tag, id, (const struct ns1__mc_USCOREenum_USCOREseveritiesResponse *)ptr, "ns1:mc_enum_severitiesResponse");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREpriorities:
		return soap_out_ns1__mc_USCOREenum_USCOREpriorities(soap, tag, id, (const struct ns1__mc_USCOREenum_USCOREpriorities *)ptr, "ns1:mc_enum_priorities");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREprioritiesResponse:
		return soap_out_ns1__mc_USCOREenum_USCOREprioritiesResponse(soap, tag, id, (const struct ns1__mc_USCOREenum_USCOREprioritiesResponse *)ptr, "ns1:mc_enum_prioritiesResponse");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREstatus:
		return soap_out_ns1__mc_USCOREenum_USCOREstatus(soap, tag, id, (const struct ns1__mc_USCOREenum_USCOREstatus *)ptr, "ns1:mc_enum_status");
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREstatusResponse:
		return soap_out_ns1__mc_USCOREenum_USCOREstatusResponse(soap, tag, id, (const struct ns1__mc_USCOREenum_USCOREstatusResponse *)ptr, "ns1:mc_enum_statusResponse");
	case SOAP_TYPE_ns1__mc_USCOREversion:
		return soap_out_ns1__mc_USCOREversion(soap, tag, id, (const struct ns1__mc_USCOREversion *)ptr, "ns1:mc_version");
	case SOAP_TYPE_ns1__mc_USCOREversionResponse:
		return soap_out_ns1__mc_USCOREversionResponse(soap, tag, id, (const struct ns1__mc_USCOREversionResponse *)ptr, "ns1:mc_versionResponse");
	case SOAP_TYPE_CustomFieldLinkForProjectDataArray:
		return soap_out_CustomFieldLinkForProjectDataArray(soap, tag, id, (const struct CustomFieldLinkForProjectDataArray *)ptr, "ns1:CustomFieldLinkForProjectData");
	case SOAP_TYPE_CustomFieldDefinitionDataArray:
		return soap_out_CustomFieldDefinitionDataArray(soap, tag, id, (const struct CustomFieldDefinitionDataArray *)ptr, "ns1:CustomFieldDefinitionData");
	case SOAP_TYPE_FilterDataArray:
		return soap_out_FilterDataArray(soap, tag, id, (const struct FilterDataArray *)ptr, "ns1:FilterData");
	case SOAP_TYPE_ProjectVersionDataArray:
		return soap_out_ProjectVersionDataArray(soap, tag, id, (const struct ProjectVersionDataArray *)ptr, "ns1:ProjectVersionData");
	case SOAP_TYPE_IssueHeaderDataArray:
		return soap_out_IssueHeaderDataArray(soap, tag, id, (const struct IssueHeaderDataArray *)ptr, "ns1:IssueHeaderData");
	case SOAP_TYPE_IssueDataArray:
		return soap_out_IssueDataArray(soap, tag, id, (const struct IssueDataArray *)ptr, "ns1:IssueData");
	case SOAP_TYPE_ProjectAttachmentDataArray:
		return soap_out_ProjectAttachmentDataArray(soap, tag, id, (const struct ProjectAttachmentDataArray *)ptr, "ns1:ProjectAttachmentData");
	case SOAP_TYPE_AccountDataArray:
		return soap_out_AccountDataArray(soap, tag, id, (const struct AccountDataArray *)ptr, "ns1:AccountData");
	case SOAP_TYPE_ObjectRefArray:
		return soap_out_ObjectRefArray(soap, tag, id, (const struct ObjectRefArray *)ptr, "ns1:ObjectRef");
	case SOAP_TYPE_StringArray:
		return soap_out_StringArray(soap, tag, id, (const struct StringArray *)ptr, "xsd:string");
	case SOAP_TYPE_ns1__CustomFieldValueForIssueData:
		return soap_out_ns1__CustomFieldValueForIssueData(soap, tag, id, (const struct ns1__CustomFieldValueForIssueData *)ptr, "ns1:CustomFieldValueForIssueData");
	case SOAP_TYPE_ns1__CustomFieldLinkForProjectData:
		return soap_out_ns1__CustomFieldLinkForProjectData(soap, tag, id, (const struct ns1__CustomFieldLinkForProjectData *)ptr, "ns1:CustomFieldLinkForProjectData");
	case SOAP_TYPE_ns1__CustomFieldDefinitionData:
		return soap_out_ns1__CustomFieldDefinitionData(soap, tag, id, (const struct ns1__CustomFieldDefinitionData *)ptr, "ns1:CustomFieldDefinitionData");
	case SOAP_TYPE_ns1__FilterData:
		return soap_out_ns1__FilterData(soap, tag, id, (const struct ns1__FilterData *)ptr, "ns1:FilterData");
	case SOAP_TYPE_ns1__ProjectVersionData:
		return soap_out_ns1__ProjectVersionData(soap, tag, id, (const struct ns1__ProjectVersionData *)ptr, "ns1:ProjectVersionData");
	case SOAP_TYPE_ProjectDataArray:
		return soap_out_ProjectDataArray(soap, tag, id, (const struct ProjectDataArray *)ptr, "ns1:ProjectData");
	case SOAP_TYPE_ns1__ProjectData:
		return soap_out_ns1__ProjectData(soap, tag, id, (const struct ns1__ProjectData *)ptr, "ns1:ProjectData");
	case SOAP_TYPE_ns1__IssueHeaderData:
		return soap_out_ns1__IssueHeaderData(soap, tag, id, (const struct ns1__IssueHeaderData *)ptr, "ns1:IssueHeaderData");
	case SOAP_TYPE_CustomFieldValueForIssueDataArray:
		return soap_out_CustomFieldValueForIssueDataArray(soap, tag, id, (const struct CustomFieldValueForIssueDataArray *)ptr, "ns1:CustomFieldValueForIssueData");
	case SOAP_TYPE_IssueNoteDataArray:
		return soap_out_IssueNoteDataArray(soap, tag, id, (const struct IssueNoteDataArray *)ptr, "ns1:IssueNoteData");
	case SOAP_TYPE_RelationshipDataArray:
		return soap_out_RelationshipDataArray(soap, tag, id, (const struct RelationshipDataArray *)ptr, "ns1:RelationshipData");
	case SOAP_TYPE_AttachmentDataArray:
		return soap_out_AttachmentDataArray(soap, tag, id, (const struct AttachmentDataArray *)ptr, "ns1:AttachmentData");
	case SOAP_TYPE_ns1__IssueData:
		return soap_out_ns1__IssueData(soap, tag, id, (const struct ns1__IssueData *)ptr, "ns1:IssueData");
	case SOAP_TYPE_ns1__IssueNoteData:
		return soap_out_ns1__IssueNoteData(soap, tag, id, (const struct ns1__IssueNoteData *)ptr, "ns1:IssueNoteData");
	case SOAP_TYPE_ns1__RelationshipData:
		return soap_out_ns1__RelationshipData(soap, tag, id, (const struct ns1__RelationshipData *)ptr, "ns1:RelationshipData");
	case SOAP_TYPE_ns1__ProjectAttachmentData:
		return soap_out_ns1__ProjectAttachmentData(soap, tag, id, (const struct ns1__ProjectAttachmentData *)ptr, "ns1:ProjectAttachmentData");
	case SOAP_TYPE_ns1__AttachmentData:
		return soap_out_ns1__AttachmentData(soap, tag, id, (const struct ns1__AttachmentData *)ptr, "ns1:AttachmentData");
	case SOAP_TYPE_ns1__AccountData:
		return soap_out_ns1__AccountData(soap, tag, id, (const struct ns1__AccountData *)ptr, "ns1:AccountData");
	case SOAP_TYPE_ns1__ObjectRef:
		return soap_out_ns1__ObjectRef(soap, tag, id, (const struct ns1__ObjectRef *)ptr, "ns1:ObjectRef");
	case SOAP_TYPE_xsd__base64Binary:
		return soap_out_xsd__base64Binary(soap, tag, id, (const struct xsd__base64Binary *)ptr, "xsd:base64Binary");
	case SOAP_TYPE_PointerTons1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse:
		return soap_out_PointerTons1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse(soap, tag, id, (struct ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse *const*)ptr, "ns1:mc_filter_get_issue_headersResponse");
	case SOAP_TYPE_PointerTons1__mc_USCOREfilter_USCOREget_USCOREissuesResponse:
		return soap_out_PointerTons1__mc_USCOREfilter_USCOREget_USCOREissuesResponse(soap, tag, id, (struct ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse *const*)ptr, "ns1:mc_filter_get_issuesResponse");
	case SOAP_TYPE_PointerTons1__mc_USCOREfilter_USCOREgetResponse:
		return soap_out_PointerTons1__mc_USCOREfilter_USCOREgetResponse(soap, tag, id, (struct ns1__mc_USCOREfilter_USCOREgetResponse *const*)ptr, "ns1:mc_filter_getResponse");
	case SOAP_TYPE_PointerToFilterDataArray:
		return soap_out_PointerToFilterDataArray(soap, tag, id, (struct FilterDataArray *const*)ptr, "ns1:FilterData");
	case SOAP_TYPE_PointerTons1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse:
		return soap_out_PointerTons1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse(soap, tag, id, (struct ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse *const*)ptr, "ns1:mc_project_get_custom_fieldsResponse");
	case SOAP_TYPE_PointerToCustomFieldDefinitionDataArray:
		return soap_out_PointerToCustomFieldDefinitionDataArray(soap, tag, id, (struct CustomFieldDefinitionDataArray *const*)ptr, "ns1:CustomFieldDefinitionData");
	case SOAP_TYPE_PointerTons1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse:
		return soap_out_PointerTons1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse(soap, tag, id, (struct ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse *const*)ptr, "ns1:mc_project_get_attachmentsResponse");
	case SOAP_TYPE_PointerToProjectAttachmentDataArray:
		return soap_out_PointerToProjectAttachmentDataArray(soap, tag, id, (struct ProjectAttachmentDataArray *const*)ptr, "ns1:ProjectAttachmentData");
	case SOAP_TYPE_PointerTons1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse:
		return soap_out_PointerTons1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse(soap, tag, id, (struct ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse *const*)ptr, "ns1:mc_project_get_unreleased_versionsResponse");
	case SOAP_TYPE_PointerTons1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse:
		return soap_out_PointerTons1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse(soap, tag, id, (struct ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse *const*)ptr, "ns1:mc_project_get_released_versionsResponse");
	case SOAP_TYPE_PointerTons1__mc_USCOREproject_USCOREget_USCOREversionsResponse:
		return soap_out_PointerTons1__mc_USCOREproject_USCOREget_USCOREversionsResponse(soap, tag, id, (struct ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse *const*)ptr, "ns1:mc_project_get_versionsResponse");
	case SOAP_TYPE_PointerToProjectVersionDataArray:
		return soap_out_PointerToProjectVersionDataArray(soap, tag, id, (struct ProjectVersionDataArray *const*)ptr, "ns1:ProjectVersionData");
	case SOAP_TYPE_PointerTons1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse:
		return soap_out_PointerTons1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse(soap, tag, id, (struct ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse *const*)ptr, "ns1:mc_project_get_categoriesResponse");
	case SOAP_TYPE_PointerToStringArray:
		return soap_out_PointerToStringArray(soap, tag, id, (struct StringArray *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTons1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse:
		return soap_out_PointerTons1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse(soap, tag, id, (struct ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse *const*)ptr, "ns1:mc_projects_get_user_accessibleResponse");
	case SOAP_TYPE_PointerTons1__mc_USCOREproject_USCOREget_USCOREusersResponse:
		return soap_out_PointerTons1__mc_USCOREproject_USCOREget_USCOREusersResponse(soap, tag, id, (struct ns1__mc_USCOREproject_USCOREget_USCOREusersResponse *const*)ptr, "ns1:mc_project_get_usersResponse");
	case SOAP_TYPE_PointerToAccountDataArray:
		return soap_out_PointerToAccountDataArray(soap, tag, id, (struct AccountDataArray *const*)ptr, "ns1:AccountData");
	case SOAP_TYPE_PointerTons1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse:
		return soap_out_PointerTons1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse(soap, tag, id, (struct ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse *const*)ptr, "ns1:mc_project_get_issue_headersResponse");
	case SOAP_TYPE_PointerToIssueHeaderDataArray:
		return soap_out_PointerToIssueHeaderDataArray(soap, tag, id, (struct IssueHeaderDataArray *const*)ptr, "ns1:IssueHeaderData");
	case SOAP_TYPE_PointerTons1__mc_USCOREproject_USCOREget_USCOREissuesResponse:
		return soap_out_PointerTons1__mc_USCOREproject_USCOREget_USCOREissuesResponse(soap, tag, id, (struct ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse *const*)ptr, "ns1:mc_project_get_issuesResponse");
	case SOAP_TYPE_PointerToIssueDataArray:
		return soap_out_PointerToIssueDataArray(soap, tag, id, (struct IssueDataArray *const*)ptr, "ns1:IssueData");
	case SOAP_TYPE_PointerToxsd__base64Binary:
		return soap_out_PointerToxsd__base64Binary(soap, tag, id, (struct xsd__base64Binary *const*)ptr, "xsd:base64Binary");
	case SOAP_TYPE_PointerToxsd__integer:
		return soap_out_PointerToxsd__integer(soap, tag, id, (char **const*)ptr, "xsd:integer");
	case SOAP_TYPE_PointerTons1__mc_USCOREissue_USCOREgetResponse:
		return soap_out_PointerTons1__mc_USCOREissue_USCOREgetResponse(soap, tag, id, (struct ns1__mc_USCOREissue_USCOREgetResponse *const*)ptr, "ns1:mc_issue_getResponse");
	case SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse:
		return soap_out_PointerTons1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse(soap, tag, id, (struct ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse *const*)ptr, "ns1:mc_enum_custom_field_typesResponse");
	case SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREview_USCOREstatesResponse:
		return soap_out_PointerTons1__mc_USCOREenum_USCOREview_USCOREstatesResponse(soap, tag, id, (struct ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse *const*)ptr, "ns1:mc_enum_view_statesResponse");
	case SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse:
		return soap_out_PointerTons1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse(soap, tag, id, (struct ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse *const*)ptr, "ns1:mc_enum_project_view_statesResponse");
	case SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREproject_USCOREstatusResponse:
		return soap_out_PointerTons1__mc_USCOREenum_USCOREproject_USCOREstatusResponse(soap, tag, id, (struct ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse *const*)ptr, "ns1:mc_enum_project_statusResponse");
	case SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse:
		return soap_out_PointerTons1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse(soap, tag, id, (struct ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse *const*)ptr, "ns1:mc_enum_access_levelsResponse");
	case SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREresolutionsResponse:
		return soap_out_PointerTons1__mc_USCOREenum_USCOREresolutionsResponse(soap, tag, id, (struct ns1__mc_USCOREenum_USCOREresolutionsResponse *const*)ptr, "ns1:mc_enum_resolutionsResponse");
	case SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREetasResponse:
		return soap_out_PointerTons1__mc_USCOREenum_USCOREetasResponse(soap, tag, id, (struct ns1__mc_USCOREenum_USCOREetasResponse *const*)ptr, "ns1:mc_enum_etasResponse");
	case SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREprojectionsResponse:
		return soap_out_PointerTons1__mc_USCOREenum_USCOREprojectionsResponse(soap, tag, id, (struct ns1__mc_USCOREenum_USCOREprojectionsResponse *const*)ptr, "ns1:mc_enum_projectionsResponse");
	case SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREreproducibilitiesResponse:
		return soap_out_PointerTons1__mc_USCOREenum_USCOREreproducibilitiesResponse(soap, tag, id, (struct ns1__mc_USCOREenum_USCOREreproducibilitiesResponse *const*)ptr, "ns1:mc_enum_reproducibilitiesResponse");
	case SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREseveritiesResponse:
		return soap_out_PointerTons1__mc_USCOREenum_USCOREseveritiesResponse(soap, tag, id, (struct ns1__mc_USCOREenum_USCOREseveritiesResponse *const*)ptr, "ns1:mc_enum_severitiesResponse");
	case SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREprioritiesResponse:
		return soap_out_PointerTons1__mc_USCOREenum_USCOREprioritiesResponse(soap, tag, id, (struct ns1__mc_USCOREenum_USCOREprioritiesResponse *const*)ptr, "ns1:mc_enum_prioritiesResponse");
	case SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREstatusResponse:
		return soap_out_PointerTons1__mc_USCOREenum_USCOREstatusResponse(soap, tag, id, (struct ns1__mc_USCOREenum_USCOREstatusResponse *const*)ptr, "ns1:mc_enum_statusResponse");
	case SOAP_TYPE_PointerToObjectRefArray:
		return soap_out_PointerToObjectRefArray(soap, tag, id, (struct ObjectRefArray *const*)ptr, "ns1:ObjectRef");
	case SOAP_TYPE_PointerToPointerTons1__CustomFieldValueForIssueData:
		return soap_out_PointerToPointerTons1__CustomFieldValueForIssueData(soap, tag, id, (struct ns1__CustomFieldValueForIssueData **const*)ptr, "ns1:CustomFieldValueForIssueData");
	case SOAP_TYPE_PointerTons1__CustomFieldValueForIssueData:
		return soap_out_PointerTons1__CustomFieldValueForIssueData(soap, tag, id, (struct ns1__CustomFieldValueForIssueData *const*)ptr, "ns1:CustomFieldValueForIssueData");
	case SOAP_TYPE_PointerToPointerTons1__CustomFieldLinkForProjectData:
		return soap_out_PointerToPointerTons1__CustomFieldLinkForProjectData(soap, tag, id, (struct ns1__CustomFieldLinkForProjectData **const*)ptr, "ns1:CustomFieldLinkForProjectData");
	case SOAP_TYPE_PointerTons1__CustomFieldLinkForProjectData:
		return soap_out_PointerTons1__CustomFieldLinkForProjectData(soap, tag, id, (struct ns1__CustomFieldLinkForProjectData *const*)ptr, "ns1:CustomFieldLinkForProjectData");
	case SOAP_TYPE_PointerToPointerTons1__CustomFieldDefinitionData:
		return soap_out_PointerToPointerTons1__CustomFieldDefinitionData(soap, tag, id, (struct ns1__CustomFieldDefinitionData **const*)ptr, "ns1:CustomFieldDefinitionData");
	case SOAP_TYPE_PointerTons1__CustomFieldDefinitionData:
		return soap_out_PointerTons1__CustomFieldDefinitionData(soap, tag, id, (struct ns1__CustomFieldDefinitionData *const*)ptr, "ns1:CustomFieldDefinitionData");
	case SOAP_TYPE_PointerToPointerTons1__FilterData:
		return soap_out_PointerToPointerTons1__FilterData(soap, tag, id, (struct ns1__FilterData **const*)ptr, "ns1:FilterData");
	case SOAP_TYPE_PointerTons1__FilterData:
		return soap_out_PointerTons1__FilterData(soap, tag, id, (struct ns1__FilterData *const*)ptr, "ns1:FilterData");
	case SOAP_TYPE_PointerToPointerTons1__ProjectVersionData:
		return soap_out_PointerToPointerTons1__ProjectVersionData(soap, tag, id, (struct ns1__ProjectVersionData **const*)ptr, "ns1:ProjectVersionData");
	case SOAP_TYPE_PointerTons1__ProjectVersionData:
		return soap_out_PointerTons1__ProjectVersionData(soap, tag, id, (struct ns1__ProjectVersionData *const*)ptr, "ns1:ProjectVersionData");
	case SOAP_TYPE_PointerToPointerTons1__ProjectData:
		return soap_out_PointerToPointerTons1__ProjectData(soap, tag, id, (struct ns1__ProjectData **const*)ptr, "ns1:ProjectData");
	case SOAP_TYPE_PointerTons1__ProjectData:
		return soap_out_PointerTons1__ProjectData(soap, tag, id, (struct ns1__ProjectData *const*)ptr, "ns1:ProjectData");
	case SOAP_TYPE_PointerToPointerTons1__IssueHeaderData:
		return soap_out_PointerToPointerTons1__IssueHeaderData(soap, tag, id, (struct ns1__IssueHeaderData **const*)ptr, "ns1:IssueHeaderData");
	case SOAP_TYPE_PointerTons1__IssueHeaderData:
		return soap_out_PointerTons1__IssueHeaderData(soap, tag, id, (struct ns1__IssueHeaderData *const*)ptr, "ns1:IssueHeaderData");
	case SOAP_TYPE_PointerToPointerTons1__IssueData:
		return soap_out_PointerToPointerTons1__IssueData(soap, tag, id, (struct ns1__IssueData **const*)ptr, "ns1:IssueData");
	case SOAP_TYPE_PointerTons1__IssueData:
		return soap_out_PointerTons1__IssueData(soap, tag, id, (struct ns1__IssueData *const*)ptr, "ns1:IssueData");
	case SOAP_TYPE_PointerToPointerTons1__IssueNoteData:
		return soap_out_PointerToPointerTons1__IssueNoteData(soap, tag, id, (struct ns1__IssueNoteData **const*)ptr, "ns1:IssueNoteData");
	case SOAP_TYPE_PointerTons1__IssueNoteData:
		return soap_out_PointerTons1__IssueNoteData(soap, tag, id, (struct ns1__IssueNoteData *const*)ptr, "ns1:IssueNoteData");
	case SOAP_TYPE_PointerToPointerTons1__RelationshipData:
		return soap_out_PointerToPointerTons1__RelationshipData(soap, tag, id, (struct ns1__RelationshipData **const*)ptr, "ns1:RelationshipData");
	case SOAP_TYPE_PointerTons1__RelationshipData:
		return soap_out_PointerTons1__RelationshipData(soap, tag, id, (struct ns1__RelationshipData *const*)ptr, "ns1:RelationshipData");
	case SOAP_TYPE_PointerToPointerTons1__ProjectAttachmentData:
		return soap_out_PointerToPointerTons1__ProjectAttachmentData(soap, tag, id, (struct ns1__ProjectAttachmentData **const*)ptr, "ns1:ProjectAttachmentData");
	case SOAP_TYPE_PointerTons1__ProjectAttachmentData:
		return soap_out_PointerTons1__ProjectAttachmentData(soap, tag, id, (struct ns1__ProjectAttachmentData *const*)ptr, "ns1:ProjectAttachmentData");
	case SOAP_TYPE_PointerToPointerTons1__AttachmentData:
		return soap_out_PointerToPointerTons1__AttachmentData(soap, tag, id, (struct ns1__AttachmentData **const*)ptr, "ns1:AttachmentData");
	case SOAP_TYPE_PointerTons1__AttachmentData:
		return soap_out_PointerTons1__AttachmentData(soap, tag, id, (struct ns1__AttachmentData *const*)ptr, "ns1:AttachmentData");
	case SOAP_TYPE_PointerToPointerTons1__AccountData:
		return soap_out_PointerToPointerTons1__AccountData(soap, tag, id, (struct ns1__AccountData **const*)ptr, "ns1:AccountData");
	case SOAP_TYPE_PointerToPointerTons1__ObjectRef:
		return soap_out_PointerToPointerTons1__ObjectRef(soap, tag, id, (struct ns1__ObjectRef **const*)ptr, "ns1:ObjectRef");
	case SOAP_TYPE_PointerTostring:
		return soap_out_PointerTostring(soap, tag, id, (char **const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerToxsd__byte:
		return soap_out_PointerToxsd__byte(soap, tag, id, (char *const*)ptr, "xsd:byte");
	case SOAP_TYPE_PointerToProjectDataArray:
		return soap_out_PointerToProjectDataArray(soap, tag, id, (struct ProjectDataArray *const*)ptr, "ns1:ProjectData");
	case SOAP_TYPE_PointerToxsd__boolean:
		return soap_out_PointerToxsd__boolean(soap, tag, id, (enum xsd__boolean *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerToCustomFieldValueForIssueDataArray:
		return soap_out_PointerToCustomFieldValueForIssueDataArray(soap, tag, id, (struct CustomFieldValueForIssueDataArray *const*)ptr, "ns1:CustomFieldValueForIssueData");
	case SOAP_TYPE_PointerToIssueNoteDataArray:
		return soap_out_PointerToIssueNoteDataArray(soap, tag, id, (struct IssueNoteDataArray *const*)ptr, "ns1:IssueNoteData");
	case SOAP_TYPE_PointerToRelationshipDataArray:
		return soap_out_PointerToRelationshipDataArray(soap, tag, id, (struct RelationshipDataArray *const*)ptr, "ns1:RelationshipData");
	case SOAP_TYPE_PointerToAttachmentDataArray:
		return soap_out_PointerToAttachmentDataArray(soap, tag, id, (struct AttachmentDataArray *const*)ptr, "ns1:AttachmentData");
	case SOAP_TYPE_PointerTons1__AccountData:
		return soap_out_PointerTons1__AccountData(soap, tag, id, (struct ns1__AccountData *const*)ptr, "ns1:AccountData");
	case SOAP_TYPE_PointerTons1__ObjectRef:
		return soap_out_PointerTons1__ObjectRef(soap, tag, id, (struct ns1__ObjectRef *const*)ptr, "ns1:ObjectRef");
	case SOAP_TYPE_PointerTotime:
		return soap_out_PointerTotime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_xsd__integer:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:integer");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_xsd__anyURI:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:anyURI");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREcheckin:
		soap_serialize_ns1__mc_USCOREissue_USCOREcheckin(soap, (const struct ns1__mc_USCOREissue_USCOREcheckin *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREcheckinResponse:
		soap_serialize_ns1__mc_USCOREissue_USCOREcheckinResponse(soap, (const struct ns1__mc_USCOREissue_USCOREcheckinResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREconfig_USCOREget_USCOREstring:
		soap_serialize_ns1__mc_USCOREconfig_USCOREget_USCOREstring(soap, (const struct ns1__mc_USCOREconfig_USCOREget_USCOREstring *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREconfig_USCOREget_USCOREstringResponse:
		soap_serialize_ns1__mc_USCOREconfig_USCOREget_USCOREstringResponse(soap, (const struct ns1__mc_USCOREconfig_USCOREget_USCOREstringResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheaders:
		soap_serialize_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheaders(soap, (const struct ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheaders *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse:
		soap_serialize_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse(soap, (const struct ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREfilter_USCOREget_USCOREissues:
		soap_serialize_ns1__mc_USCOREfilter_USCOREget_USCOREissues(soap, (const struct ns1__mc_USCOREfilter_USCOREget_USCOREissues *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse:
		soap_serialize_ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse(soap, (const struct ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREfilter_USCOREget:
		soap_serialize_ns1__mc_USCOREfilter_USCOREget(soap, (const struct ns1__mc_USCOREfilter_USCOREget *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREfilter_USCOREgetResponse:
		soap_serialize_ns1__mc_USCOREfilter_USCOREgetResponse(soap, (const struct ns1__mc_USCOREfilter_USCOREgetResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREdelete:
		soap_serialize_ns1__mc_USCOREproject_USCOREattachment_USCOREdelete(soap, (const struct ns1__mc_USCOREproject_USCOREattachment_USCOREdelete *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREdeleteResponse:
		soap_serialize_ns1__mc_USCOREproject_USCOREattachment_USCOREdeleteResponse(soap, (const struct ns1__mc_USCOREproject_USCOREattachment_USCOREdeleteResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREadd:
		soap_serialize_ns1__mc_USCOREproject_USCOREattachment_USCOREadd(soap, (const struct ns1__mc_USCOREproject_USCOREattachment_USCOREadd *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREaddResponse:
		soap_serialize_ns1__mc_USCOREproject_USCOREattachment_USCOREaddResponse(soap, (const struct ns1__mc_USCOREproject_USCOREattachment_USCOREaddResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREget:
		soap_serialize_ns1__mc_USCOREproject_USCOREattachment_USCOREget(soap, (const struct ns1__mc_USCOREproject_USCOREattachment_USCOREget *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREgetResponse:
		soap_serialize_ns1__mc_USCOREproject_USCOREattachment_USCOREgetResponse(soap, (const struct ns1__mc_USCOREproject_USCOREattachment_USCOREgetResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfields:
		soap_serialize_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfields(soap, (const struct ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfields *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse:
		soap_serialize_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse(soap, (const struct ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREattachments:
		soap_serialize_ns1__mc_USCOREproject_USCOREget_USCOREattachments(soap, (const struct ns1__mc_USCOREproject_USCOREget_USCOREattachments *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse:
		soap_serialize_ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse(soap, (const struct ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversions:
		soap_serialize_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversions(soap, (const struct ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversions *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse:
		soap_serialize_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse(soap, (const struct ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversions:
		soap_serialize_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversions(soap, (const struct ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversions *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse:
		soap_serialize_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse(soap, (const struct ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREdelete:
		soap_serialize_ns1__mc_USCOREproject_USCOREversion_USCOREdelete(soap, (const struct ns1__mc_USCOREproject_USCOREversion_USCOREdelete *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREdeleteResponse:
		soap_serialize_ns1__mc_USCOREproject_USCOREversion_USCOREdeleteResponse(soap, (const struct ns1__mc_USCOREproject_USCOREversion_USCOREdeleteResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREupdate:
		soap_serialize_ns1__mc_USCOREproject_USCOREversion_USCOREupdate(soap, (const struct ns1__mc_USCOREproject_USCOREversion_USCOREupdate *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREupdateResponse:
		soap_serialize_ns1__mc_USCOREproject_USCOREversion_USCOREupdateResponse(soap, (const struct ns1__mc_USCOREproject_USCOREversion_USCOREupdateResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREadd:
		soap_serialize_ns1__mc_USCOREproject_USCOREversion_USCOREadd(soap, (const struct ns1__mc_USCOREproject_USCOREversion_USCOREadd *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREaddResponse:
		soap_serialize_ns1__mc_USCOREproject_USCOREversion_USCOREaddResponse(soap, (const struct ns1__mc_USCOREproject_USCOREversion_USCOREaddResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREversions:
		soap_serialize_ns1__mc_USCOREproject_USCOREget_USCOREversions(soap, (const struct ns1__mc_USCOREproject_USCOREget_USCOREversions *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse:
		soap_serialize_ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse(soap, (const struct ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREcategories:
		soap_serialize_ns1__mc_USCOREproject_USCOREget_USCOREcategories(soap, (const struct ns1__mc_USCOREproject_USCOREget_USCOREcategories *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse:
		soap_serialize_ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse(soap, (const struct ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessible:
		soap_serialize_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessible(soap, (const struct ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessible *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse:
		soap_serialize_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse(soap, (const struct ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREusers:
		soap_serialize_ns1__mc_USCOREproject_USCOREget_USCOREusers(soap, (const struct ns1__mc_USCOREproject_USCOREget_USCOREusers *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREusersResponse:
		soap_serialize_ns1__mc_USCOREproject_USCOREget_USCOREusersResponse(soap, (const struct ns1__mc_USCOREproject_USCOREget_USCOREusersResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheaders:
		soap_serialize_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheaders(soap, (const struct ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheaders *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse:
		soap_serialize_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse(soap, (const struct ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREissues:
		soap_serialize_ns1__mc_USCOREproject_USCOREget_USCOREissues(soap, (const struct ns1__mc_USCOREproject_USCOREget_USCOREissues *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse:
		soap_serialize_ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse(soap, (const struct ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREdelete:
		soap_serialize_ns1__mc_USCOREproject_USCOREdelete(soap, (const struct ns1__mc_USCOREproject_USCOREdelete *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREdeleteResponse:
		soap_serialize_ns1__mc_USCOREproject_USCOREdeleteResponse(soap, (const struct ns1__mc_USCOREproject_USCOREdeleteResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREadd:
		soap_serialize_ns1__mc_USCOREproject_USCOREadd(soap, (const struct ns1__mc_USCOREproject_USCOREadd *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREproject_USCOREaddResponse:
		soap_serialize_ns1__mc_USCOREproject_USCOREaddResponse(soap, (const struct ns1__mc_USCOREproject_USCOREaddResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREget:
		soap_serialize_ns1__mc_USCOREissue_USCOREattachment_USCOREget(soap, (const struct ns1__mc_USCOREissue_USCOREattachment_USCOREget *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREgetResponse:
		soap_serialize_ns1__mc_USCOREissue_USCOREattachment_USCOREgetResponse(soap, (const struct ns1__mc_USCOREissue_USCOREattachment_USCOREgetResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREdelete:
		soap_serialize_ns1__mc_USCOREissue_USCOREattachment_USCOREdelete(soap, (const struct ns1__mc_USCOREissue_USCOREattachment_USCOREdelete *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREdeleteResponse:
		soap_serialize_ns1__mc_USCOREissue_USCOREattachment_USCOREdeleteResponse(soap, (const struct ns1__mc_USCOREissue_USCOREattachment_USCOREdeleteResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREadd:
		soap_serialize_ns1__mc_USCOREissue_USCOREattachment_USCOREadd(soap, (const struct ns1__mc_USCOREissue_USCOREattachment_USCOREadd *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREaddResponse:
		soap_serialize_ns1__mc_USCOREissue_USCOREattachment_USCOREaddResponse(soap, (const struct ns1__mc_USCOREissue_USCOREattachment_USCOREaddResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREissue_USCORErelationship_USCOREdelete:
		soap_serialize_ns1__mc_USCOREissue_USCORErelationship_USCOREdelete(soap, (const struct ns1__mc_USCOREissue_USCORErelationship_USCOREdelete *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREissue_USCORErelationship_USCOREdeleteResponse:
		soap_serialize_ns1__mc_USCOREissue_USCORErelationship_USCOREdeleteResponse(soap, (const struct ns1__mc_USCOREissue_USCORErelationship_USCOREdeleteResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREissue_USCORErelationship_USCOREadd:
		soap_serialize_ns1__mc_USCOREissue_USCORErelationship_USCOREadd(soap, (const struct ns1__mc_USCOREissue_USCORErelationship_USCOREadd *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREissue_USCORErelationship_USCOREaddResponse:
		soap_serialize_ns1__mc_USCOREissue_USCORErelationship_USCOREaddResponse(soap, (const struct ns1__mc_USCOREissue_USCORErelationship_USCOREaddResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREnote_USCOREdelete:
		soap_serialize_ns1__mc_USCOREissue_USCOREnote_USCOREdelete(soap, (const struct ns1__mc_USCOREissue_USCOREnote_USCOREdelete *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREnote_USCOREdeleteResponse:
		soap_serialize_ns1__mc_USCOREissue_USCOREnote_USCOREdeleteResponse(soap, (const struct ns1__mc_USCOREissue_USCOREnote_USCOREdeleteResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREnote_USCOREadd:
		soap_serialize_ns1__mc_USCOREissue_USCOREnote_USCOREadd(soap, (const struct ns1__mc_USCOREissue_USCOREnote_USCOREadd *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREnote_USCOREaddResponse:
		soap_serialize_ns1__mc_USCOREissue_USCOREnote_USCOREaddResponse(soap, (const struct ns1__mc_USCOREissue_USCOREnote_USCOREaddResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREdelete:
		soap_serialize_ns1__mc_USCOREissue_USCOREdelete(soap, (const struct ns1__mc_USCOREissue_USCOREdelete *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREdeleteResponse:
		soap_serialize_ns1__mc_USCOREissue_USCOREdeleteResponse(soap, (const struct ns1__mc_USCOREissue_USCOREdeleteResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREupdate:
		soap_serialize_ns1__mc_USCOREissue_USCOREupdate(soap, (const struct ns1__mc_USCOREissue_USCOREupdate *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREupdateResponse:
		soap_serialize_ns1__mc_USCOREissue_USCOREupdateResponse(soap, (const struct ns1__mc_USCOREissue_USCOREupdateResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREadd:
		soap_serialize_ns1__mc_USCOREissue_USCOREadd(soap, (const struct ns1__mc_USCOREissue_USCOREadd *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREaddResponse:
		soap_serialize_ns1__mc_USCOREissue_USCOREaddResponse(soap, (const struct ns1__mc_USCOREissue_USCOREaddResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummary:
		soap_serialize_ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummary(soap, (const struct ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummary *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummaryResponse:
		soap_serialize_ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummaryResponse(soap, (const struct ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummaryResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREid:
		soap_serialize_ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREid(soap, (const struct ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREid *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREidResponse:
		soap_serialize_ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREidResponse(soap, (const struct ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREidResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREget:
		soap_serialize_ns1__mc_USCOREissue_USCOREget(soap, (const struct ns1__mc_USCOREissue_USCOREget *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREgetResponse:
		soap_serialize_ns1__mc_USCOREissue_USCOREgetResponse(soap, (const struct ns1__mc_USCOREissue_USCOREgetResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREexists:
		soap_serialize_ns1__mc_USCOREissue_USCOREexists(soap, (const struct ns1__mc_USCOREissue_USCOREexists *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREissue_USCOREexistsResponse:
		soap_serialize_ns1__mc_USCOREissue_USCOREexistsResponse(soap, (const struct ns1__mc_USCOREissue_USCOREexistsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREget:
		soap_serialize_ns1__mc_USCOREenum_USCOREget(soap, (const struct ns1__mc_USCOREenum_USCOREget *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREgetResponse:
		soap_serialize_ns1__mc_USCOREenum_USCOREgetResponse(soap, (const struct ns1__mc_USCOREenum_USCOREgetResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypes:
		soap_serialize_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypes(soap, (const struct ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypes *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse:
		soap_serialize_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse(soap, (const struct ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREview_USCOREstates:
		soap_serialize_ns1__mc_USCOREenum_USCOREview_USCOREstates(soap, (const struct ns1__mc_USCOREenum_USCOREview_USCOREstates *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse:
		soap_serialize_ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse(soap, (const struct ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstates:
		soap_serialize_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstates(soap, (const struct ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstates *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse:
		soap_serialize_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse(soap, (const struct ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREproject_USCOREstatus:
		soap_serialize_ns1__mc_USCOREenum_USCOREproject_USCOREstatus(soap, (const struct ns1__mc_USCOREenum_USCOREproject_USCOREstatus *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse:
		soap_serialize_ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse(soap, (const struct ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREaccess_USCORElevels:
		soap_serialize_ns1__mc_USCOREenum_USCOREaccess_USCORElevels(soap, (const struct ns1__mc_USCOREenum_USCOREaccess_USCORElevels *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse:
		soap_serialize_ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse(soap, (const struct ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREresolutions:
		soap_serialize_ns1__mc_USCOREenum_USCOREresolutions(soap, (const struct ns1__mc_USCOREenum_USCOREresolutions *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREresolutionsResponse:
		soap_serialize_ns1__mc_USCOREenum_USCOREresolutionsResponse(soap, (const struct ns1__mc_USCOREenum_USCOREresolutionsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREetas:
		soap_serialize_ns1__mc_USCOREenum_USCOREetas(soap, (const struct ns1__mc_USCOREenum_USCOREetas *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREetasResponse:
		soap_serialize_ns1__mc_USCOREenum_USCOREetasResponse(soap, (const struct ns1__mc_USCOREenum_USCOREetasResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREprojections:
		soap_serialize_ns1__mc_USCOREenum_USCOREprojections(soap, (const struct ns1__mc_USCOREenum_USCOREprojections *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREprojectionsResponse:
		soap_serialize_ns1__mc_USCOREenum_USCOREprojectionsResponse(soap, (const struct ns1__mc_USCOREenum_USCOREprojectionsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREreproducibilities:
		soap_serialize_ns1__mc_USCOREenum_USCOREreproducibilities(soap, (const struct ns1__mc_USCOREenum_USCOREreproducibilities *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREreproducibilitiesResponse:
		soap_serialize_ns1__mc_USCOREenum_USCOREreproducibilitiesResponse(soap, (const struct ns1__mc_USCOREenum_USCOREreproducibilitiesResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREseverities:
		soap_serialize_ns1__mc_USCOREenum_USCOREseverities(soap, (const struct ns1__mc_USCOREenum_USCOREseverities *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREseveritiesResponse:
		soap_serialize_ns1__mc_USCOREenum_USCOREseveritiesResponse(soap, (const struct ns1__mc_USCOREenum_USCOREseveritiesResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREpriorities:
		soap_serialize_ns1__mc_USCOREenum_USCOREpriorities(soap, (const struct ns1__mc_USCOREenum_USCOREpriorities *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREprioritiesResponse:
		soap_serialize_ns1__mc_USCOREenum_USCOREprioritiesResponse(soap, (const struct ns1__mc_USCOREenum_USCOREprioritiesResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREstatus:
		soap_serialize_ns1__mc_USCOREenum_USCOREstatus(soap, (const struct ns1__mc_USCOREenum_USCOREstatus *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREenum_USCOREstatusResponse:
		soap_serialize_ns1__mc_USCOREenum_USCOREstatusResponse(soap, (const struct ns1__mc_USCOREenum_USCOREstatusResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREversion:
		soap_serialize_ns1__mc_USCOREversion(soap, (const struct ns1__mc_USCOREversion *)ptr);
		break;
	case SOAP_TYPE_ns1__mc_USCOREversionResponse:
		soap_serialize_ns1__mc_USCOREversionResponse(soap, (const struct ns1__mc_USCOREversionResponse *)ptr);
		break;
	case SOAP_TYPE_CustomFieldLinkForProjectDataArray:
		soap_serialize_CustomFieldLinkForProjectDataArray(soap, (const struct CustomFieldLinkForProjectDataArray *)ptr);
		break;
	case SOAP_TYPE_CustomFieldDefinitionDataArray:
		soap_serialize_CustomFieldDefinitionDataArray(soap, (const struct CustomFieldDefinitionDataArray *)ptr);
		break;
	case SOAP_TYPE_FilterDataArray:
		soap_serialize_FilterDataArray(soap, (const struct FilterDataArray *)ptr);
		break;
	case SOAP_TYPE_ProjectVersionDataArray:
		soap_serialize_ProjectVersionDataArray(soap, (const struct ProjectVersionDataArray *)ptr);
		break;
	case SOAP_TYPE_IssueHeaderDataArray:
		soap_serialize_IssueHeaderDataArray(soap, (const struct IssueHeaderDataArray *)ptr);
		break;
	case SOAP_TYPE_IssueDataArray:
		soap_serialize_IssueDataArray(soap, (const struct IssueDataArray *)ptr);
		break;
	case SOAP_TYPE_ProjectAttachmentDataArray:
		soap_serialize_ProjectAttachmentDataArray(soap, (const struct ProjectAttachmentDataArray *)ptr);
		break;
	case SOAP_TYPE_AccountDataArray:
		soap_serialize_AccountDataArray(soap, (const struct AccountDataArray *)ptr);
		break;
	case SOAP_TYPE_ObjectRefArray:
		soap_serialize_ObjectRefArray(soap, (const struct ObjectRefArray *)ptr);
		break;
	case SOAP_TYPE_StringArray:
		soap_serialize_StringArray(soap, (const struct StringArray *)ptr);
		break;
	case SOAP_TYPE_ns1__CustomFieldValueForIssueData:
		soap_serialize_ns1__CustomFieldValueForIssueData(soap, (const struct ns1__CustomFieldValueForIssueData *)ptr);
		break;
	case SOAP_TYPE_ns1__CustomFieldLinkForProjectData:
		soap_serialize_ns1__CustomFieldLinkForProjectData(soap, (const struct ns1__CustomFieldLinkForProjectData *)ptr);
		break;
	case SOAP_TYPE_ns1__CustomFieldDefinitionData:
		soap_serialize_ns1__CustomFieldDefinitionData(soap, (const struct ns1__CustomFieldDefinitionData *)ptr);
		break;
	case SOAP_TYPE_ns1__FilterData:
		soap_serialize_ns1__FilterData(soap, (const struct ns1__FilterData *)ptr);
		break;
	case SOAP_TYPE_ns1__ProjectVersionData:
		soap_serialize_ns1__ProjectVersionData(soap, (const struct ns1__ProjectVersionData *)ptr);
		break;
	case SOAP_TYPE_ProjectDataArray:
		soap_serialize_ProjectDataArray(soap, (const struct ProjectDataArray *)ptr);
		break;
	case SOAP_TYPE_ns1__ProjectData:
		soap_serialize_ns1__ProjectData(soap, (const struct ns1__ProjectData *)ptr);
		break;
	case SOAP_TYPE_ns1__IssueHeaderData:
		soap_serialize_ns1__IssueHeaderData(soap, (const struct ns1__IssueHeaderData *)ptr);
		break;
	case SOAP_TYPE_CustomFieldValueForIssueDataArray:
		soap_serialize_CustomFieldValueForIssueDataArray(soap, (const struct CustomFieldValueForIssueDataArray *)ptr);
		break;
	case SOAP_TYPE_IssueNoteDataArray:
		soap_serialize_IssueNoteDataArray(soap, (const struct IssueNoteDataArray *)ptr);
		break;
	case SOAP_TYPE_RelationshipDataArray:
		soap_serialize_RelationshipDataArray(soap, (const struct RelationshipDataArray *)ptr);
		break;
	case SOAP_TYPE_AttachmentDataArray:
		soap_serialize_AttachmentDataArray(soap, (const struct AttachmentDataArray *)ptr);
		break;
	case SOAP_TYPE_ns1__IssueData:
		soap_serialize_ns1__IssueData(soap, (const struct ns1__IssueData *)ptr);
		break;
	case SOAP_TYPE_ns1__IssueNoteData:
		soap_serialize_ns1__IssueNoteData(soap, (const struct ns1__IssueNoteData *)ptr);
		break;
	case SOAP_TYPE_ns1__RelationshipData:
		soap_serialize_ns1__RelationshipData(soap, (const struct ns1__RelationshipData *)ptr);
		break;
	case SOAP_TYPE_ns1__ProjectAttachmentData:
		soap_serialize_ns1__ProjectAttachmentData(soap, (const struct ns1__ProjectAttachmentData *)ptr);
		break;
	case SOAP_TYPE_ns1__AttachmentData:
		soap_serialize_ns1__AttachmentData(soap, (const struct ns1__AttachmentData *)ptr);
		break;
	case SOAP_TYPE_ns1__AccountData:
		soap_serialize_ns1__AccountData(soap, (const struct ns1__AccountData *)ptr);
		break;
	case SOAP_TYPE_ns1__ObjectRef:
		soap_serialize_ns1__ObjectRef(soap, (const struct ns1__ObjectRef *)ptr);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		soap_serialize_xsd__base64Binary(soap, (const struct xsd__base64Binary *)ptr);
		break;
	case SOAP_TYPE_PointerTons1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse:
		soap_serialize_PointerTons1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse(soap, (struct ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__mc_USCOREfilter_USCOREget_USCOREissuesResponse:
		soap_serialize_PointerTons1__mc_USCOREfilter_USCOREget_USCOREissuesResponse(soap, (struct ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__mc_USCOREfilter_USCOREgetResponse:
		soap_serialize_PointerTons1__mc_USCOREfilter_USCOREgetResponse(soap, (struct ns1__mc_USCOREfilter_USCOREgetResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToFilterDataArray:
		soap_serialize_PointerToFilterDataArray(soap, (struct FilterDataArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse:
		soap_serialize_PointerTons1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse(soap, (struct ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToCustomFieldDefinitionDataArray:
		soap_serialize_PointerToCustomFieldDefinitionDataArray(soap, (struct CustomFieldDefinitionDataArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse:
		soap_serialize_PointerTons1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse(soap, (struct ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToProjectAttachmentDataArray:
		soap_serialize_PointerToProjectAttachmentDataArray(soap, (struct ProjectAttachmentDataArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse:
		soap_serialize_PointerTons1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse(soap, (struct ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse:
		soap_serialize_PointerTons1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse(soap, (struct ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__mc_USCOREproject_USCOREget_USCOREversionsResponse:
		soap_serialize_PointerTons1__mc_USCOREproject_USCOREget_USCOREversionsResponse(soap, (struct ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToProjectVersionDataArray:
		soap_serialize_PointerToProjectVersionDataArray(soap, (struct ProjectVersionDataArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse:
		soap_serialize_PointerTons1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse(soap, (struct ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToStringArray:
		soap_serialize_PointerToStringArray(soap, (struct StringArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse:
		soap_serialize_PointerTons1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse(soap, (struct ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__mc_USCOREproject_USCOREget_USCOREusersResponse:
		soap_serialize_PointerTons1__mc_USCOREproject_USCOREget_USCOREusersResponse(soap, (struct ns1__mc_USCOREproject_USCOREget_USCOREusersResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToAccountDataArray:
		soap_serialize_PointerToAccountDataArray(soap, (struct AccountDataArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse:
		soap_serialize_PointerTons1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse(soap, (struct ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToIssueHeaderDataArray:
		soap_serialize_PointerToIssueHeaderDataArray(soap, (struct IssueHeaderDataArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__mc_USCOREproject_USCOREget_USCOREissuesResponse:
		soap_serialize_PointerTons1__mc_USCOREproject_USCOREget_USCOREissuesResponse(soap, (struct ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToIssueDataArray:
		soap_serialize_PointerToIssueDataArray(soap, (struct IssueDataArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__base64Binary:
		soap_serialize_PointerToxsd__base64Binary(soap, (struct xsd__base64Binary *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__integer:
		soap_serialize_PointerToxsd__integer(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__mc_USCOREissue_USCOREgetResponse:
		soap_serialize_PointerTons1__mc_USCOREissue_USCOREgetResponse(soap, (struct ns1__mc_USCOREissue_USCOREgetResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse:
		soap_serialize_PointerTons1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse(soap, (struct ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREview_USCOREstatesResponse:
		soap_serialize_PointerTons1__mc_USCOREenum_USCOREview_USCOREstatesResponse(soap, (struct ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse:
		soap_serialize_PointerTons1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse(soap, (struct ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREproject_USCOREstatusResponse:
		soap_serialize_PointerTons1__mc_USCOREenum_USCOREproject_USCOREstatusResponse(soap, (struct ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse:
		soap_serialize_PointerTons1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse(soap, (struct ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREresolutionsResponse:
		soap_serialize_PointerTons1__mc_USCOREenum_USCOREresolutionsResponse(soap, (struct ns1__mc_USCOREenum_USCOREresolutionsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREetasResponse:
		soap_serialize_PointerTons1__mc_USCOREenum_USCOREetasResponse(soap, (struct ns1__mc_USCOREenum_USCOREetasResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREprojectionsResponse:
		soap_serialize_PointerTons1__mc_USCOREenum_USCOREprojectionsResponse(soap, (struct ns1__mc_USCOREenum_USCOREprojectionsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREreproducibilitiesResponse:
		soap_serialize_PointerTons1__mc_USCOREenum_USCOREreproducibilitiesResponse(soap, (struct ns1__mc_USCOREenum_USCOREreproducibilitiesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREseveritiesResponse:
		soap_serialize_PointerTons1__mc_USCOREenum_USCOREseveritiesResponse(soap, (struct ns1__mc_USCOREenum_USCOREseveritiesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREprioritiesResponse:
		soap_serialize_PointerTons1__mc_USCOREenum_USCOREprioritiesResponse(soap, (struct ns1__mc_USCOREenum_USCOREprioritiesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREstatusResponse:
		soap_serialize_PointerTons1__mc_USCOREenum_USCOREstatusResponse(soap, (struct ns1__mc_USCOREenum_USCOREstatusResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToObjectRefArray:
		soap_serialize_PointerToObjectRefArray(soap, (struct ObjectRefArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CustomFieldValueForIssueData:
		soap_serialize_PointerToPointerTons1__CustomFieldValueForIssueData(soap, (struct ns1__CustomFieldValueForIssueData **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CustomFieldValueForIssueData:
		soap_serialize_PointerTons1__CustomFieldValueForIssueData(soap, (struct ns1__CustomFieldValueForIssueData *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CustomFieldLinkForProjectData:
		soap_serialize_PointerToPointerTons1__CustomFieldLinkForProjectData(soap, (struct ns1__CustomFieldLinkForProjectData **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CustomFieldLinkForProjectData:
		soap_serialize_PointerTons1__CustomFieldLinkForProjectData(soap, (struct ns1__CustomFieldLinkForProjectData *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CustomFieldDefinitionData:
		soap_serialize_PointerToPointerTons1__CustomFieldDefinitionData(soap, (struct ns1__CustomFieldDefinitionData **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CustomFieldDefinitionData:
		soap_serialize_PointerTons1__CustomFieldDefinitionData(soap, (struct ns1__CustomFieldDefinitionData *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__FilterData:
		soap_serialize_PointerToPointerTons1__FilterData(soap, (struct ns1__FilterData **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__FilterData:
		soap_serialize_PointerTons1__FilterData(soap, (struct ns1__FilterData *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__ProjectVersionData:
		soap_serialize_PointerToPointerTons1__ProjectVersionData(soap, (struct ns1__ProjectVersionData **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ProjectVersionData:
		soap_serialize_PointerTons1__ProjectVersionData(soap, (struct ns1__ProjectVersionData *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__ProjectData:
		soap_serialize_PointerToPointerTons1__ProjectData(soap, (struct ns1__ProjectData **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ProjectData:
		soap_serialize_PointerTons1__ProjectData(soap, (struct ns1__ProjectData *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__IssueHeaderData:
		soap_serialize_PointerToPointerTons1__IssueHeaderData(soap, (struct ns1__IssueHeaderData **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__IssueHeaderData:
		soap_serialize_PointerTons1__IssueHeaderData(soap, (struct ns1__IssueHeaderData *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__IssueData:
		soap_serialize_PointerToPointerTons1__IssueData(soap, (struct ns1__IssueData **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__IssueData:
		soap_serialize_PointerTons1__IssueData(soap, (struct ns1__IssueData *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__IssueNoteData:
		soap_serialize_PointerToPointerTons1__IssueNoteData(soap, (struct ns1__IssueNoteData **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__IssueNoteData:
		soap_serialize_PointerTons1__IssueNoteData(soap, (struct ns1__IssueNoteData *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__RelationshipData:
		soap_serialize_PointerToPointerTons1__RelationshipData(soap, (struct ns1__RelationshipData **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RelationshipData:
		soap_serialize_PointerTons1__RelationshipData(soap, (struct ns1__RelationshipData *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__ProjectAttachmentData:
		soap_serialize_PointerToPointerTons1__ProjectAttachmentData(soap, (struct ns1__ProjectAttachmentData **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ProjectAttachmentData:
		soap_serialize_PointerTons1__ProjectAttachmentData(soap, (struct ns1__ProjectAttachmentData *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__AttachmentData:
		soap_serialize_PointerToPointerTons1__AttachmentData(soap, (struct ns1__AttachmentData **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AttachmentData:
		soap_serialize_PointerTons1__AttachmentData(soap, (struct ns1__AttachmentData *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__AccountData:
		soap_serialize_PointerToPointerTons1__AccountData(soap, (struct ns1__AccountData **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__ObjectRef:
		soap_serialize_PointerToPointerTons1__ObjectRef(soap, (struct ns1__ObjectRef **const*)ptr);
		break;
	case SOAP_TYPE_PointerTostring:
		soap_serialize_PointerTostring(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__byte:
		soap_serialize_PointerToxsd__byte(soap, (char *const*)ptr);
		break;
	case SOAP_TYPE_PointerToProjectDataArray:
		soap_serialize_PointerToProjectDataArray(soap, (struct ProjectDataArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__boolean:
		soap_serialize_PointerToxsd__boolean(soap, (enum xsd__boolean *const*)ptr);
		break;
	case SOAP_TYPE_PointerToCustomFieldValueForIssueDataArray:
		soap_serialize_PointerToCustomFieldValueForIssueDataArray(soap, (struct CustomFieldValueForIssueDataArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerToIssueNoteDataArray:
		soap_serialize_PointerToIssueNoteDataArray(soap, (struct IssueNoteDataArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerToRelationshipDataArray:
		soap_serialize_PointerToRelationshipDataArray(soap, (struct RelationshipDataArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerToAttachmentDataArray:
		soap_serialize_PointerToAttachmentDataArray(soap, (struct AttachmentDataArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AccountData:
		soap_serialize_PointerTons1__AccountData(soap, (struct ns1__AccountData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ObjectRef:
		soap_serialize_PointerTons1__ObjectRef(soap, (struct ns1__ObjectRef *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotime:
		soap_serialize_PointerTotime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE_xsd__integer:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_PointerTounsignedByte:
		soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE_xsd__anyURI:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_xsd__byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_xsd__byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_xsd__byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__byte);
	if (soap_out_xsd__byte(soap, tag?tag:"xsd:byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_xsd__byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedByte(struct soap *soap, unsigned char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedByte
	*a = SOAP_DEFAULT_unsignedByte;
#else
	*a = (unsigned char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{	unsigned char *p;
	p = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedByte);
	if (soap_out_unsignedByte(soap, tag?tag:"unsignedByte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{	unsigned int *p;
	p = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
	if (soap_out_unsignedInt(soap, tag?tag:"unsignedInt", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{	time_t *p;
	p = soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__boolean(struct soap *soap, enum xsd__boolean *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_xsd__boolean
	*a = SOAP_DEFAULT_xsd__boolean;
#else
	*a = (enum xsd__boolean)0;
#endif
}

static const struct soap_code_map soap_codes_xsd__boolean[] =
{	{ (long)xsd__boolean__false_, "false" },
	{ (long)xsd__boolean__true_, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__boolean2s(struct soap *soap, enum xsd__boolean n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_xsd__boolean, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean(struct soap *soap, const char *tag, int id, const enum xsd__boolean *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xsd__boolean), type) || soap_send(soap, soap_xsd__boolean2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__boolean(struct soap *soap, const char *s, enum xsd__boolean *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_xsd__boolean, s);
	if (map)
		*a = (enum xsd__boolean)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum xsd__boolean)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_in_xsd__boolean(struct soap *soap, const char *tag, enum xsd__boolean *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum xsd__boolean *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2xsd__boolean(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum xsd__boolean *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__boolean, 0, sizeof(enum xsd__boolean), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__boolean(struct soap *soap, const enum xsd__boolean *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__boolean);
	if (soap_out_xsd__boolean(soap, tag?tag:"xsd:boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_get_xsd__boolean(struct soap *soap, enum xsd__boolean *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREissue_USCOREcheckin(struct soap *soap, struct ns1__mc_USCOREissue_USCOREcheckin *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
	soap_default_xsd__integer(soap, &a->issue_USCOREid);
	soap_default_string(soap, &a->comment);
	soap_default_xsd__boolean(soap, &a->fixed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREissue_USCOREcheckin(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREcheckin *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
	soap_serialize_xsd__integer(soap, &a->issue_USCOREid);
	soap_serialize_string(soap, &a->comment);
	soap_embedded(soap, &a->fixed, SOAP_TYPE_xsd__boolean);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREissue_USCOREcheckin(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREissue_USCOREcheckin *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREcheckin), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "issue_id", -1, &a->issue_USCOREid, ""))
		return soap->error;
	if (soap_out_string(soap, "comment", -1, &a->comment, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "fixed", -1, &a->fixed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREcheckin * SOAP_FMAC4 soap_in_ns1__mc_USCOREissue_USCOREcheckin(struct soap *soap, const char *tag, struct ns1__mc_USCOREissue_USCOREcheckin *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_issue_USCOREid = 1;
	size_t soap_flag_comment = 1;
	size_t soap_flag_fixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREissue_USCOREcheckin *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREcheckin, sizeof(struct ns1__mc_USCOREissue_USCOREcheckin), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREissue_USCOREcheckin(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_issue_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "issue_id", &a->issue_USCOREid, "xsd:integer"))
				{	soap_flag_issue_USCOREid--;
					continue;
				}
			if (soap_flag_comment && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "comment", &a->comment, "xsd:string"))
				{	soap_flag_comment--;
					continue;
				}
			if (soap_flag_fixed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "fixed", &a->fixed, "xsd:boolean"))
				{	soap_flag_fixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREissue_USCOREcheckin *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREissue_USCOREcheckin, 0, sizeof(struct ns1__mc_USCOREissue_USCOREcheckin), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fixed > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREissue_USCOREcheckin(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREcheckin *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREissue_USCOREcheckin);
	if (soap_out_ns1__mc_USCOREissue_USCOREcheckin(soap, tag?tag:"ns1:mc_issue_checkin", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREcheckin * SOAP_FMAC4 soap_get_ns1__mc_USCOREissue_USCOREcheckin(struct soap *soap, struct ns1__mc_USCOREissue_USCOREcheckin *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREissue_USCOREcheckin(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREissue_USCOREcheckinResponse(struct soap *soap, struct ns1__mc_USCOREissue_USCOREcheckinResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREissue_USCOREcheckinResponse(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREcheckinResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__boolean(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREissue_USCOREcheckinResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREissue_USCOREcheckinResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREcheckinResponse), type))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREcheckinResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREissue_USCOREcheckinResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREissue_USCOREcheckinResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREissue_USCOREcheckinResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREcheckinResponse, sizeof(struct ns1__mc_USCOREissue_USCOREcheckinResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREissue_USCOREcheckinResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "return", &a->return_, "xsd:boolean"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREissue_USCOREcheckinResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREissue_USCOREcheckinResponse, 0, sizeof(struct ns1__mc_USCOREissue_USCOREcheckinResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREissue_USCOREcheckinResponse(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREcheckinResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREissue_USCOREcheckinResponse);
	if (soap_out_ns1__mc_USCOREissue_USCOREcheckinResponse(soap, tag?tag:"ns1:mc_issue_checkinResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREcheckinResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREissue_USCOREcheckinResponse(struct soap *soap, struct ns1__mc_USCOREissue_USCOREcheckinResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREissue_USCOREcheckinResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREconfig_USCOREget_USCOREstring(struct soap *soap, struct ns1__mc_USCOREconfig_USCOREget_USCOREstring *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
	soap_default_string(soap, &a->config_USCOREvar);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREconfig_USCOREget_USCOREstring(struct soap *soap, const struct ns1__mc_USCOREconfig_USCOREget_USCOREstring *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
	soap_serialize_string(soap, &a->config_USCOREvar);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREconfig_USCOREget_USCOREstring(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREconfig_USCOREget_USCOREstring *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREconfig_USCOREget_USCOREstring), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_string(soap, "config_var", -1, &a->config_USCOREvar, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREconfig_USCOREget_USCOREstring * SOAP_FMAC4 soap_in_ns1__mc_USCOREconfig_USCOREget_USCOREstring(struct soap *soap, const char *tag, struct ns1__mc_USCOREconfig_USCOREget_USCOREstring *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_config_USCOREvar = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREconfig_USCOREget_USCOREstring *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREconfig_USCOREget_USCOREstring, sizeof(struct ns1__mc_USCOREconfig_USCOREget_USCOREstring), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREconfig_USCOREget_USCOREstring(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_config_USCOREvar && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "config_var", &a->config_USCOREvar, "xsd:string"))
				{	soap_flag_config_USCOREvar--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREconfig_USCOREget_USCOREstring *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREconfig_USCOREget_USCOREstring, 0, sizeof(struct ns1__mc_USCOREconfig_USCOREget_USCOREstring), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREconfig_USCOREget_USCOREstring(struct soap *soap, const struct ns1__mc_USCOREconfig_USCOREget_USCOREstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREconfig_USCOREget_USCOREstring);
	if (soap_out_ns1__mc_USCOREconfig_USCOREget_USCOREstring(soap, tag?tag:"ns1:mc_config_get_string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREconfig_USCOREget_USCOREstring * SOAP_FMAC4 soap_get_ns1__mc_USCOREconfig_USCOREget_USCOREstring(struct soap *soap, struct ns1__mc_USCOREconfig_USCOREget_USCOREstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREconfig_USCOREget_USCOREstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREconfig_USCOREget_USCOREstringResponse(struct soap *soap, struct ns1__mc_USCOREconfig_USCOREget_USCOREstringResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREconfig_USCOREget_USCOREstringResponse(struct soap *soap, const struct ns1__mc_USCOREconfig_USCOREget_USCOREstringResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREconfig_USCOREget_USCOREstringResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREconfig_USCOREget_USCOREstringResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREconfig_USCOREget_USCOREstringResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREconfig_USCOREget_USCOREstringResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREconfig_USCOREget_USCOREstringResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREconfig_USCOREget_USCOREstringResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREconfig_USCOREget_USCOREstringResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREconfig_USCOREget_USCOREstringResponse, sizeof(struct ns1__mc_USCOREconfig_USCOREget_USCOREstringResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREconfig_USCOREget_USCOREstringResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREconfig_USCOREget_USCOREstringResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREconfig_USCOREget_USCOREstringResponse, 0, sizeof(struct ns1__mc_USCOREconfig_USCOREget_USCOREstringResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREconfig_USCOREget_USCOREstringResponse(struct soap *soap, const struct ns1__mc_USCOREconfig_USCOREget_USCOREstringResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREconfig_USCOREget_USCOREstringResponse);
	if (soap_out_ns1__mc_USCOREconfig_USCOREget_USCOREstringResponse(soap, tag?tag:"ns1:mc_config_get_stringResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREconfig_USCOREget_USCOREstringResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREconfig_USCOREget_USCOREstringResponse(struct soap *soap, struct ns1__mc_USCOREconfig_USCOREget_USCOREstringResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREconfig_USCOREget_USCOREstringResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheaders(struct soap *soap, struct ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheaders *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
	soap_default_xsd__integer(soap, &a->project_USCOREid);
	soap_default_xsd__integer(soap, &a->filter_USCOREid);
	soap_default_xsd__integer(soap, &a->page_USCOREnumber);
	soap_default_xsd__integer(soap, &a->per_USCOREpage);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheaders(struct soap *soap, const struct ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheaders *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
	soap_serialize_xsd__integer(soap, &a->project_USCOREid);
	soap_serialize_xsd__integer(soap, &a->filter_USCOREid);
	soap_serialize_xsd__integer(soap, &a->page_USCOREnumber);
	soap_serialize_xsd__integer(soap, &a->per_USCOREpage);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheaders(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheaders *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheaders), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "project_id", -1, &a->project_USCOREid, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "filter_id", -1, &a->filter_USCOREid, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "page_number", -1, &a->page_USCOREnumber, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "per_page", -1, &a->per_USCOREpage, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheaders * SOAP_FMAC4 soap_in_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheaders(struct soap *soap, const char *tag, struct ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheaders *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_project_USCOREid = 1;
	size_t soap_flag_filter_USCOREid = 1;
	size_t soap_flag_page_USCOREnumber = 1;
	size_t soap_flag_per_USCOREpage = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheaders *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheaders, sizeof(struct ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheaders), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheaders(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_project_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "project_id", &a->project_USCOREid, "xsd:integer"))
				{	soap_flag_project_USCOREid--;
					continue;
				}
			if (soap_flag_filter_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "filter_id", &a->filter_USCOREid, "xsd:integer"))
				{	soap_flag_filter_USCOREid--;
					continue;
				}
			if (soap_flag_page_USCOREnumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "page_number", &a->page_USCOREnumber, "xsd:integer"))
				{	soap_flag_page_USCOREnumber--;
					continue;
				}
			if (soap_flag_per_USCOREpage && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "per_page", &a->per_USCOREpage, "xsd:integer"))
				{	soap_flag_per_USCOREpage--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheaders *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheaders, 0, sizeof(struct ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheaders), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheaders(struct soap *soap, const struct ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheaders *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheaders);
	if (soap_out_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheaders(soap, tag?tag:"ns1:mc_filter_get_issue_headers", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheaders * SOAP_FMAC4 soap_get_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheaders(struct soap *soap, struct ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheaders *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheaders(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse(struct soap *soap, struct ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse(struct soap *soap, const struct ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToIssueHeaderDataArray(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse), type))
		return soap->error;
	if (soap_out_PointerToIssueHeaderDataArray(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse, sizeof(struct ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToIssueHeaderDataArray(soap, "return", &a->return_, "ns1:IssueHeaderData"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse, 0, sizeof(struct ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse(struct soap *soap, const struct ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse);
	if (soap_out_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse(soap, tag?tag:"ns1:mc_filter_get_issue_headersResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse(struct soap *soap, struct ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREfilter_USCOREget_USCOREissues(struct soap *soap, struct ns1__mc_USCOREfilter_USCOREget_USCOREissues *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
	soap_default_xsd__integer(soap, &a->project_USCOREid);
	soap_default_xsd__integer(soap, &a->filter_USCOREid);
	soap_default_xsd__integer(soap, &a->page_USCOREnumber);
	soap_default_xsd__integer(soap, &a->per_USCOREpage);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREfilter_USCOREget_USCOREissues(struct soap *soap, const struct ns1__mc_USCOREfilter_USCOREget_USCOREissues *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
	soap_serialize_xsd__integer(soap, &a->project_USCOREid);
	soap_serialize_xsd__integer(soap, &a->filter_USCOREid);
	soap_serialize_xsd__integer(soap, &a->page_USCOREnumber);
	soap_serialize_xsd__integer(soap, &a->per_USCOREpage);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREfilter_USCOREget_USCOREissues(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREfilter_USCOREget_USCOREissues *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREfilter_USCOREget_USCOREissues), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "project_id", -1, &a->project_USCOREid, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "filter_id", -1, &a->filter_USCOREid, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "page_number", -1, &a->page_USCOREnumber, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "per_page", -1, &a->per_USCOREpage, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREfilter_USCOREget_USCOREissues * SOAP_FMAC4 soap_in_ns1__mc_USCOREfilter_USCOREget_USCOREissues(struct soap *soap, const char *tag, struct ns1__mc_USCOREfilter_USCOREget_USCOREissues *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_project_USCOREid = 1;
	size_t soap_flag_filter_USCOREid = 1;
	size_t soap_flag_page_USCOREnumber = 1;
	size_t soap_flag_per_USCOREpage = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREfilter_USCOREget_USCOREissues *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREfilter_USCOREget_USCOREissues, sizeof(struct ns1__mc_USCOREfilter_USCOREget_USCOREissues), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREfilter_USCOREget_USCOREissues(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_project_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "project_id", &a->project_USCOREid, "xsd:integer"))
				{	soap_flag_project_USCOREid--;
					continue;
				}
			if (soap_flag_filter_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "filter_id", &a->filter_USCOREid, "xsd:integer"))
				{	soap_flag_filter_USCOREid--;
					continue;
				}
			if (soap_flag_page_USCOREnumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "page_number", &a->page_USCOREnumber, "xsd:integer"))
				{	soap_flag_page_USCOREnumber--;
					continue;
				}
			if (soap_flag_per_USCOREpage && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "per_page", &a->per_USCOREpage, "xsd:integer"))
				{	soap_flag_per_USCOREpage--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREfilter_USCOREget_USCOREissues *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREfilter_USCOREget_USCOREissues, 0, sizeof(struct ns1__mc_USCOREfilter_USCOREget_USCOREissues), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREfilter_USCOREget_USCOREissues(struct soap *soap, const struct ns1__mc_USCOREfilter_USCOREget_USCOREissues *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREfilter_USCOREget_USCOREissues);
	if (soap_out_ns1__mc_USCOREfilter_USCOREget_USCOREissues(soap, tag?tag:"ns1:mc_filter_get_issues", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREfilter_USCOREget_USCOREissues * SOAP_FMAC4 soap_get_ns1__mc_USCOREfilter_USCOREget_USCOREissues(struct soap *soap, struct ns1__mc_USCOREfilter_USCOREget_USCOREissues *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREfilter_USCOREget_USCOREissues(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse(struct soap *soap, struct ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse(struct soap *soap, const struct ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToIssueDataArray(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse), type))
		return soap->error;
	if (soap_out_PointerToIssueDataArray(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse, sizeof(struct ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToIssueDataArray(soap, "return", &a->return_, "ns1:IssueData"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse, 0, sizeof(struct ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse(struct soap *soap, const struct ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse);
	if (soap_out_ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse(soap, tag?tag:"ns1:mc_filter_get_issuesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse(struct soap *soap, struct ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREfilter_USCOREget(struct soap *soap, struct ns1__mc_USCOREfilter_USCOREget *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
	soap_default_xsd__integer(soap, &a->project_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREfilter_USCOREget(struct soap *soap, const struct ns1__mc_USCOREfilter_USCOREget *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
	soap_serialize_xsd__integer(soap, &a->project_USCOREid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREfilter_USCOREget(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREfilter_USCOREget *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREfilter_USCOREget), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "project_id", -1, &a->project_USCOREid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREfilter_USCOREget * SOAP_FMAC4 soap_in_ns1__mc_USCOREfilter_USCOREget(struct soap *soap, const char *tag, struct ns1__mc_USCOREfilter_USCOREget *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_project_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREfilter_USCOREget *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREfilter_USCOREget, sizeof(struct ns1__mc_USCOREfilter_USCOREget), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREfilter_USCOREget(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_project_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "project_id", &a->project_USCOREid, "xsd:integer"))
				{	soap_flag_project_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREfilter_USCOREget *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREfilter_USCOREget, 0, sizeof(struct ns1__mc_USCOREfilter_USCOREget), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREfilter_USCOREget(struct soap *soap, const struct ns1__mc_USCOREfilter_USCOREget *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREfilter_USCOREget);
	if (soap_out_ns1__mc_USCOREfilter_USCOREget(soap, tag?tag:"ns1:mc_filter_get", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREfilter_USCOREget * SOAP_FMAC4 soap_get_ns1__mc_USCOREfilter_USCOREget(struct soap *soap, struct ns1__mc_USCOREfilter_USCOREget *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREfilter_USCOREget(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREfilter_USCOREgetResponse(struct soap *soap, struct ns1__mc_USCOREfilter_USCOREgetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREfilter_USCOREgetResponse(struct soap *soap, const struct ns1__mc_USCOREfilter_USCOREgetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToFilterDataArray(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREfilter_USCOREgetResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREfilter_USCOREgetResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREfilter_USCOREgetResponse), type))
		return soap->error;
	if (soap_out_PointerToFilterDataArray(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREfilter_USCOREgetResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREfilter_USCOREgetResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREfilter_USCOREgetResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREfilter_USCOREgetResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREfilter_USCOREgetResponse, sizeof(struct ns1__mc_USCOREfilter_USCOREgetResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREfilter_USCOREgetResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToFilterDataArray(soap, "return", &a->return_, "ns1:FilterData"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREfilter_USCOREgetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREfilter_USCOREgetResponse, 0, sizeof(struct ns1__mc_USCOREfilter_USCOREgetResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREfilter_USCOREgetResponse(struct soap *soap, const struct ns1__mc_USCOREfilter_USCOREgetResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREfilter_USCOREgetResponse);
	if (soap_out_ns1__mc_USCOREfilter_USCOREgetResponse(soap, tag?tag:"ns1:mc_filter_getResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREfilter_USCOREgetResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREfilter_USCOREgetResponse(struct soap *soap, struct ns1__mc_USCOREfilter_USCOREgetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREfilter_USCOREgetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREproject_USCOREattachment_USCOREdelete(struct soap *soap, struct ns1__mc_USCOREproject_USCOREattachment_USCOREdelete *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
	soap_default_xsd__integer(soap, &a->project_USCOREattachment_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREproject_USCOREattachment_USCOREdelete(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREattachment_USCOREdelete *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
	soap_serialize_xsd__integer(soap, &a->project_USCOREattachment_USCOREid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREproject_USCOREattachment_USCOREdelete(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREproject_USCOREattachment_USCOREdelete *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREdelete), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "project_attachment_id", -1, &a->project_USCOREattachment_USCOREid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREattachment_USCOREdelete * SOAP_FMAC4 soap_in_ns1__mc_USCOREproject_USCOREattachment_USCOREdelete(struct soap *soap, const char *tag, struct ns1__mc_USCOREproject_USCOREattachment_USCOREdelete *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_project_USCOREattachment_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREproject_USCOREattachment_USCOREdelete *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREdelete, sizeof(struct ns1__mc_USCOREproject_USCOREattachment_USCOREdelete), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREproject_USCOREattachment_USCOREdelete(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_project_USCOREattachment_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "project_attachment_id", &a->project_USCOREattachment_USCOREid, "xsd:integer"))
				{	soap_flag_project_USCOREattachment_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREproject_USCOREattachment_USCOREdelete *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREdelete, 0, sizeof(struct ns1__mc_USCOREproject_USCOREattachment_USCOREdelete), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREproject_USCOREattachment_USCOREdelete(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREattachment_USCOREdelete *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREdelete);
	if (soap_out_ns1__mc_USCOREproject_USCOREattachment_USCOREdelete(soap, tag?tag:"ns1:mc_project_attachment_delete", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREattachment_USCOREdelete * SOAP_FMAC4 soap_get_ns1__mc_USCOREproject_USCOREattachment_USCOREdelete(struct soap *soap, struct ns1__mc_USCOREproject_USCOREattachment_USCOREdelete *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREproject_USCOREattachment_USCOREdelete(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREproject_USCOREattachment_USCOREdeleteResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREattachment_USCOREdeleteResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREproject_USCOREattachment_USCOREdeleteResponse(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREattachment_USCOREdeleteResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__boolean(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREproject_USCOREattachment_USCOREdeleteResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREproject_USCOREattachment_USCOREdeleteResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREdeleteResponse), type))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREattachment_USCOREdeleteResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREproject_USCOREattachment_USCOREdeleteResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREproject_USCOREattachment_USCOREdeleteResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREproject_USCOREattachment_USCOREdeleteResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREdeleteResponse, sizeof(struct ns1__mc_USCOREproject_USCOREattachment_USCOREdeleteResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREproject_USCOREattachment_USCOREdeleteResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "return", &a->return_, "xsd:boolean"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREproject_USCOREattachment_USCOREdeleteResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREdeleteResponse, 0, sizeof(struct ns1__mc_USCOREproject_USCOREattachment_USCOREdeleteResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREproject_USCOREattachment_USCOREdeleteResponse(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREattachment_USCOREdeleteResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREdeleteResponse);
	if (soap_out_ns1__mc_USCOREproject_USCOREattachment_USCOREdeleteResponse(soap, tag?tag:"ns1:mc_project_attachment_deleteResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREattachment_USCOREdeleteResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREproject_USCOREattachment_USCOREdeleteResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREattachment_USCOREdeleteResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREproject_USCOREattachment_USCOREdeleteResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREproject_USCOREattachment_USCOREadd(struct soap *soap, struct ns1__mc_USCOREproject_USCOREattachment_USCOREadd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
	soap_default_xsd__integer(soap, &a->project_USCOREid);
	soap_default_string(soap, &a->name);
	soap_default_string(soap, &a->title);
	soap_default_string(soap, &a->description);
	soap_default_string(soap, &a->file_USCOREtype);
	soap_default_xsd__base64Binary(soap, &a->content);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREproject_USCOREattachment_USCOREadd(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREattachment_USCOREadd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
	soap_serialize_xsd__integer(soap, &a->project_USCOREid);
	soap_serialize_string(soap, &a->name);
	soap_serialize_string(soap, &a->title);
	soap_serialize_string(soap, &a->description);
	soap_serialize_string(soap, &a->file_USCOREtype);
	soap_embedded(soap, &a->content, SOAP_TYPE_xsd__base64Binary);
	soap_serialize_xsd__base64Binary(soap, &a->content);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREproject_USCOREattachment_USCOREadd(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREproject_USCOREattachment_USCOREadd *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREadd), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "project_id", -1, &a->project_USCOREid, ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->name, ""))
		return soap->error;
	if (soap_out_string(soap, "title", -1, &a->title, ""))
		return soap->error;
	if (soap_out_string(soap, "description", -1, &a->description, ""))
		return soap->error;
	if (soap_out_string(soap, "file_type", -1, &a->file_USCOREtype, ""))
		return soap->error;
	if (soap_out_xsd__base64Binary(soap, "content", -1, &a->content, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREattachment_USCOREadd * SOAP_FMAC4 soap_in_ns1__mc_USCOREproject_USCOREattachment_USCOREadd(struct soap *soap, const char *tag, struct ns1__mc_USCOREproject_USCOREattachment_USCOREadd *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_project_USCOREid = 1;
	size_t soap_flag_name = 1;
	size_t soap_flag_title = 1;
	size_t soap_flag_description = 1;
	size_t soap_flag_file_USCOREtype = 1;
	size_t soap_flag_content = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREproject_USCOREattachment_USCOREadd *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREadd, sizeof(struct ns1__mc_USCOREproject_USCOREattachment_USCOREadd), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREproject_USCOREattachment_USCOREadd(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_project_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "project_id", &a->project_USCOREid, "xsd:integer"))
				{	soap_flag_project_USCOREid--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_title && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "title", &a->title, "xsd:string"))
				{	soap_flag_title--;
					continue;
				}
			if (soap_flag_description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "description", &a->description, "xsd:string"))
				{	soap_flag_description--;
					continue;
				}
			if (soap_flag_file_USCOREtype && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "file_type", &a->file_USCOREtype, "xsd:string"))
				{	soap_flag_file_USCOREtype--;
					continue;
				}
			if (soap_flag_content && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__base64Binary(soap, "content", &a->content, "xsd:base64Binary"))
				{	soap_flag_content--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREproject_USCOREattachment_USCOREadd *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREadd, 0, sizeof(struct ns1__mc_USCOREproject_USCOREattachment_USCOREadd), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_content > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREproject_USCOREattachment_USCOREadd(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREattachment_USCOREadd *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREadd);
	if (soap_out_ns1__mc_USCOREproject_USCOREattachment_USCOREadd(soap, tag?tag:"ns1:mc_project_attachment_add", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREattachment_USCOREadd * SOAP_FMAC4 soap_get_ns1__mc_USCOREproject_USCOREattachment_USCOREadd(struct soap *soap, struct ns1__mc_USCOREproject_USCOREattachment_USCOREadd *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREproject_USCOREattachment_USCOREadd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREproject_USCOREattachment_USCOREaddResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREattachment_USCOREaddResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREproject_USCOREattachment_USCOREaddResponse(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREattachment_USCOREaddResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__integer(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREproject_USCOREattachment_USCOREaddResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREproject_USCOREattachment_USCOREaddResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREaddResponse), type))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREattachment_USCOREaddResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREproject_USCOREattachment_USCOREaddResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREproject_USCOREattachment_USCOREaddResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREproject_USCOREattachment_USCOREaddResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREaddResponse, sizeof(struct ns1__mc_USCOREproject_USCOREattachment_USCOREaddResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREproject_USCOREattachment_USCOREaddResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "return", &a->return_, "xsd:integer"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREproject_USCOREattachment_USCOREaddResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREaddResponse, 0, sizeof(struct ns1__mc_USCOREproject_USCOREattachment_USCOREaddResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREproject_USCOREattachment_USCOREaddResponse(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREattachment_USCOREaddResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREaddResponse);
	if (soap_out_ns1__mc_USCOREproject_USCOREattachment_USCOREaddResponse(soap, tag?tag:"ns1:mc_project_attachment_addResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREattachment_USCOREaddResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREproject_USCOREattachment_USCOREaddResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREattachment_USCOREaddResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREproject_USCOREattachment_USCOREaddResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREproject_USCOREattachment_USCOREget(struct soap *soap, struct ns1__mc_USCOREproject_USCOREattachment_USCOREget *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
	soap_default_xsd__integer(soap, &a->project_USCOREattachment_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREproject_USCOREattachment_USCOREget(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREattachment_USCOREget *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
	soap_serialize_xsd__integer(soap, &a->project_USCOREattachment_USCOREid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREproject_USCOREattachment_USCOREget(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREproject_USCOREattachment_USCOREget *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREget), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "project_attachment_id", -1, &a->project_USCOREattachment_USCOREid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREattachment_USCOREget * SOAP_FMAC4 soap_in_ns1__mc_USCOREproject_USCOREattachment_USCOREget(struct soap *soap, const char *tag, struct ns1__mc_USCOREproject_USCOREattachment_USCOREget *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_project_USCOREattachment_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREproject_USCOREattachment_USCOREget *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREget, sizeof(struct ns1__mc_USCOREproject_USCOREattachment_USCOREget), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREproject_USCOREattachment_USCOREget(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_project_USCOREattachment_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "project_attachment_id", &a->project_USCOREattachment_USCOREid, "xsd:integer"))
				{	soap_flag_project_USCOREattachment_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREproject_USCOREattachment_USCOREget *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREget, 0, sizeof(struct ns1__mc_USCOREproject_USCOREattachment_USCOREget), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREproject_USCOREattachment_USCOREget(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREattachment_USCOREget *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREget);
	if (soap_out_ns1__mc_USCOREproject_USCOREattachment_USCOREget(soap, tag?tag:"ns1:mc_project_attachment_get", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREattachment_USCOREget * SOAP_FMAC4 soap_get_ns1__mc_USCOREproject_USCOREattachment_USCOREget(struct soap *soap, struct ns1__mc_USCOREproject_USCOREattachment_USCOREget *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREproject_USCOREattachment_USCOREget(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREproject_USCOREattachment_USCOREgetResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREattachment_USCOREgetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREproject_USCOREattachment_USCOREgetResponse(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREattachment_USCOREgetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREproject_USCOREattachment_USCOREgetResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREproject_USCOREattachment_USCOREgetResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREgetResponse), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREattachment_USCOREgetResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREproject_USCOREattachment_USCOREgetResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREproject_USCOREattachment_USCOREgetResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREproject_USCOREattachment_USCOREgetResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREgetResponse, sizeof(struct ns1__mc_USCOREproject_USCOREattachment_USCOREgetResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREproject_USCOREattachment_USCOREgetResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "return", &a->return_, "xsd:base64Binary"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREproject_USCOREattachment_USCOREgetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREgetResponse, 0, sizeof(struct ns1__mc_USCOREproject_USCOREattachment_USCOREgetResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREproject_USCOREattachment_USCOREgetResponse(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREattachment_USCOREgetResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREproject_USCOREattachment_USCOREgetResponse);
	if (soap_out_ns1__mc_USCOREproject_USCOREattachment_USCOREgetResponse(soap, tag?tag:"ns1:mc_project_attachment_getResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREattachment_USCOREgetResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREproject_USCOREattachment_USCOREgetResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREattachment_USCOREgetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREproject_USCOREattachment_USCOREgetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfields(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfields *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
	soap_default_xsd__integer(soap, &a->project_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfields(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfields *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
	soap_serialize_xsd__integer(soap, &a->project_USCOREid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfields(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfields *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfields), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "project_id", -1, &a->project_USCOREid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfields * SOAP_FMAC4 soap_in_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfields(struct soap *soap, const char *tag, struct ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfields *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_project_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfields *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfields, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfields), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfields(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_project_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "project_id", &a->project_USCOREid, "xsd:integer"))
				{	soap_flag_project_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfields *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfields, 0, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfields), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfields(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfields *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfields);
	if (soap_out_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfields(soap, tag?tag:"ns1:mc_project_get_custom_fields", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfields * SOAP_FMAC4 soap_get_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfields(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfields *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfields(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToCustomFieldDefinitionDataArray(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse), type))
		return soap->error;
	if (soap_out_PointerToCustomFieldDefinitionDataArray(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToCustomFieldDefinitionDataArray(soap, "return", &a->return_, "ns1:CustomFieldDefinitionData"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse, 0, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse);
	if (soap_out_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse(soap, tag?tag:"ns1:mc_project_get_custom_fieldsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREproject_USCOREget_USCOREattachments(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREattachments *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
	soap_default_xsd__integer(soap, &a->project_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREproject_USCOREget_USCOREattachments(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREget_USCOREattachments *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
	soap_serialize_xsd__integer(soap, &a->project_USCOREid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREproject_USCOREget_USCOREattachments(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREproject_USCOREget_USCOREattachments *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREattachments), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "project_id", -1, &a->project_USCOREid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREattachments * SOAP_FMAC4 soap_in_ns1__mc_USCOREproject_USCOREget_USCOREattachments(struct soap *soap, const char *tag, struct ns1__mc_USCOREproject_USCOREget_USCOREattachments *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_project_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREproject_USCOREget_USCOREattachments *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREattachments, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREattachments), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREproject_USCOREget_USCOREattachments(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_project_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "project_id", &a->project_USCOREid, "xsd:integer"))
				{	soap_flag_project_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREproject_USCOREget_USCOREattachments *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREattachments, 0, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREattachments), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREproject_USCOREget_USCOREattachments(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREget_USCOREattachments *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREattachments);
	if (soap_out_ns1__mc_USCOREproject_USCOREget_USCOREattachments(soap, tag?tag:"ns1:mc_project_get_attachments", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREattachments * SOAP_FMAC4 soap_get_ns1__mc_USCOREproject_USCOREget_USCOREattachments(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREattachments *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREproject_USCOREget_USCOREattachments(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToProjectAttachmentDataArray(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse), type))
		return soap->error;
	if (soap_out_PointerToProjectAttachmentDataArray(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToProjectAttachmentDataArray(soap, "return", &a->return_, "ns1:ProjectAttachmentData"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse, 0, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse);
	if (soap_out_ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse(soap, tag?tag:"ns1:mc_project_get_attachmentsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversions(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
	soap_default_xsd__integer(soap, &a->project_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversions(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
	soap_serialize_xsd__integer(soap, &a->project_USCOREid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversions(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversions), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "project_id", -1, &a->project_USCOREid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversions * SOAP_FMAC4 soap_in_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversions(struct soap *soap, const char *tag, struct ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversions *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_project_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversions, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_project_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "project_id", &a->project_USCOREid, "xsd:integer"))
				{	soap_flag_project_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversions, 0, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversions(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversions);
	if (soap_out_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversions(soap, tag?tag:"ns1:mc_project_get_unreleased_versions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversions * SOAP_FMAC4 soap_get_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversions(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToProjectVersionDataArray(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse), type))
		return soap->error;
	if (soap_out_PointerToProjectVersionDataArray(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToProjectVersionDataArray(soap, "return", &a->return_, "ns1:ProjectVersionData"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse, 0, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse);
	if (soap_out_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse(soap, tag?tag:"ns1:mc_project_get_unreleased_versionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversions(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
	soap_default_xsd__integer(soap, &a->project_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversions(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
	soap_serialize_xsd__integer(soap, &a->project_USCOREid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversions(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversions), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "project_id", -1, &a->project_USCOREid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversions * SOAP_FMAC4 soap_in_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversions(struct soap *soap, const char *tag, struct ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversions *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_project_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversions, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_project_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "project_id", &a->project_USCOREid, "xsd:integer"))
				{	soap_flag_project_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversions, 0, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversions(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversions);
	if (soap_out_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversions(soap, tag?tag:"ns1:mc_project_get_released_versions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversions * SOAP_FMAC4 soap_get_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversions(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToProjectVersionDataArray(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse), type))
		return soap->error;
	if (soap_out_PointerToProjectVersionDataArray(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToProjectVersionDataArray(soap, "return", &a->return_, "ns1:ProjectVersionData"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse, 0, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse);
	if (soap_out_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse(soap, tag?tag:"ns1:mc_project_get_released_versionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREproject_USCOREversion_USCOREdelete(struct soap *soap, struct ns1__mc_USCOREproject_USCOREversion_USCOREdelete *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
	soap_default_xsd__integer(soap, &a->version_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREproject_USCOREversion_USCOREdelete(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREversion_USCOREdelete *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
	soap_serialize_xsd__integer(soap, &a->version_USCOREid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREproject_USCOREversion_USCOREdelete(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREproject_USCOREversion_USCOREdelete *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREdelete), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "version_id", -1, &a->version_USCOREid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREversion_USCOREdelete * SOAP_FMAC4 soap_in_ns1__mc_USCOREproject_USCOREversion_USCOREdelete(struct soap *soap, const char *tag, struct ns1__mc_USCOREproject_USCOREversion_USCOREdelete *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_version_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREproject_USCOREversion_USCOREdelete *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREdelete, sizeof(struct ns1__mc_USCOREproject_USCOREversion_USCOREdelete), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREproject_USCOREversion_USCOREdelete(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_version_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "version_id", &a->version_USCOREid, "xsd:integer"))
				{	soap_flag_version_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREproject_USCOREversion_USCOREdelete *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREdelete, 0, sizeof(struct ns1__mc_USCOREproject_USCOREversion_USCOREdelete), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREproject_USCOREversion_USCOREdelete(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREversion_USCOREdelete *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREdelete);
	if (soap_out_ns1__mc_USCOREproject_USCOREversion_USCOREdelete(soap, tag?tag:"ns1:mc_project_version_delete", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREversion_USCOREdelete * SOAP_FMAC4 soap_get_ns1__mc_USCOREproject_USCOREversion_USCOREdelete(struct soap *soap, struct ns1__mc_USCOREproject_USCOREversion_USCOREdelete *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREproject_USCOREversion_USCOREdelete(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREproject_USCOREversion_USCOREdeleteResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREversion_USCOREdeleteResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREproject_USCOREversion_USCOREdeleteResponse(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREversion_USCOREdeleteResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__boolean(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREproject_USCOREversion_USCOREdeleteResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREproject_USCOREversion_USCOREdeleteResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREdeleteResponse), type))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREversion_USCOREdeleteResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREproject_USCOREversion_USCOREdeleteResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREproject_USCOREversion_USCOREdeleteResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREproject_USCOREversion_USCOREdeleteResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREdeleteResponse, sizeof(struct ns1__mc_USCOREproject_USCOREversion_USCOREdeleteResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREproject_USCOREversion_USCOREdeleteResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "return", &a->return_, "xsd:boolean"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREproject_USCOREversion_USCOREdeleteResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREdeleteResponse, 0, sizeof(struct ns1__mc_USCOREproject_USCOREversion_USCOREdeleteResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREproject_USCOREversion_USCOREdeleteResponse(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREversion_USCOREdeleteResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREdeleteResponse);
	if (soap_out_ns1__mc_USCOREproject_USCOREversion_USCOREdeleteResponse(soap, tag?tag:"ns1:mc_project_version_deleteResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREversion_USCOREdeleteResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREproject_USCOREversion_USCOREdeleteResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREversion_USCOREdeleteResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREproject_USCOREversion_USCOREdeleteResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREproject_USCOREversion_USCOREupdate(struct soap *soap, struct ns1__mc_USCOREproject_USCOREversion_USCOREupdate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
	soap_default_xsd__integer(soap, &a->version_USCOREid);
	a->version = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREproject_USCOREversion_USCOREupdate(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREversion_USCOREupdate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
	soap_serialize_xsd__integer(soap, &a->version_USCOREid);
	soap_serialize_PointerTons1__ProjectVersionData(soap, &a->version);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREproject_USCOREversion_USCOREupdate(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREproject_USCOREversion_USCOREupdate *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREupdate), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "version_id", -1, &a->version_USCOREid, ""))
		return soap->error;
	if (soap_out_PointerTons1__ProjectVersionData(soap, "version", -1, &a->version, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREversion_USCOREupdate * SOAP_FMAC4 soap_in_ns1__mc_USCOREproject_USCOREversion_USCOREupdate(struct soap *soap, const char *tag, struct ns1__mc_USCOREproject_USCOREversion_USCOREupdate *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_version_USCOREid = 1;
	size_t soap_flag_version = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREproject_USCOREversion_USCOREupdate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREupdate, sizeof(struct ns1__mc_USCOREproject_USCOREversion_USCOREupdate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREproject_USCOREversion_USCOREupdate(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_version_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "version_id", &a->version_USCOREid, "xsd:integer"))
				{	soap_flag_version_USCOREid--;
					continue;
				}
			if (soap_flag_version && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ProjectVersionData(soap, "version", &a->version, "ns1:ProjectVersionData"))
				{	soap_flag_version--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREproject_USCOREversion_USCOREupdate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREupdate, 0, sizeof(struct ns1__mc_USCOREproject_USCOREversion_USCOREupdate), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREproject_USCOREversion_USCOREupdate(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREversion_USCOREupdate *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREupdate);
	if (soap_out_ns1__mc_USCOREproject_USCOREversion_USCOREupdate(soap, tag?tag:"ns1:mc_project_version_update", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREversion_USCOREupdate * SOAP_FMAC4 soap_get_ns1__mc_USCOREproject_USCOREversion_USCOREupdate(struct soap *soap, struct ns1__mc_USCOREproject_USCOREversion_USCOREupdate *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREproject_USCOREversion_USCOREupdate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREproject_USCOREversion_USCOREupdateResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREversion_USCOREupdateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREproject_USCOREversion_USCOREupdateResponse(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREversion_USCOREupdateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__boolean(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREproject_USCOREversion_USCOREupdateResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREproject_USCOREversion_USCOREupdateResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREupdateResponse), type))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREversion_USCOREupdateResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREproject_USCOREversion_USCOREupdateResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREproject_USCOREversion_USCOREupdateResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREproject_USCOREversion_USCOREupdateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREupdateResponse, sizeof(struct ns1__mc_USCOREproject_USCOREversion_USCOREupdateResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREproject_USCOREversion_USCOREupdateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "return", &a->return_, "xsd:boolean"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREproject_USCOREversion_USCOREupdateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREupdateResponse, 0, sizeof(struct ns1__mc_USCOREproject_USCOREversion_USCOREupdateResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREproject_USCOREversion_USCOREupdateResponse(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREversion_USCOREupdateResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREupdateResponse);
	if (soap_out_ns1__mc_USCOREproject_USCOREversion_USCOREupdateResponse(soap, tag?tag:"ns1:mc_project_version_updateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREversion_USCOREupdateResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREproject_USCOREversion_USCOREupdateResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREversion_USCOREupdateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREproject_USCOREversion_USCOREupdateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREproject_USCOREversion_USCOREadd(struct soap *soap, struct ns1__mc_USCOREproject_USCOREversion_USCOREadd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
	a->version = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREproject_USCOREversion_USCOREadd(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREversion_USCOREadd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
	soap_serialize_PointerTons1__ProjectVersionData(soap, &a->version);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREproject_USCOREversion_USCOREadd(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREproject_USCOREversion_USCOREadd *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREadd), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_PointerTons1__ProjectVersionData(soap, "version", -1, &a->version, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREversion_USCOREadd * SOAP_FMAC4 soap_in_ns1__mc_USCOREproject_USCOREversion_USCOREadd(struct soap *soap, const char *tag, struct ns1__mc_USCOREproject_USCOREversion_USCOREadd *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_version = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREproject_USCOREversion_USCOREadd *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREadd, sizeof(struct ns1__mc_USCOREproject_USCOREversion_USCOREadd), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREproject_USCOREversion_USCOREadd(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_version && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ProjectVersionData(soap, "version", &a->version, "ns1:ProjectVersionData"))
				{	soap_flag_version--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREproject_USCOREversion_USCOREadd *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREadd, 0, sizeof(struct ns1__mc_USCOREproject_USCOREversion_USCOREadd), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREproject_USCOREversion_USCOREadd(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREversion_USCOREadd *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREadd);
	if (soap_out_ns1__mc_USCOREproject_USCOREversion_USCOREadd(soap, tag?tag:"ns1:mc_project_version_add", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREversion_USCOREadd * SOAP_FMAC4 soap_get_ns1__mc_USCOREproject_USCOREversion_USCOREadd(struct soap *soap, struct ns1__mc_USCOREproject_USCOREversion_USCOREadd *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREproject_USCOREversion_USCOREadd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREproject_USCOREversion_USCOREaddResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREversion_USCOREaddResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREproject_USCOREversion_USCOREaddResponse(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREversion_USCOREaddResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__integer(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREproject_USCOREversion_USCOREaddResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREproject_USCOREversion_USCOREaddResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREaddResponse), type))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREversion_USCOREaddResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREproject_USCOREversion_USCOREaddResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREproject_USCOREversion_USCOREaddResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREproject_USCOREversion_USCOREaddResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREaddResponse, sizeof(struct ns1__mc_USCOREproject_USCOREversion_USCOREaddResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREproject_USCOREversion_USCOREaddResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "return", &a->return_, "xsd:integer"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREproject_USCOREversion_USCOREaddResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREaddResponse, 0, sizeof(struct ns1__mc_USCOREproject_USCOREversion_USCOREaddResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREproject_USCOREversion_USCOREaddResponse(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREversion_USCOREaddResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREproject_USCOREversion_USCOREaddResponse);
	if (soap_out_ns1__mc_USCOREproject_USCOREversion_USCOREaddResponse(soap, tag?tag:"ns1:mc_project_version_addResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREversion_USCOREaddResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREproject_USCOREversion_USCOREaddResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREversion_USCOREaddResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREproject_USCOREversion_USCOREaddResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREproject_USCOREget_USCOREversions(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREversions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
	soap_default_xsd__integer(soap, &a->project_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREproject_USCOREget_USCOREversions(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREget_USCOREversions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
	soap_serialize_xsd__integer(soap, &a->project_USCOREid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREproject_USCOREget_USCOREversions(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREproject_USCOREget_USCOREversions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREversions), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "project_id", -1, &a->project_USCOREid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREversions * SOAP_FMAC4 soap_in_ns1__mc_USCOREproject_USCOREget_USCOREversions(struct soap *soap, const char *tag, struct ns1__mc_USCOREproject_USCOREget_USCOREversions *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_project_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREproject_USCOREget_USCOREversions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREversions, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREversions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREproject_USCOREget_USCOREversions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_project_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "project_id", &a->project_USCOREid, "xsd:integer"))
				{	soap_flag_project_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREproject_USCOREget_USCOREversions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREversions, 0, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREversions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREproject_USCOREget_USCOREversions(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREget_USCOREversions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREversions);
	if (soap_out_ns1__mc_USCOREproject_USCOREget_USCOREversions(soap, tag?tag:"ns1:mc_project_get_versions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREversions * SOAP_FMAC4 soap_get_ns1__mc_USCOREproject_USCOREget_USCOREversions(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREversions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREproject_USCOREget_USCOREversions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToProjectVersionDataArray(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse), type))
		return soap->error;
	if (soap_out_PointerToProjectVersionDataArray(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToProjectVersionDataArray(soap, "return", &a->return_, "ns1:ProjectVersionData"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse, 0, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse);
	if (soap_out_ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse(soap, tag?tag:"ns1:mc_project_get_versionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREproject_USCOREget_USCOREcategories(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREcategories *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
	soap_default_xsd__integer(soap, &a->project_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREproject_USCOREget_USCOREcategories(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREget_USCOREcategories *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
	soap_serialize_xsd__integer(soap, &a->project_USCOREid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREproject_USCOREget_USCOREcategories(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREproject_USCOREget_USCOREcategories *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREcategories), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "project_id", -1, &a->project_USCOREid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREcategories * SOAP_FMAC4 soap_in_ns1__mc_USCOREproject_USCOREget_USCOREcategories(struct soap *soap, const char *tag, struct ns1__mc_USCOREproject_USCOREget_USCOREcategories *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_project_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREproject_USCOREget_USCOREcategories *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREcategories, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREcategories), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREproject_USCOREget_USCOREcategories(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_project_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "project_id", &a->project_USCOREid, "xsd:integer"))
				{	soap_flag_project_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREproject_USCOREget_USCOREcategories *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREcategories, 0, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREcategories), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREproject_USCOREget_USCOREcategories(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREget_USCOREcategories *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREcategories);
	if (soap_out_ns1__mc_USCOREproject_USCOREget_USCOREcategories(soap, tag?tag:"ns1:mc_project_get_categories", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREcategories * SOAP_FMAC4 soap_get_ns1__mc_USCOREproject_USCOREget_USCOREcategories(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREcategories *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREproject_USCOREget_USCOREcategories(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToStringArray(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse), type))
		return soap->error;
	if (soap_out_PointerToStringArray(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToStringArray(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse, 0, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse);
	if (soap_out_ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse(soap, tag?tag:"ns1:mc_project_get_categoriesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessible(struct soap *soap, struct ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessible *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessible(struct soap *soap, const struct ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessible *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessible(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessible *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessible), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessible * SOAP_FMAC4 soap_in_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessible(struct soap *soap, const char *tag, struct ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessible *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessible *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessible, sizeof(struct ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessible), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessible(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessible *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessible, 0, sizeof(struct ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessible), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessible(struct soap *soap, const struct ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessible *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessible);
	if (soap_out_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessible(soap, tag?tag:"ns1:mc_projects_get_user_accessible", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessible * SOAP_FMAC4 soap_get_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessible(struct soap *soap, struct ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessible *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessible(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse(struct soap *soap, struct ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse(struct soap *soap, const struct ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToProjectDataArray(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse), type))
		return soap->error;
	if (soap_out_PointerToProjectDataArray(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse, sizeof(struct ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToProjectDataArray(soap, "return", &a->return_, "ns1:ProjectData"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse, 0, sizeof(struct ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse(struct soap *soap, const struct ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse);
	if (soap_out_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse(soap, tag?tag:"ns1:mc_projects_get_user_accessibleResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse(struct soap *soap, struct ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREproject_USCOREget_USCOREusers(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREusers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
	soap_default_xsd__integer(soap, &a->project_USCOREid);
	soap_default_xsd__integer(soap, &a->access);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREproject_USCOREget_USCOREusers(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREget_USCOREusers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
	soap_serialize_xsd__integer(soap, &a->project_USCOREid);
	soap_serialize_xsd__integer(soap, &a->access);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREproject_USCOREget_USCOREusers(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREproject_USCOREget_USCOREusers *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREusers), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "project_id", -1, &a->project_USCOREid, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "access", -1, &a->access, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREusers * SOAP_FMAC4 soap_in_ns1__mc_USCOREproject_USCOREget_USCOREusers(struct soap *soap, const char *tag, struct ns1__mc_USCOREproject_USCOREget_USCOREusers *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_project_USCOREid = 1;
	size_t soap_flag_access = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREproject_USCOREget_USCOREusers *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREusers, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREusers), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREproject_USCOREget_USCOREusers(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_project_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "project_id", &a->project_USCOREid, "xsd:integer"))
				{	soap_flag_project_USCOREid--;
					continue;
				}
			if (soap_flag_access && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "access", &a->access, "xsd:integer"))
				{	soap_flag_access--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREproject_USCOREget_USCOREusers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREusers, 0, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREusers), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREproject_USCOREget_USCOREusers(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREget_USCOREusers *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREusers);
	if (soap_out_ns1__mc_USCOREproject_USCOREget_USCOREusers(soap, tag?tag:"ns1:mc_project_get_users", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREusers * SOAP_FMAC4 soap_get_ns1__mc_USCOREproject_USCOREget_USCOREusers(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREusers *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREproject_USCOREget_USCOREusers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREproject_USCOREget_USCOREusersResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREusersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREproject_USCOREget_USCOREusersResponse(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREget_USCOREusersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToAccountDataArray(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREproject_USCOREget_USCOREusersResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREproject_USCOREget_USCOREusersResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREusersResponse), type))
		return soap->error;
	if (soap_out_PointerToAccountDataArray(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREusersResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREproject_USCOREget_USCOREusersResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREproject_USCOREget_USCOREusersResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREproject_USCOREget_USCOREusersResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREusersResponse, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREusersResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREproject_USCOREget_USCOREusersResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToAccountDataArray(soap, "return", &a->return_, "ns1:AccountData"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREproject_USCOREget_USCOREusersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREusersResponse, 0, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREusersResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREproject_USCOREget_USCOREusersResponse(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREget_USCOREusersResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREusersResponse);
	if (soap_out_ns1__mc_USCOREproject_USCOREget_USCOREusersResponse(soap, tag?tag:"ns1:mc_project_get_usersResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREusersResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREproject_USCOREget_USCOREusersResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREusersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREproject_USCOREget_USCOREusersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheaders(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheaders *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
	soap_default_xsd__integer(soap, &a->project_USCOREid);
	soap_default_xsd__integer(soap, &a->page_USCOREnumber);
	soap_default_xsd__integer(soap, &a->per_USCOREpage);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheaders(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheaders *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
	soap_serialize_xsd__integer(soap, &a->project_USCOREid);
	soap_serialize_xsd__integer(soap, &a->page_USCOREnumber);
	soap_serialize_xsd__integer(soap, &a->per_USCOREpage);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheaders(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheaders *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheaders), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "project_id", -1, &a->project_USCOREid, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "page_number", -1, &a->page_USCOREnumber, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "per_page", -1, &a->per_USCOREpage, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheaders * SOAP_FMAC4 soap_in_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheaders(struct soap *soap, const char *tag, struct ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheaders *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_project_USCOREid = 1;
	size_t soap_flag_page_USCOREnumber = 1;
	size_t soap_flag_per_USCOREpage = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheaders *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheaders, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheaders), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheaders(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_project_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "project_id", &a->project_USCOREid, "xsd:integer"))
				{	soap_flag_project_USCOREid--;
					continue;
				}
			if (soap_flag_page_USCOREnumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "page_number", &a->page_USCOREnumber, "xsd:integer"))
				{	soap_flag_page_USCOREnumber--;
					continue;
				}
			if (soap_flag_per_USCOREpage && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "per_page", &a->per_USCOREpage, "xsd:integer"))
				{	soap_flag_per_USCOREpage--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheaders *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheaders, 0, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheaders), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheaders(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheaders *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheaders);
	if (soap_out_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheaders(soap, tag?tag:"ns1:mc_project_get_issue_headers", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheaders * SOAP_FMAC4 soap_get_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheaders(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheaders *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheaders(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToIssueHeaderDataArray(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse), type))
		return soap->error;
	if (soap_out_PointerToIssueHeaderDataArray(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToIssueHeaderDataArray(soap, "return", &a->return_, "ns1:IssueHeaderData"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse, 0, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse);
	if (soap_out_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse(soap, tag?tag:"ns1:mc_project_get_issue_headersResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREproject_USCOREget_USCOREissues(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREissues *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
	soap_default_xsd__integer(soap, &a->project_USCOREid);
	soap_default_xsd__integer(soap, &a->page_USCOREnumber);
	soap_default_xsd__integer(soap, &a->per_USCOREpage);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREproject_USCOREget_USCOREissues(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREget_USCOREissues *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
	soap_serialize_xsd__integer(soap, &a->project_USCOREid);
	soap_serialize_xsd__integer(soap, &a->page_USCOREnumber);
	soap_serialize_xsd__integer(soap, &a->per_USCOREpage);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREproject_USCOREget_USCOREissues(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREproject_USCOREget_USCOREissues *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREissues), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "project_id", -1, &a->project_USCOREid, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "page_number", -1, &a->page_USCOREnumber, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "per_page", -1, &a->per_USCOREpage, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREissues * SOAP_FMAC4 soap_in_ns1__mc_USCOREproject_USCOREget_USCOREissues(struct soap *soap, const char *tag, struct ns1__mc_USCOREproject_USCOREget_USCOREissues *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_project_USCOREid = 1;
	size_t soap_flag_page_USCOREnumber = 1;
	size_t soap_flag_per_USCOREpage = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREproject_USCOREget_USCOREissues *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREissues, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREissues), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREproject_USCOREget_USCOREissues(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_project_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "project_id", &a->project_USCOREid, "xsd:integer"))
				{	soap_flag_project_USCOREid--;
					continue;
				}
			if (soap_flag_page_USCOREnumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "page_number", &a->page_USCOREnumber, "xsd:integer"))
				{	soap_flag_page_USCOREnumber--;
					continue;
				}
			if (soap_flag_per_USCOREpage && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "per_page", &a->per_USCOREpage, "xsd:integer"))
				{	soap_flag_per_USCOREpage--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREproject_USCOREget_USCOREissues *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREissues, 0, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREissues), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREproject_USCOREget_USCOREissues(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREget_USCOREissues *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREissues);
	if (soap_out_ns1__mc_USCOREproject_USCOREget_USCOREissues(soap, tag?tag:"ns1:mc_project_get_issues", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREissues * SOAP_FMAC4 soap_get_ns1__mc_USCOREproject_USCOREget_USCOREissues(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREissues *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREproject_USCOREget_USCOREissues(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToIssueDataArray(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse), type))
		return soap->error;
	if (soap_out_PointerToIssueDataArray(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToIssueDataArray(soap, "return", &a->return_, "ns1:IssueData"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse, 0, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse);
	if (soap_out_ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse(soap, tag?tag:"ns1:mc_project_get_issuesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREproject_USCOREdelete(struct soap *soap, struct ns1__mc_USCOREproject_USCOREdelete *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
	soap_default_xsd__integer(soap, &a->project_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREproject_USCOREdelete(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREdelete *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
	soap_serialize_xsd__integer(soap, &a->project_USCOREid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREproject_USCOREdelete(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREproject_USCOREdelete *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREdelete), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "project_id", -1, &a->project_USCOREid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREdelete * SOAP_FMAC4 soap_in_ns1__mc_USCOREproject_USCOREdelete(struct soap *soap, const char *tag, struct ns1__mc_USCOREproject_USCOREdelete *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_project_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREproject_USCOREdelete *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREdelete, sizeof(struct ns1__mc_USCOREproject_USCOREdelete), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREproject_USCOREdelete(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_project_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "project_id", &a->project_USCOREid, "xsd:integer"))
				{	soap_flag_project_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREproject_USCOREdelete *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREproject_USCOREdelete, 0, sizeof(struct ns1__mc_USCOREproject_USCOREdelete), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREproject_USCOREdelete(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREdelete *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREproject_USCOREdelete);
	if (soap_out_ns1__mc_USCOREproject_USCOREdelete(soap, tag?tag:"ns1:mc_project_delete", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREdelete * SOAP_FMAC4 soap_get_ns1__mc_USCOREproject_USCOREdelete(struct soap *soap, struct ns1__mc_USCOREproject_USCOREdelete *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREproject_USCOREdelete(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREproject_USCOREdeleteResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREdeleteResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREproject_USCOREdeleteResponse(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREdeleteResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__boolean(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREproject_USCOREdeleteResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREproject_USCOREdeleteResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREdeleteResponse), type))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREdeleteResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREproject_USCOREdeleteResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREproject_USCOREdeleteResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREproject_USCOREdeleteResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREdeleteResponse, sizeof(struct ns1__mc_USCOREproject_USCOREdeleteResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREproject_USCOREdeleteResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "return", &a->return_, "xsd:boolean"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREproject_USCOREdeleteResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREproject_USCOREdeleteResponse, 0, sizeof(struct ns1__mc_USCOREproject_USCOREdeleteResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREproject_USCOREdeleteResponse(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREdeleteResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREproject_USCOREdeleteResponse);
	if (soap_out_ns1__mc_USCOREproject_USCOREdeleteResponse(soap, tag?tag:"ns1:mc_project_deleteResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREdeleteResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREproject_USCOREdeleteResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREdeleteResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREproject_USCOREdeleteResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREproject_USCOREadd(struct soap *soap, struct ns1__mc_USCOREproject_USCOREadd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
	a->project = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREproject_USCOREadd(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREadd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
	soap_serialize_PointerTons1__ProjectData(soap, &a->project);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREproject_USCOREadd(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREproject_USCOREadd *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREadd), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_PointerTons1__ProjectData(soap, "project", -1, &a->project, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREadd * SOAP_FMAC4 soap_in_ns1__mc_USCOREproject_USCOREadd(struct soap *soap, const char *tag, struct ns1__mc_USCOREproject_USCOREadd *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_project = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREproject_USCOREadd *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREadd, sizeof(struct ns1__mc_USCOREproject_USCOREadd), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREproject_USCOREadd(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_project && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ProjectData(soap, "project", &a->project, "ns1:ProjectData"))
				{	soap_flag_project--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREproject_USCOREadd *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREproject_USCOREadd, 0, sizeof(struct ns1__mc_USCOREproject_USCOREadd), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREproject_USCOREadd(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREadd *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREproject_USCOREadd);
	if (soap_out_ns1__mc_USCOREproject_USCOREadd(soap, tag?tag:"ns1:mc_project_add", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREadd * SOAP_FMAC4 soap_get_ns1__mc_USCOREproject_USCOREadd(struct soap *soap, struct ns1__mc_USCOREproject_USCOREadd *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREproject_USCOREadd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREproject_USCOREaddResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREaddResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREproject_USCOREaddResponse(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREaddResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__integer(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREproject_USCOREaddResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREproject_USCOREaddResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREaddResponse), type))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREaddResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREproject_USCOREaddResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREproject_USCOREaddResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREproject_USCOREaddResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREaddResponse, sizeof(struct ns1__mc_USCOREproject_USCOREaddResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREproject_USCOREaddResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "return", &a->return_, "xsd:integer"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREproject_USCOREaddResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREproject_USCOREaddResponse, 0, sizeof(struct ns1__mc_USCOREproject_USCOREaddResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREproject_USCOREaddResponse(struct soap *soap, const struct ns1__mc_USCOREproject_USCOREaddResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREproject_USCOREaddResponse);
	if (soap_out_ns1__mc_USCOREproject_USCOREaddResponse(soap, tag?tag:"ns1:mc_project_addResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREaddResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREproject_USCOREaddResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREaddResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREproject_USCOREaddResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREissue_USCOREattachment_USCOREget(struct soap *soap, struct ns1__mc_USCOREissue_USCOREattachment_USCOREget *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
	soap_default_xsd__integer(soap, &a->issue_USCOREattachment_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREissue_USCOREattachment_USCOREget(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREattachment_USCOREget *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
	soap_serialize_xsd__integer(soap, &a->issue_USCOREattachment_USCOREid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREissue_USCOREattachment_USCOREget(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREissue_USCOREattachment_USCOREget *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREget), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "issue_attachment_id", -1, &a->issue_USCOREattachment_USCOREid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREattachment_USCOREget * SOAP_FMAC4 soap_in_ns1__mc_USCOREissue_USCOREattachment_USCOREget(struct soap *soap, const char *tag, struct ns1__mc_USCOREissue_USCOREattachment_USCOREget *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_issue_USCOREattachment_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREissue_USCOREattachment_USCOREget *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREget, sizeof(struct ns1__mc_USCOREissue_USCOREattachment_USCOREget), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREissue_USCOREattachment_USCOREget(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_issue_USCOREattachment_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "issue_attachment_id", &a->issue_USCOREattachment_USCOREid, "xsd:integer"))
				{	soap_flag_issue_USCOREattachment_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREissue_USCOREattachment_USCOREget *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREget, 0, sizeof(struct ns1__mc_USCOREissue_USCOREattachment_USCOREget), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREissue_USCOREattachment_USCOREget(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREattachment_USCOREget *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREget);
	if (soap_out_ns1__mc_USCOREissue_USCOREattachment_USCOREget(soap, tag?tag:"ns1:mc_issue_attachment_get", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREattachment_USCOREget * SOAP_FMAC4 soap_get_ns1__mc_USCOREissue_USCOREattachment_USCOREget(struct soap *soap, struct ns1__mc_USCOREissue_USCOREattachment_USCOREget *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREissue_USCOREattachment_USCOREget(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREissue_USCOREattachment_USCOREgetResponse(struct soap *soap, struct ns1__mc_USCOREissue_USCOREattachment_USCOREgetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREissue_USCOREattachment_USCOREgetResponse(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREattachment_USCOREgetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREissue_USCOREattachment_USCOREgetResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREissue_USCOREattachment_USCOREgetResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREgetResponse), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREattachment_USCOREgetResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREissue_USCOREattachment_USCOREgetResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREissue_USCOREattachment_USCOREgetResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREissue_USCOREattachment_USCOREgetResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREgetResponse, sizeof(struct ns1__mc_USCOREissue_USCOREattachment_USCOREgetResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREissue_USCOREattachment_USCOREgetResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "return", &a->return_, "xsd:base64Binary"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREissue_USCOREattachment_USCOREgetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREgetResponse, 0, sizeof(struct ns1__mc_USCOREissue_USCOREattachment_USCOREgetResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREissue_USCOREattachment_USCOREgetResponse(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREattachment_USCOREgetResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREgetResponse);
	if (soap_out_ns1__mc_USCOREissue_USCOREattachment_USCOREgetResponse(soap, tag?tag:"ns1:mc_issue_attachment_getResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREattachment_USCOREgetResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREissue_USCOREattachment_USCOREgetResponse(struct soap *soap, struct ns1__mc_USCOREissue_USCOREattachment_USCOREgetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREissue_USCOREattachment_USCOREgetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREissue_USCOREattachment_USCOREdelete(struct soap *soap, struct ns1__mc_USCOREissue_USCOREattachment_USCOREdelete *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
	soap_default_xsd__integer(soap, &a->issue_USCOREattachment_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREissue_USCOREattachment_USCOREdelete(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREattachment_USCOREdelete *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
	soap_serialize_xsd__integer(soap, &a->issue_USCOREattachment_USCOREid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREissue_USCOREattachment_USCOREdelete(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREissue_USCOREattachment_USCOREdelete *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREdelete), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "issue_attachment_id", -1, &a->issue_USCOREattachment_USCOREid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREattachment_USCOREdelete * SOAP_FMAC4 soap_in_ns1__mc_USCOREissue_USCOREattachment_USCOREdelete(struct soap *soap, const char *tag, struct ns1__mc_USCOREissue_USCOREattachment_USCOREdelete *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_issue_USCOREattachment_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREissue_USCOREattachment_USCOREdelete *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREdelete, sizeof(struct ns1__mc_USCOREissue_USCOREattachment_USCOREdelete), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREissue_USCOREattachment_USCOREdelete(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_issue_USCOREattachment_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "issue_attachment_id", &a->issue_USCOREattachment_USCOREid, "xsd:integer"))
				{	soap_flag_issue_USCOREattachment_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREissue_USCOREattachment_USCOREdelete *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREdelete, 0, sizeof(struct ns1__mc_USCOREissue_USCOREattachment_USCOREdelete), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREissue_USCOREattachment_USCOREdelete(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREattachment_USCOREdelete *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREdelete);
	if (soap_out_ns1__mc_USCOREissue_USCOREattachment_USCOREdelete(soap, tag?tag:"ns1:mc_issue_attachment_delete", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREattachment_USCOREdelete * SOAP_FMAC4 soap_get_ns1__mc_USCOREissue_USCOREattachment_USCOREdelete(struct soap *soap, struct ns1__mc_USCOREissue_USCOREattachment_USCOREdelete *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREissue_USCOREattachment_USCOREdelete(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREissue_USCOREattachment_USCOREdeleteResponse(struct soap *soap, struct ns1__mc_USCOREissue_USCOREattachment_USCOREdeleteResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREissue_USCOREattachment_USCOREdeleteResponse(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREattachment_USCOREdeleteResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__boolean(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREissue_USCOREattachment_USCOREdeleteResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREissue_USCOREattachment_USCOREdeleteResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREdeleteResponse), type))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREattachment_USCOREdeleteResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREissue_USCOREattachment_USCOREdeleteResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREissue_USCOREattachment_USCOREdeleteResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREissue_USCOREattachment_USCOREdeleteResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREdeleteResponse, sizeof(struct ns1__mc_USCOREissue_USCOREattachment_USCOREdeleteResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREissue_USCOREattachment_USCOREdeleteResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "return", &a->return_, "xsd:boolean"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREissue_USCOREattachment_USCOREdeleteResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREdeleteResponse, 0, sizeof(struct ns1__mc_USCOREissue_USCOREattachment_USCOREdeleteResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREissue_USCOREattachment_USCOREdeleteResponse(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREattachment_USCOREdeleteResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREdeleteResponse);
	if (soap_out_ns1__mc_USCOREissue_USCOREattachment_USCOREdeleteResponse(soap, tag?tag:"ns1:mc_issue_attachment_deleteResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREattachment_USCOREdeleteResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREissue_USCOREattachment_USCOREdeleteResponse(struct soap *soap, struct ns1__mc_USCOREissue_USCOREattachment_USCOREdeleteResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREissue_USCOREattachment_USCOREdeleteResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREissue_USCOREattachment_USCOREadd(struct soap *soap, struct ns1__mc_USCOREissue_USCOREattachment_USCOREadd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
	soap_default_xsd__integer(soap, &a->issue_USCOREid);
	soap_default_string(soap, &a->name);
	soap_default_string(soap, &a->file_USCOREtype);
	soap_default_xsd__base64Binary(soap, &a->content);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREissue_USCOREattachment_USCOREadd(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREattachment_USCOREadd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
	soap_serialize_xsd__integer(soap, &a->issue_USCOREid);
	soap_serialize_string(soap, &a->name);
	soap_serialize_string(soap, &a->file_USCOREtype);
	soap_embedded(soap, &a->content, SOAP_TYPE_xsd__base64Binary);
	soap_serialize_xsd__base64Binary(soap, &a->content);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREissue_USCOREattachment_USCOREadd(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREissue_USCOREattachment_USCOREadd *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREadd), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "issue_id", -1, &a->issue_USCOREid, ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->name, ""))
		return soap->error;
	if (soap_out_string(soap, "file_type", -1, &a->file_USCOREtype, ""))
		return soap->error;
	if (soap_out_xsd__base64Binary(soap, "content", -1, &a->content, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREattachment_USCOREadd * SOAP_FMAC4 soap_in_ns1__mc_USCOREissue_USCOREattachment_USCOREadd(struct soap *soap, const char *tag, struct ns1__mc_USCOREissue_USCOREattachment_USCOREadd *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_issue_USCOREid = 1;
	size_t soap_flag_name = 1;
	size_t soap_flag_file_USCOREtype = 1;
	size_t soap_flag_content = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREissue_USCOREattachment_USCOREadd *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREadd, sizeof(struct ns1__mc_USCOREissue_USCOREattachment_USCOREadd), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREissue_USCOREattachment_USCOREadd(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_issue_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "issue_id", &a->issue_USCOREid, "xsd:integer"))
				{	soap_flag_issue_USCOREid--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_file_USCOREtype && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "file_type", &a->file_USCOREtype, "xsd:string"))
				{	soap_flag_file_USCOREtype--;
					continue;
				}
			if (soap_flag_content && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__base64Binary(soap, "content", &a->content, "xsd:base64Binary"))
				{	soap_flag_content--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREissue_USCOREattachment_USCOREadd *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREadd, 0, sizeof(struct ns1__mc_USCOREissue_USCOREattachment_USCOREadd), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_content > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREissue_USCOREattachment_USCOREadd(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREattachment_USCOREadd *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREadd);
	if (soap_out_ns1__mc_USCOREissue_USCOREattachment_USCOREadd(soap, tag?tag:"ns1:mc_issue_attachment_add", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREattachment_USCOREadd * SOAP_FMAC4 soap_get_ns1__mc_USCOREissue_USCOREattachment_USCOREadd(struct soap *soap, struct ns1__mc_USCOREissue_USCOREattachment_USCOREadd *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREissue_USCOREattachment_USCOREadd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREissue_USCOREattachment_USCOREaddResponse(struct soap *soap, struct ns1__mc_USCOREissue_USCOREattachment_USCOREaddResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREissue_USCOREattachment_USCOREaddResponse(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREattachment_USCOREaddResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__integer(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREissue_USCOREattachment_USCOREaddResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREissue_USCOREattachment_USCOREaddResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREaddResponse), type))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREattachment_USCOREaddResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREissue_USCOREattachment_USCOREaddResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREissue_USCOREattachment_USCOREaddResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREissue_USCOREattachment_USCOREaddResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREaddResponse, sizeof(struct ns1__mc_USCOREissue_USCOREattachment_USCOREaddResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREissue_USCOREattachment_USCOREaddResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "return", &a->return_, "xsd:integer"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREissue_USCOREattachment_USCOREaddResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREaddResponse, 0, sizeof(struct ns1__mc_USCOREissue_USCOREattachment_USCOREaddResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREissue_USCOREattachment_USCOREaddResponse(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREattachment_USCOREaddResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREissue_USCOREattachment_USCOREaddResponse);
	if (soap_out_ns1__mc_USCOREissue_USCOREattachment_USCOREaddResponse(soap, tag?tag:"ns1:mc_issue_attachment_addResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREattachment_USCOREaddResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREissue_USCOREattachment_USCOREaddResponse(struct soap *soap, struct ns1__mc_USCOREissue_USCOREattachment_USCOREaddResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREissue_USCOREattachment_USCOREaddResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREissue_USCORErelationship_USCOREdelete(struct soap *soap, struct ns1__mc_USCOREissue_USCORErelationship_USCOREdelete *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
	soap_default_xsd__integer(soap, &a->issue_USCOREid);
	soap_default_xsd__integer(soap, &a->relationship_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREissue_USCORErelationship_USCOREdelete(struct soap *soap, const struct ns1__mc_USCOREissue_USCORErelationship_USCOREdelete *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
	soap_serialize_xsd__integer(soap, &a->issue_USCOREid);
	soap_serialize_xsd__integer(soap, &a->relationship_USCOREid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREissue_USCORErelationship_USCOREdelete(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREissue_USCORErelationship_USCOREdelete *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCORErelationship_USCOREdelete), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "issue_id", -1, &a->issue_USCOREid, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "relationship_id", -1, &a->relationship_USCOREid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCORErelationship_USCOREdelete * SOAP_FMAC4 soap_in_ns1__mc_USCOREissue_USCORErelationship_USCOREdelete(struct soap *soap, const char *tag, struct ns1__mc_USCOREissue_USCORErelationship_USCOREdelete *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_issue_USCOREid = 1;
	size_t soap_flag_relationship_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREissue_USCORErelationship_USCOREdelete *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCORErelationship_USCOREdelete, sizeof(struct ns1__mc_USCOREissue_USCORErelationship_USCOREdelete), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREissue_USCORErelationship_USCOREdelete(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_issue_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "issue_id", &a->issue_USCOREid, "xsd:integer"))
				{	soap_flag_issue_USCOREid--;
					continue;
				}
			if (soap_flag_relationship_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "relationship_id", &a->relationship_USCOREid, "xsd:integer"))
				{	soap_flag_relationship_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREissue_USCORErelationship_USCOREdelete *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREissue_USCORErelationship_USCOREdelete, 0, sizeof(struct ns1__mc_USCOREissue_USCORErelationship_USCOREdelete), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREissue_USCORErelationship_USCOREdelete(struct soap *soap, const struct ns1__mc_USCOREissue_USCORErelationship_USCOREdelete *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREissue_USCORErelationship_USCOREdelete);
	if (soap_out_ns1__mc_USCOREissue_USCORErelationship_USCOREdelete(soap, tag?tag:"ns1:mc_issue_relationship_delete", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCORErelationship_USCOREdelete * SOAP_FMAC4 soap_get_ns1__mc_USCOREissue_USCORErelationship_USCOREdelete(struct soap *soap, struct ns1__mc_USCOREissue_USCORErelationship_USCOREdelete *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREissue_USCORErelationship_USCOREdelete(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREissue_USCORErelationship_USCOREdeleteResponse(struct soap *soap, struct ns1__mc_USCOREissue_USCORErelationship_USCOREdeleteResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREissue_USCORErelationship_USCOREdeleteResponse(struct soap *soap, const struct ns1__mc_USCOREissue_USCORErelationship_USCOREdeleteResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__boolean(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREissue_USCORErelationship_USCOREdeleteResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREissue_USCORErelationship_USCOREdeleteResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCORErelationship_USCOREdeleteResponse), type))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCORErelationship_USCOREdeleteResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREissue_USCORErelationship_USCOREdeleteResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREissue_USCORErelationship_USCOREdeleteResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREissue_USCORErelationship_USCOREdeleteResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCORErelationship_USCOREdeleteResponse, sizeof(struct ns1__mc_USCOREissue_USCORErelationship_USCOREdeleteResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREissue_USCORErelationship_USCOREdeleteResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "return", &a->return_, "xsd:boolean"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREissue_USCORErelationship_USCOREdeleteResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREissue_USCORErelationship_USCOREdeleteResponse, 0, sizeof(struct ns1__mc_USCOREissue_USCORErelationship_USCOREdeleteResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREissue_USCORErelationship_USCOREdeleteResponse(struct soap *soap, const struct ns1__mc_USCOREissue_USCORErelationship_USCOREdeleteResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREissue_USCORErelationship_USCOREdeleteResponse);
	if (soap_out_ns1__mc_USCOREissue_USCORErelationship_USCOREdeleteResponse(soap, tag?tag:"ns1:mc_issue_relationship_deleteResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCORErelationship_USCOREdeleteResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREissue_USCORErelationship_USCOREdeleteResponse(struct soap *soap, struct ns1__mc_USCOREissue_USCORErelationship_USCOREdeleteResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREissue_USCORErelationship_USCOREdeleteResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREissue_USCORErelationship_USCOREadd(struct soap *soap, struct ns1__mc_USCOREissue_USCORErelationship_USCOREadd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
	soap_default_xsd__integer(soap, &a->issue_USCOREid);
	a->relationship = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREissue_USCORErelationship_USCOREadd(struct soap *soap, const struct ns1__mc_USCOREissue_USCORErelationship_USCOREadd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
	soap_serialize_xsd__integer(soap, &a->issue_USCOREid);
	soap_serialize_PointerTons1__RelationshipData(soap, &a->relationship);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREissue_USCORErelationship_USCOREadd(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREissue_USCORErelationship_USCOREadd *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCORErelationship_USCOREadd), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "issue_id", -1, &a->issue_USCOREid, ""))
		return soap->error;
	if (soap_out_PointerTons1__RelationshipData(soap, "relationship", -1, &a->relationship, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCORErelationship_USCOREadd * SOAP_FMAC4 soap_in_ns1__mc_USCOREissue_USCORErelationship_USCOREadd(struct soap *soap, const char *tag, struct ns1__mc_USCOREissue_USCORErelationship_USCOREadd *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_issue_USCOREid = 1;
	size_t soap_flag_relationship = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREissue_USCORErelationship_USCOREadd *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCORErelationship_USCOREadd, sizeof(struct ns1__mc_USCOREissue_USCORErelationship_USCOREadd), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREissue_USCORErelationship_USCOREadd(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_issue_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "issue_id", &a->issue_USCOREid, "xsd:integer"))
				{	soap_flag_issue_USCOREid--;
					continue;
				}
			if (soap_flag_relationship && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RelationshipData(soap, "relationship", &a->relationship, "ns1:RelationshipData"))
				{	soap_flag_relationship--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREissue_USCORErelationship_USCOREadd *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREissue_USCORErelationship_USCOREadd, 0, sizeof(struct ns1__mc_USCOREissue_USCORErelationship_USCOREadd), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREissue_USCORErelationship_USCOREadd(struct soap *soap, const struct ns1__mc_USCOREissue_USCORErelationship_USCOREadd *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREissue_USCORErelationship_USCOREadd);
	if (soap_out_ns1__mc_USCOREissue_USCORErelationship_USCOREadd(soap, tag?tag:"ns1:mc_issue_relationship_add", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCORErelationship_USCOREadd * SOAP_FMAC4 soap_get_ns1__mc_USCOREissue_USCORErelationship_USCOREadd(struct soap *soap, struct ns1__mc_USCOREissue_USCORErelationship_USCOREadd *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREissue_USCORErelationship_USCOREadd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREissue_USCORErelationship_USCOREaddResponse(struct soap *soap, struct ns1__mc_USCOREissue_USCORErelationship_USCOREaddResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREissue_USCORErelationship_USCOREaddResponse(struct soap *soap, const struct ns1__mc_USCOREissue_USCORErelationship_USCOREaddResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__integer(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREissue_USCORErelationship_USCOREaddResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREissue_USCORErelationship_USCOREaddResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCORErelationship_USCOREaddResponse), type))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCORErelationship_USCOREaddResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREissue_USCORErelationship_USCOREaddResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREissue_USCORErelationship_USCOREaddResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREissue_USCORErelationship_USCOREaddResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCORErelationship_USCOREaddResponse, sizeof(struct ns1__mc_USCOREissue_USCORErelationship_USCOREaddResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREissue_USCORErelationship_USCOREaddResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "return", &a->return_, "xsd:integer"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREissue_USCORErelationship_USCOREaddResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREissue_USCORErelationship_USCOREaddResponse, 0, sizeof(struct ns1__mc_USCOREissue_USCORErelationship_USCOREaddResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREissue_USCORErelationship_USCOREaddResponse(struct soap *soap, const struct ns1__mc_USCOREissue_USCORErelationship_USCOREaddResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREissue_USCORErelationship_USCOREaddResponse);
	if (soap_out_ns1__mc_USCOREissue_USCORErelationship_USCOREaddResponse(soap, tag?tag:"ns1:mc_issue_relationship_addResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCORErelationship_USCOREaddResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREissue_USCORErelationship_USCOREaddResponse(struct soap *soap, struct ns1__mc_USCOREissue_USCORErelationship_USCOREaddResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREissue_USCORErelationship_USCOREaddResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREissue_USCOREnote_USCOREdelete(struct soap *soap, struct ns1__mc_USCOREissue_USCOREnote_USCOREdelete *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
	soap_default_xsd__integer(soap, &a->issue_USCOREnote_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREissue_USCOREnote_USCOREdelete(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREnote_USCOREdelete *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
	soap_serialize_xsd__integer(soap, &a->issue_USCOREnote_USCOREid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREissue_USCOREnote_USCOREdelete(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREissue_USCOREnote_USCOREdelete *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREnote_USCOREdelete), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "issue_note_id", -1, &a->issue_USCOREnote_USCOREid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREnote_USCOREdelete * SOAP_FMAC4 soap_in_ns1__mc_USCOREissue_USCOREnote_USCOREdelete(struct soap *soap, const char *tag, struct ns1__mc_USCOREissue_USCOREnote_USCOREdelete *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_issue_USCOREnote_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREissue_USCOREnote_USCOREdelete *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREnote_USCOREdelete, sizeof(struct ns1__mc_USCOREissue_USCOREnote_USCOREdelete), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREissue_USCOREnote_USCOREdelete(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_issue_USCOREnote_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "issue_note_id", &a->issue_USCOREnote_USCOREid, "xsd:integer"))
				{	soap_flag_issue_USCOREnote_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREissue_USCOREnote_USCOREdelete *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREissue_USCOREnote_USCOREdelete, 0, sizeof(struct ns1__mc_USCOREissue_USCOREnote_USCOREdelete), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREissue_USCOREnote_USCOREdelete(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREnote_USCOREdelete *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREissue_USCOREnote_USCOREdelete);
	if (soap_out_ns1__mc_USCOREissue_USCOREnote_USCOREdelete(soap, tag?tag:"ns1:mc_issue_note_delete", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREnote_USCOREdelete * SOAP_FMAC4 soap_get_ns1__mc_USCOREissue_USCOREnote_USCOREdelete(struct soap *soap, struct ns1__mc_USCOREissue_USCOREnote_USCOREdelete *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREissue_USCOREnote_USCOREdelete(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREissue_USCOREnote_USCOREdeleteResponse(struct soap *soap, struct ns1__mc_USCOREissue_USCOREnote_USCOREdeleteResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREissue_USCOREnote_USCOREdeleteResponse(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREnote_USCOREdeleteResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__boolean(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREissue_USCOREnote_USCOREdeleteResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREissue_USCOREnote_USCOREdeleteResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREnote_USCOREdeleteResponse), type))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREnote_USCOREdeleteResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREissue_USCOREnote_USCOREdeleteResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREissue_USCOREnote_USCOREdeleteResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREissue_USCOREnote_USCOREdeleteResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREnote_USCOREdeleteResponse, sizeof(struct ns1__mc_USCOREissue_USCOREnote_USCOREdeleteResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREissue_USCOREnote_USCOREdeleteResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "return", &a->return_, "xsd:boolean"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREissue_USCOREnote_USCOREdeleteResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREissue_USCOREnote_USCOREdeleteResponse, 0, sizeof(struct ns1__mc_USCOREissue_USCOREnote_USCOREdeleteResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREissue_USCOREnote_USCOREdeleteResponse(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREnote_USCOREdeleteResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREissue_USCOREnote_USCOREdeleteResponse);
	if (soap_out_ns1__mc_USCOREissue_USCOREnote_USCOREdeleteResponse(soap, tag?tag:"ns1:mc_issue_note_deleteResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREnote_USCOREdeleteResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREissue_USCOREnote_USCOREdeleteResponse(struct soap *soap, struct ns1__mc_USCOREissue_USCOREnote_USCOREdeleteResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREissue_USCOREnote_USCOREdeleteResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREissue_USCOREnote_USCOREadd(struct soap *soap, struct ns1__mc_USCOREissue_USCOREnote_USCOREadd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
	soap_default_xsd__integer(soap, &a->issue_USCOREid);
	a->note = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREissue_USCOREnote_USCOREadd(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREnote_USCOREadd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
	soap_serialize_xsd__integer(soap, &a->issue_USCOREid);
	soap_serialize_PointerTons1__IssueNoteData(soap, &a->note);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREissue_USCOREnote_USCOREadd(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREissue_USCOREnote_USCOREadd *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREnote_USCOREadd), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "issue_id", -1, &a->issue_USCOREid, ""))
		return soap->error;
	if (soap_out_PointerTons1__IssueNoteData(soap, "note", -1, &a->note, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREnote_USCOREadd * SOAP_FMAC4 soap_in_ns1__mc_USCOREissue_USCOREnote_USCOREadd(struct soap *soap, const char *tag, struct ns1__mc_USCOREissue_USCOREnote_USCOREadd *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_issue_USCOREid = 1;
	size_t soap_flag_note = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREissue_USCOREnote_USCOREadd *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREnote_USCOREadd, sizeof(struct ns1__mc_USCOREissue_USCOREnote_USCOREadd), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREissue_USCOREnote_USCOREadd(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_issue_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "issue_id", &a->issue_USCOREid, "xsd:integer"))
				{	soap_flag_issue_USCOREid--;
					continue;
				}
			if (soap_flag_note && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__IssueNoteData(soap, "note", &a->note, "ns1:IssueNoteData"))
				{	soap_flag_note--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREissue_USCOREnote_USCOREadd *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREissue_USCOREnote_USCOREadd, 0, sizeof(struct ns1__mc_USCOREissue_USCOREnote_USCOREadd), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREissue_USCOREnote_USCOREadd(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREnote_USCOREadd *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREissue_USCOREnote_USCOREadd);
	if (soap_out_ns1__mc_USCOREissue_USCOREnote_USCOREadd(soap, tag?tag:"ns1:mc_issue_note_add", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREnote_USCOREadd * SOAP_FMAC4 soap_get_ns1__mc_USCOREissue_USCOREnote_USCOREadd(struct soap *soap, struct ns1__mc_USCOREissue_USCOREnote_USCOREadd *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREissue_USCOREnote_USCOREadd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREissue_USCOREnote_USCOREaddResponse(struct soap *soap, struct ns1__mc_USCOREissue_USCOREnote_USCOREaddResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREissue_USCOREnote_USCOREaddResponse(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREnote_USCOREaddResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__integer(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREissue_USCOREnote_USCOREaddResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREissue_USCOREnote_USCOREaddResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREnote_USCOREaddResponse), type))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREnote_USCOREaddResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREissue_USCOREnote_USCOREaddResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREissue_USCOREnote_USCOREaddResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREissue_USCOREnote_USCOREaddResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREnote_USCOREaddResponse, sizeof(struct ns1__mc_USCOREissue_USCOREnote_USCOREaddResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREissue_USCOREnote_USCOREaddResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "return", &a->return_, "xsd:integer"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREissue_USCOREnote_USCOREaddResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREissue_USCOREnote_USCOREaddResponse, 0, sizeof(struct ns1__mc_USCOREissue_USCOREnote_USCOREaddResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREissue_USCOREnote_USCOREaddResponse(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREnote_USCOREaddResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREissue_USCOREnote_USCOREaddResponse);
	if (soap_out_ns1__mc_USCOREissue_USCOREnote_USCOREaddResponse(soap, tag?tag:"ns1:mc_issue_note_addResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREnote_USCOREaddResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREissue_USCOREnote_USCOREaddResponse(struct soap *soap, struct ns1__mc_USCOREissue_USCOREnote_USCOREaddResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREissue_USCOREnote_USCOREaddResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREissue_USCOREdelete(struct soap *soap, struct ns1__mc_USCOREissue_USCOREdelete *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
	soap_default_xsd__integer(soap, &a->issue_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREissue_USCOREdelete(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREdelete *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
	soap_serialize_xsd__integer(soap, &a->issue_USCOREid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREissue_USCOREdelete(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREissue_USCOREdelete *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREdelete), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "issue_id", -1, &a->issue_USCOREid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREdelete * SOAP_FMAC4 soap_in_ns1__mc_USCOREissue_USCOREdelete(struct soap *soap, const char *tag, struct ns1__mc_USCOREissue_USCOREdelete *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_issue_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREissue_USCOREdelete *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREdelete, sizeof(struct ns1__mc_USCOREissue_USCOREdelete), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREissue_USCOREdelete(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_issue_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "issue_id", &a->issue_USCOREid, "xsd:integer"))
				{	soap_flag_issue_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREissue_USCOREdelete *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREissue_USCOREdelete, 0, sizeof(struct ns1__mc_USCOREissue_USCOREdelete), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREissue_USCOREdelete(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREdelete *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREissue_USCOREdelete);
	if (soap_out_ns1__mc_USCOREissue_USCOREdelete(soap, tag?tag:"ns1:mc_issue_delete", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREdelete * SOAP_FMAC4 soap_get_ns1__mc_USCOREissue_USCOREdelete(struct soap *soap, struct ns1__mc_USCOREissue_USCOREdelete *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREissue_USCOREdelete(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREissue_USCOREdeleteResponse(struct soap *soap, struct ns1__mc_USCOREissue_USCOREdeleteResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREissue_USCOREdeleteResponse(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREdeleteResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__boolean(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREissue_USCOREdeleteResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREissue_USCOREdeleteResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREdeleteResponse), type))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREdeleteResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREissue_USCOREdeleteResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREissue_USCOREdeleteResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREissue_USCOREdeleteResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREdeleteResponse, sizeof(struct ns1__mc_USCOREissue_USCOREdeleteResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREissue_USCOREdeleteResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "return", &a->return_, "xsd:boolean"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREissue_USCOREdeleteResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREissue_USCOREdeleteResponse, 0, sizeof(struct ns1__mc_USCOREissue_USCOREdeleteResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREissue_USCOREdeleteResponse(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREdeleteResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREissue_USCOREdeleteResponse);
	if (soap_out_ns1__mc_USCOREissue_USCOREdeleteResponse(soap, tag?tag:"ns1:mc_issue_deleteResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREdeleteResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREissue_USCOREdeleteResponse(struct soap *soap, struct ns1__mc_USCOREissue_USCOREdeleteResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREissue_USCOREdeleteResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREissue_USCOREupdate(struct soap *soap, struct ns1__mc_USCOREissue_USCOREupdate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
	soap_default_xsd__integer(soap, &a->issueId);
	a->issue = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREissue_USCOREupdate(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREupdate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
	soap_serialize_xsd__integer(soap, &a->issueId);
	soap_serialize_PointerTons1__IssueData(soap, &a->issue);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREissue_USCOREupdate(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREissue_USCOREupdate *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREupdate), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "issueId", -1, &a->issueId, ""))
		return soap->error;
	if (soap_out_PointerTons1__IssueData(soap, "issue", -1, &a->issue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREupdate * SOAP_FMAC4 soap_in_ns1__mc_USCOREissue_USCOREupdate(struct soap *soap, const char *tag, struct ns1__mc_USCOREissue_USCOREupdate *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_issueId = 1;
	size_t soap_flag_issue = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREissue_USCOREupdate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREupdate, sizeof(struct ns1__mc_USCOREissue_USCOREupdate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREissue_USCOREupdate(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_issueId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "issueId", &a->issueId, "xsd:integer"))
				{	soap_flag_issueId--;
					continue;
				}
			if (soap_flag_issue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__IssueData(soap, "issue", &a->issue, "ns1:IssueData"))
				{	soap_flag_issue--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREissue_USCOREupdate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREissue_USCOREupdate, 0, sizeof(struct ns1__mc_USCOREissue_USCOREupdate), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREissue_USCOREupdate(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREupdate *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREissue_USCOREupdate);
	if (soap_out_ns1__mc_USCOREissue_USCOREupdate(soap, tag?tag:"ns1:mc_issue_update", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREupdate * SOAP_FMAC4 soap_get_ns1__mc_USCOREissue_USCOREupdate(struct soap *soap, struct ns1__mc_USCOREissue_USCOREupdate *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREissue_USCOREupdate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREissue_USCOREupdateResponse(struct soap *soap, struct ns1__mc_USCOREissue_USCOREupdateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREissue_USCOREupdateResponse(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREupdateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__boolean(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREissue_USCOREupdateResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREissue_USCOREupdateResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREupdateResponse), type))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREupdateResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREissue_USCOREupdateResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREissue_USCOREupdateResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREissue_USCOREupdateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREupdateResponse, sizeof(struct ns1__mc_USCOREissue_USCOREupdateResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREissue_USCOREupdateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "return", &a->return_, "xsd:boolean"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREissue_USCOREupdateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREissue_USCOREupdateResponse, 0, sizeof(struct ns1__mc_USCOREissue_USCOREupdateResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREissue_USCOREupdateResponse(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREupdateResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREissue_USCOREupdateResponse);
	if (soap_out_ns1__mc_USCOREissue_USCOREupdateResponse(soap, tag?tag:"ns1:mc_issue_updateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREupdateResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREissue_USCOREupdateResponse(struct soap *soap, struct ns1__mc_USCOREissue_USCOREupdateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREissue_USCOREupdateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREissue_USCOREadd(struct soap *soap, struct ns1__mc_USCOREissue_USCOREadd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
	a->issue = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREissue_USCOREadd(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREadd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
	soap_serialize_PointerTons1__IssueData(soap, &a->issue);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREissue_USCOREadd(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREissue_USCOREadd *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREadd), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_PointerTons1__IssueData(soap, "issue", -1, &a->issue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREadd * SOAP_FMAC4 soap_in_ns1__mc_USCOREissue_USCOREadd(struct soap *soap, const char *tag, struct ns1__mc_USCOREissue_USCOREadd *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_issue = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREissue_USCOREadd *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREadd, sizeof(struct ns1__mc_USCOREissue_USCOREadd), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREissue_USCOREadd(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_issue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__IssueData(soap, "issue", &a->issue, "ns1:IssueData"))
				{	soap_flag_issue--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREissue_USCOREadd *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREissue_USCOREadd, 0, sizeof(struct ns1__mc_USCOREissue_USCOREadd), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREissue_USCOREadd(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREadd *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREissue_USCOREadd);
	if (soap_out_ns1__mc_USCOREissue_USCOREadd(soap, tag?tag:"ns1:mc_issue_add", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREadd * SOAP_FMAC4 soap_get_ns1__mc_USCOREissue_USCOREadd(struct soap *soap, struct ns1__mc_USCOREissue_USCOREadd *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREissue_USCOREadd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREissue_USCOREaddResponse(struct soap *soap, struct ns1__mc_USCOREissue_USCOREaddResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREissue_USCOREaddResponse(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREaddResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__integer(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREissue_USCOREaddResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREissue_USCOREaddResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREaddResponse), type))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREaddResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREissue_USCOREaddResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREissue_USCOREaddResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREissue_USCOREaddResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREaddResponse, sizeof(struct ns1__mc_USCOREissue_USCOREaddResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREissue_USCOREaddResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "return", &a->return_, "xsd:integer"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREissue_USCOREaddResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREissue_USCOREaddResponse, 0, sizeof(struct ns1__mc_USCOREissue_USCOREaddResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREissue_USCOREaddResponse(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREaddResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREissue_USCOREaddResponse);
	if (soap_out_ns1__mc_USCOREissue_USCOREaddResponse(soap, tag?tag:"ns1:mc_issue_addResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREaddResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREissue_USCOREaddResponse(struct soap *soap, struct ns1__mc_USCOREissue_USCOREaddResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREissue_USCOREaddResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummary(struct soap *soap, struct ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
	soap_default_string(soap, &a->summary);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummary(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
	soap_serialize_string(soap, &a->summary);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummary(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummary *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummary), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_string(soap, "summary", -1, &a->summary, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummary * SOAP_FMAC4 soap_in_ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummary(struct soap *soap, const char *tag, struct ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummary *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_summary = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummary, sizeof(struct ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummary), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummary(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_summary && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "summary", &a->summary, "xsd:string"))
				{	soap_flag_summary--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummary, 0, sizeof(struct ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummary), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummary(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummary *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummary);
	if (soap_out_ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummary(soap, tag?tag:"ns1:mc_issue_get_id_from_summary", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummary * SOAP_FMAC4 soap_get_ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummary(struct soap *soap, struct ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummary *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummaryResponse(struct soap *soap, struct ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummaryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummaryResponse(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummaryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__integer(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummaryResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummaryResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummaryResponse), type))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummaryResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummaryResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummaryResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummaryResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummaryResponse, sizeof(struct ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummaryResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummaryResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "return", &a->return_, "xsd:integer"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummaryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummaryResponse, 0, sizeof(struct ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummaryResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummaryResponse(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummaryResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummaryResponse);
	if (soap_out_ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummaryResponse(soap, tag?tag:"ns1:mc_issue_get_id_from_summaryResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummaryResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummaryResponse(struct soap *soap, struct ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummaryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREissue_USCOREget_USCOREid_USCOREfrom_USCOREsummaryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREid(struct soap *soap, struct ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
	soap_default_xsd__integer(soap, &a->project_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREid(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
	soap_serialize_xsd__integer(soap, &a->project_USCOREid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREid(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREid *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREid), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "project_id", -1, &a->project_USCOREid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREid * SOAP_FMAC4 soap_in_ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREid(struct soap *soap, const char *tag, struct ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREid *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_project_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREid *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREid, sizeof(struct ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREid), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREid(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_project_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "project_id", &a->project_USCOREid, "xsd:integer"))
				{	soap_flag_project_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREid *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREid, 0, sizeof(struct ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREid), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREid(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREid *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREid);
	if (soap_out_ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREid(soap, tag?tag:"ns1:mc_issue_get_biggest_id", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREid * SOAP_FMAC4 soap_get_ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREid(struct soap *soap, struct ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREid *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREidResponse(struct soap *soap, struct ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREidResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREidResponse(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREidResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__integer(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREidResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREidResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREidResponse), type))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREidResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREidResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREidResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREidResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREidResponse, sizeof(struct ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREidResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREidResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "return", &a->return_, "xsd:integer"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREidResponse, 0, sizeof(struct ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREidResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREidResponse(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREidResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREidResponse);
	if (soap_out_ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREidResponse(soap, tag?tag:"ns1:mc_issue_get_biggest_idResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREidResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREidResponse(struct soap *soap, struct ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREidResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREissue_USCOREget_USCOREbiggest_USCOREidResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREissue_USCOREget(struct soap *soap, struct ns1__mc_USCOREissue_USCOREget *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
	soap_default_xsd__integer(soap, &a->issue_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREissue_USCOREget(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREget *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
	soap_serialize_xsd__integer(soap, &a->issue_USCOREid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREissue_USCOREget(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREissue_USCOREget *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREget), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "issue_id", -1, &a->issue_USCOREid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREget * SOAP_FMAC4 soap_in_ns1__mc_USCOREissue_USCOREget(struct soap *soap, const char *tag, struct ns1__mc_USCOREissue_USCOREget *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_issue_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREissue_USCOREget *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREget, sizeof(struct ns1__mc_USCOREissue_USCOREget), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREissue_USCOREget(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_issue_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "issue_id", &a->issue_USCOREid, "xsd:integer"))
				{	soap_flag_issue_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREissue_USCOREget *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREissue_USCOREget, 0, sizeof(struct ns1__mc_USCOREissue_USCOREget), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREissue_USCOREget(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREget *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREissue_USCOREget);
	if (soap_out_ns1__mc_USCOREissue_USCOREget(soap, tag?tag:"ns1:mc_issue_get", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREget * SOAP_FMAC4 soap_get_ns1__mc_USCOREissue_USCOREget(struct soap *soap, struct ns1__mc_USCOREissue_USCOREget *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREissue_USCOREget(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREissue_USCOREgetResponse(struct soap *soap, struct ns1__mc_USCOREissue_USCOREgetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREissue_USCOREgetResponse(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREgetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__IssueData(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREissue_USCOREgetResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREissue_USCOREgetResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREgetResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__IssueData(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREgetResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREissue_USCOREgetResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREissue_USCOREgetResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREissue_USCOREgetResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREgetResponse, sizeof(struct ns1__mc_USCOREissue_USCOREgetResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREissue_USCOREgetResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__IssueData(soap, "return", &a->return_, "ns1:IssueData"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREissue_USCOREgetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREissue_USCOREgetResponse, 0, sizeof(struct ns1__mc_USCOREissue_USCOREgetResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREissue_USCOREgetResponse(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREgetResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREissue_USCOREgetResponse);
	if (soap_out_ns1__mc_USCOREissue_USCOREgetResponse(soap, tag?tag:"ns1:mc_issue_getResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREgetResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREissue_USCOREgetResponse(struct soap *soap, struct ns1__mc_USCOREissue_USCOREgetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREissue_USCOREgetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREissue_USCOREexists(struct soap *soap, struct ns1__mc_USCOREissue_USCOREexists *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
	soap_default_xsd__integer(soap, &a->issue_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREissue_USCOREexists(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREexists *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
	soap_serialize_xsd__integer(soap, &a->issue_USCOREid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREissue_USCOREexists(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREissue_USCOREexists *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREexists), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "issue_id", -1, &a->issue_USCOREid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREexists * SOAP_FMAC4 soap_in_ns1__mc_USCOREissue_USCOREexists(struct soap *soap, const char *tag, struct ns1__mc_USCOREissue_USCOREexists *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_issue_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREissue_USCOREexists *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREexists, sizeof(struct ns1__mc_USCOREissue_USCOREexists), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREissue_USCOREexists(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_issue_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "issue_id", &a->issue_USCOREid, "xsd:integer"))
				{	soap_flag_issue_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREissue_USCOREexists *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREissue_USCOREexists, 0, sizeof(struct ns1__mc_USCOREissue_USCOREexists), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREissue_USCOREexists(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREexists *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREissue_USCOREexists);
	if (soap_out_ns1__mc_USCOREissue_USCOREexists(soap, tag?tag:"ns1:mc_issue_exists", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREexists * SOAP_FMAC4 soap_get_ns1__mc_USCOREissue_USCOREexists(struct soap *soap, struct ns1__mc_USCOREissue_USCOREexists *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREissue_USCOREexists(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREissue_USCOREexistsResponse(struct soap *soap, struct ns1__mc_USCOREissue_USCOREexistsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREissue_USCOREexistsResponse(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREexistsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__boolean(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREissue_USCOREexistsResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREissue_USCOREexistsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREexistsResponse), type))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREexistsResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREissue_USCOREexistsResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREissue_USCOREexistsResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREissue_USCOREexistsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREexistsResponse, sizeof(struct ns1__mc_USCOREissue_USCOREexistsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREissue_USCOREexistsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "return", &a->return_, "xsd:boolean"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREissue_USCOREexistsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREissue_USCOREexistsResponse, 0, sizeof(struct ns1__mc_USCOREissue_USCOREexistsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREissue_USCOREexistsResponse(struct soap *soap, const struct ns1__mc_USCOREissue_USCOREexistsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREissue_USCOREexistsResponse);
	if (soap_out_ns1__mc_USCOREissue_USCOREexistsResponse(soap, tag?tag:"ns1:mc_issue_existsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREexistsResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREissue_USCOREexistsResponse(struct soap *soap, struct ns1__mc_USCOREissue_USCOREexistsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREissue_USCOREexistsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREenum_USCOREget(struct soap *soap, struct ns1__mc_USCOREenum_USCOREget *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
	soap_default_string(soap, &a->enumeration);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREenum_USCOREget(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREget *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
	soap_serialize_string(soap, &a->enumeration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREenum_USCOREget(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREenum_USCOREget *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREget), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_string(soap, "enumeration", -1, &a->enumeration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREget * SOAP_FMAC4 soap_in_ns1__mc_USCOREenum_USCOREget(struct soap *soap, const char *tag, struct ns1__mc_USCOREenum_USCOREget *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_enumeration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREenum_USCOREget *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREget, sizeof(struct ns1__mc_USCOREenum_USCOREget), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREenum_USCOREget(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_enumeration && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "enumeration", &a->enumeration, "xsd:string"))
				{	soap_flag_enumeration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREenum_USCOREget *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREenum_USCOREget, 0, sizeof(struct ns1__mc_USCOREenum_USCOREget), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREenum_USCOREget(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREget *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREenum_USCOREget);
	if (soap_out_ns1__mc_USCOREenum_USCOREget(soap, tag?tag:"ns1:mc_enum_get", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREget * SOAP_FMAC4 soap_get_ns1__mc_USCOREenum_USCOREget(struct soap *soap, struct ns1__mc_USCOREenum_USCOREget *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREenum_USCOREget(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREenum_USCOREgetResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREgetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREenum_USCOREgetResponse(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREgetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREenum_USCOREgetResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREenum_USCOREgetResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREgetResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREgetResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREenum_USCOREgetResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREenum_USCOREgetResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREenum_USCOREgetResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREgetResponse, sizeof(struct ns1__mc_USCOREenum_USCOREgetResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREenum_USCOREgetResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREenum_USCOREgetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREenum_USCOREgetResponse, 0, sizeof(struct ns1__mc_USCOREenum_USCOREgetResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREenum_USCOREgetResponse(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREgetResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREenum_USCOREgetResponse);
	if (soap_out_ns1__mc_USCOREenum_USCOREgetResponse(soap, tag?tag:"ns1:mc_enum_getResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREgetResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREenum_USCOREgetResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREgetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREenum_USCOREgetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypes(struct soap *soap, struct ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypes(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypes(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypes *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypes), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypes * SOAP_FMAC4 soap_in_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypes(struct soap *soap, const char *tag, struct ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypes *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypes, sizeof(struct ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypes, 0, sizeof(struct ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypes(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypes);
	if (soap_out_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypes(soap, tag?tag:"ns1:mc_enum_custom_field_types", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypes * SOAP_FMAC4 soap_get_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypes(struct soap *soap, struct ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypes *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToObjectRefArray(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse), type))
		return soap->error;
	if (soap_out_PointerToObjectRefArray(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse, sizeof(struct ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToObjectRefArray(soap, "return", &a->return_, "ns1:ObjectRef"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse, 0, sizeof(struct ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse);
	if (soap_out_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse(soap, tag?tag:"ns1:mc_enum_custom_field_typesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREenum_USCOREview_USCOREstates(struct soap *soap, struct ns1__mc_USCOREenum_USCOREview_USCOREstates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREenum_USCOREview_USCOREstates(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREview_USCOREstates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREenum_USCOREview_USCOREstates(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREenum_USCOREview_USCOREstates *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREview_USCOREstates), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREview_USCOREstates * SOAP_FMAC4 soap_in_ns1__mc_USCOREenum_USCOREview_USCOREstates(struct soap *soap, const char *tag, struct ns1__mc_USCOREenum_USCOREview_USCOREstates *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREenum_USCOREview_USCOREstates *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREview_USCOREstates, sizeof(struct ns1__mc_USCOREenum_USCOREview_USCOREstates), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREenum_USCOREview_USCOREstates(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREenum_USCOREview_USCOREstates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREenum_USCOREview_USCOREstates, 0, sizeof(struct ns1__mc_USCOREenum_USCOREview_USCOREstates), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREenum_USCOREview_USCOREstates(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREview_USCOREstates *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREenum_USCOREview_USCOREstates);
	if (soap_out_ns1__mc_USCOREenum_USCOREview_USCOREstates(soap, tag?tag:"ns1:mc_enum_view_states", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREview_USCOREstates * SOAP_FMAC4 soap_get_ns1__mc_USCOREenum_USCOREview_USCOREstates(struct soap *soap, struct ns1__mc_USCOREenum_USCOREview_USCOREstates *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREenum_USCOREview_USCOREstates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToObjectRefArray(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse), type))
		return soap->error;
	if (soap_out_PointerToObjectRefArray(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse, sizeof(struct ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToObjectRefArray(soap, "return", &a->return_, "ns1:ObjectRef"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse, 0, sizeof(struct ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse);
	if (soap_out_ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse(soap, tag?tag:"ns1:mc_enum_view_statesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstates(struct soap *soap, struct ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstates(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstates(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstates *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstates), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstates * SOAP_FMAC4 soap_in_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstates(struct soap *soap, const char *tag, struct ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstates *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstates *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstates, sizeof(struct ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstates), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstates(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstates, 0, sizeof(struct ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstates), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstates(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstates *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstates);
	if (soap_out_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstates(soap, tag?tag:"ns1:mc_enum_project_view_states", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstates * SOAP_FMAC4 soap_get_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstates(struct soap *soap, struct ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstates *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToObjectRefArray(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse), type))
		return soap->error;
	if (soap_out_PointerToObjectRefArray(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse, sizeof(struct ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToObjectRefArray(soap, "return", &a->return_, "ns1:ObjectRef"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse, 0, sizeof(struct ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse);
	if (soap_out_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse(soap, tag?tag:"ns1:mc_enum_project_view_statesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREenum_USCOREproject_USCOREstatus(struct soap *soap, struct ns1__mc_USCOREenum_USCOREproject_USCOREstatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREenum_USCOREproject_USCOREstatus(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREproject_USCOREstatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREenum_USCOREproject_USCOREstatus(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREenum_USCOREproject_USCOREstatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREproject_USCOREstatus), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREproject_USCOREstatus * SOAP_FMAC4 soap_in_ns1__mc_USCOREenum_USCOREproject_USCOREstatus(struct soap *soap, const char *tag, struct ns1__mc_USCOREenum_USCOREproject_USCOREstatus *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREenum_USCOREproject_USCOREstatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREproject_USCOREstatus, sizeof(struct ns1__mc_USCOREenum_USCOREproject_USCOREstatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREenum_USCOREproject_USCOREstatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREenum_USCOREproject_USCOREstatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREenum_USCOREproject_USCOREstatus, 0, sizeof(struct ns1__mc_USCOREenum_USCOREproject_USCOREstatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREenum_USCOREproject_USCOREstatus(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREproject_USCOREstatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREenum_USCOREproject_USCOREstatus);
	if (soap_out_ns1__mc_USCOREenum_USCOREproject_USCOREstatus(soap, tag?tag:"ns1:mc_enum_project_status", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREproject_USCOREstatus * SOAP_FMAC4 soap_get_ns1__mc_USCOREenum_USCOREproject_USCOREstatus(struct soap *soap, struct ns1__mc_USCOREenum_USCOREproject_USCOREstatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREenum_USCOREproject_USCOREstatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToObjectRefArray(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse), type))
		return soap->error;
	if (soap_out_PointerToObjectRefArray(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse, sizeof(struct ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToObjectRefArray(soap, "return", &a->return_, "ns1:ObjectRef"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse, 0, sizeof(struct ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse);
	if (soap_out_ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse(soap, tag?tag:"ns1:mc_enum_project_statusResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREenum_USCOREaccess_USCORElevels(struct soap *soap, struct ns1__mc_USCOREenum_USCOREaccess_USCORElevels *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREenum_USCOREaccess_USCORElevels(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREaccess_USCORElevels *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREenum_USCOREaccess_USCORElevels(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREenum_USCOREaccess_USCORElevels *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREaccess_USCORElevels), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREaccess_USCORElevels * SOAP_FMAC4 soap_in_ns1__mc_USCOREenum_USCOREaccess_USCORElevels(struct soap *soap, const char *tag, struct ns1__mc_USCOREenum_USCOREaccess_USCORElevels *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREenum_USCOREaccess_USCORElevels *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREaccess_USCORElevels, sizeof(struct ns1__mc_USCOREenum_USCOREaccess_USCORElevels), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREenum_USCOREaccess_USCORElevels(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREenum_USCOREaccess_USCORElevels *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREenum_USCOREaccess_USCORElevels, 0, sizeof(struct ns1__mc_USCOREenum_USCOREaccess_USCORElevels), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREenum_USCOREaccess_USCORElevels(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREaccess_USCORElevels *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREenum_USCOREaccess_USCORElevels);
	if (soap_out_ns1__mc_USCOREenum_USCOREaccess_USCORElevels(soap, tag?tag:"ns1:mc_enum_access_levels", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREaccess_USCORElevels * SOAP_FMAC4 soap_get_ns1__mc_USCOREenum_USCOREaccess_USCORElevels(struct soap *soap, struct ns1__mc_USCOREenum_USCOREaccess_USCORElevels *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREenum_USCOREaccess_USCORElevels(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToObjectRefArray(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse), type))
		return soap->error;
	if (soap_out_PointerToObjectRefArray(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse, sizeof(struct ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToObjectRefArray(soap, "return", &a->return_, "ns1:ObjectRef"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse, 0, sizeof(struct ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse);
	if (soap_out_ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse(soap, tag?tag:"ns1:mc_enum_access_levelsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREenum_USCOREresolutions(struct soap *soap, struct ns1__mc_USCOREenum_USCOREresolutions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREenum_USCOREresolutions(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREresolutions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREenum_USCOREresolutions(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREenum_USCOREresolutions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREresolutions), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREresolutions * SOAP_FMAC4 soap_in_ns1__mc_USCOREenum_USCOREresolutions(struct soap *soap, const char *tag, struct ns1__mc_USCOREenum_USCOREresolutions *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREenum_USCOREresolutions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREresolutions, sizeof(struct ns1__mc_USCOREenum_USCOREresolutions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREenum_USCOREresolutions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREenum_USCOREresolutions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREenum_USCOREresolutions, 0, sizeof(struct ns1__mc_USCOREenum_USCOREresolutions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREenum_USCOREresolutions(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREresolutions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREenum_USCOREresolutions);
	if (soap_out_ns1__mc_USCOREenum_USCOREresolutions(soap, tag?tag:"ns1:mc_enum_resolutions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREresolutions * SOAP_FMAC4 soap_get_ns1__mc_USCOREenum_USCOREresolutions(struct soap *soap, struct ns1__mc_USCOREenum_USCOREresolutions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREenum_USCOREresolutions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREenum_USCOREresolutionsResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREresolutionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREenum_USCOREresolutionsResponse(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREresolutionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToObjectRefArray(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREenum_USCOREresolutionsResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREenum_USCOREresolutionsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREresolutionsResponse), type))
		return soap->error;
	if (soap_out_PointerToObjectRefArray(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREresolutionsResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREenum_USCOREresolutionsResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREenum_USCOREresolutionsResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREenum_USCOREresolutionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREresolutionsResponse, sizeof(struct ns1__mc_USCOREenum_USCOREresolutionsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREenum_USCOREresolutionsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToObjectRefArray(soap, "return", &a->return_, "ns1:ObjectRef"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREenum_USCOREresolutionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREenum_USCOREresolutionsResponse, 0, sizeof(struct ns1__mc_USCOREenum_USCOREresolutionsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREenum_USCOREresolutionsResponse(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREresolutionsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREenum_USCOREresolutionsResponse);
	if (soap_out_ns1__mc_USCOREenum_USCOREresolutionsResponse(soap, tag?tag:"ns1:mc_enum_resolutionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREresolutionsResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREenum_USCOREresolutionsResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREresolutionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREenum_USCOREresolutionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREenum_USCOREetas(struct soap *soap, struct ns1__mc_USCOREenum_USCOREetas *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREenum_USCOREetas(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREetas *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREenum_USCOREetas(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREenum_USCOREetas *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREetas), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREetas * SOAP_FMAC4 soap_in_ns1__mc_USCOREenum_USCOREetas(struct soap *soap, const char *tag, struct ns1__mc_USCOREenum_USCOREetas *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREenum_USCOREetas *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREetas, sizeof(struct ns1__mc_USCOREenum_USCOREetas), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREenum_USCOREetas(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREenum_USCOREetas *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREenum_USCOREetas, 0, sizeof(struct ns1__mc_USCOREenum_USCOREetas), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREenum_USCOREetas(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREetas *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREenum_USCOREetas);
	if (soap_out_ns1__mc_USCOREenum_USCOREetas(soap, tag?tag:"ns1:mc_enum_etas", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREetas * SOAP_FMAC4 soap_get_ns1__mc_USCOREenum_USCOREetas(struct soap *soap, struct ns1__mc_USCOREenum_USCOREetas *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREenum_USCOREetas(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREenum_USCOREetasResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREetasResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREenum_USCOREetasResponse(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREetasResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToObjectRefArray(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREenum_USCOREetasResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREenum_USCOREetasResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREetasResponse), type))
		return soap->error;
	if (soap_out_PointerToObjectRefArray(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREetasResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREenum_USCOREetasResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREenum_USCOREetasResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREenum_USCOREetasResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREetasResponse, sizeof(struct ns1__mc_USCOREenum_USCOREetasResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREenum_USCOREetasResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToObjectRefArray(soap, "return", &a->return_, "ns1:ObjectRef"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREenum_USCOREetasResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREenum_USCOREetasResponse, 0, sizeof(struct ns1__mc_USCOREenum_USCOREetasResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREenum_USCOREetasResponse(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREetasResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREenum_USCOREetasResponse);
	if (soap_out_ns1__mc_USCOREenum_USCOREetasResponse(soap, tag?tag:"ns1:mc_enum_etasResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREetasResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREenum_USCOREetasResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREetasResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREenum_USCOREetasResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREenum_USCOREprojections(struct soap *soap, struct ns1__mc_USCOREenum_USCOREprojections *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREenum_USCOREprojections(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREprojections *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREenum_USCOREprojections(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREenum_USCOREprojections *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREprojections), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREprojections * SOAP_FMAC4 soap_in_ns1__mc_USCOREenum_USCOREprojections(struct soap *soap, const char *tag, struct ns1__mc_USCOREenum_USCOREprojections *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREenum_USCOREprojections *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREprojections, sizeof(struct ns1__mc_USCOREenum_USCOREprojections), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREenum_USCOREprojections(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREenum_USCOREprojections *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREenum_USCOREprojections, 0, sizeof(struct ns1__mc_USCOREenum_USCOREprojections), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREenum_USCOREprojections(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREprojections *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREenum_USCOREprojections);
	if (soap_out_ns1__mc_USCOREenum_USCOREprojections(soap, tag?tag:"ns1:mc_enum_projections", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREprojections * SOAP_FMAC4 soap_get_ns1__mc_USCOREenum_USCOREprojections(struct soap *soap, struct ns1__mc_USCOREenum_USCOREprojections *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREenum_USCOREprojections(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREenum_USCOREprojectionsResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREprojectionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREenum_USCOREprojectionsResponse(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREprojectionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToObjectRefArray(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREenum_USCOREprojectionsResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREenum_USCOREprojectionsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREprojectionsResponse), type))
		return soap->error;
	if (soap_out_PointerToObjectRefArray(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREprojectionsResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREenum_USCOREprojectionsResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREenum_USCOREprojectionsResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREenum_USCOREprojectionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREprojectionsResponse, sizeof(struct ns1__mc_USCOREenum_USCOREprojectionsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREenum_USCOREprojectionsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToObjectRefArray(soap, "return", &a->return_, "ns1:ObjectRef"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREenum_USCOREprojectionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREenum_USCOREprojectionsResponse, 0, sizeof(struct ns1__mc_USCOREenum_USCOREprojectionsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREenum_USCOREprojectionsResponse(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREprojectionsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREenum_USCOREprojectionsResponse);
	if (soap_out_ns1__mc_USCOREenum_USCOREprojectionsResponse(soap, tag?tag:"ns1:mc_enum_projectionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREprojectionsResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREenum_USCOREprojectionsResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREprojectionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREenum_USCOREprojectionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREenum_USCOREreproducibilities(struct soap *soap, struct ns1__mc_USCOREenum_USCOREreproducibilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREenum_USCOREreproducibilities(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREreproducibilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREenum_USCOREreproducibilities(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREenum_USCOREreproducibilities *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREreproducibilities), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREreproducibilities * SOAP_FMAC4 soap_in_ns1__mc_USCOREenum_USCOREreproducibilities(struct soap *soap, const char *tag, struct ns1__mc_USCOREenum_USCOREreproducibilities *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREenum_USCOREreproducibilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREreproducibilities, sizeof(struct ns1__mc_USCOREenum_USCOREreproducibilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREenum_USCOREreproducibilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREenum_USCOREreproducibilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREenum_USCOREreproducibilities, 0, sizeof(struct ns1__mc_USCOREenum_USCOREreproducibilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREenum_USCOREreproducibilities(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREreproducibilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREenum_USCOREreproducibilities);
	if (soap_out_ns1__mc_USCOREenum_USCOREreproducibilities(soap, tag?tag:"ns1:mc_enum_reproducibilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREreproducibilities * SOAP_FMAC4 soap_get_ns1__mc_USCOREenum_USCOREreproducibilities(struct soap *soap, struct ns1__mc_USCOREenum_USCOREreproducibilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREenum_USCOREreproducibilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREenum_USCOREreproducibilitiesResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREreproducibilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREenum_USCOREreproducibilitiesResponse(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREreproducibilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToObjectRefArray(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREenum_USCOREreproducibilitiesResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREenum_USCOREreproducibilitiesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREreproducibilitiesResponse), type))
		return soap->error;
	if (soap_out_PointerToObjectRefArray(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREreproducibilitiesResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREenum_USCOREreproducibilitiesResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREenum_USCOREreproducibilitiesResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREenum_USCOREreproducibilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREreproducibilitiesResponse, sizeof(struct ns1__mc_USCOREenum_USCOREreproducibilitiesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREenum_USCOREreproducibilitiesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToObjectRefArray(soap, "return", &a->return_, "ns1:ObjectRef"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREenum_USCOREreproducibilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREenum_USCOREreproducibilitiesResponse, 0, sizeof(struct ns1__mc_USCOREenum_USCOREreproducibilitiesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREenum_USCOREreproducibilitiesResponse(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREreproducibilitiesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREenum_USCOREreproducibilitiesResponse);
	if (soap_out_ns1__mc_USCOREenum_USCOREreproducibilitiesResponse(soap, tag?tag:"ns1:mc_enum_reproducibilitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREreproducibilitiesResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREenum_USCOREreproducibilitiesResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREreproducibilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREenum_USCOREreproducibilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREenum_USCOREseverities(struct soap *soap, struct ns1__mc_USCOREenum_USCOREseverities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREenum_USCOREseverities(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREseverities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREenum_USCOREseverities(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREenum_USCOREseverities *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREseverities), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREseverities * SOAP_FMAC4 soap_in_ns1__mc_USCOREenum_USCOREseverities(struct soap *soap, const char *tag, struct ns1__mc_USCOREenum_USCOREseverities *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREenum_USCOREseverities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREseverities, sizeof(struct ns1__mc_USCOREenum_USCOREseverities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREenum_USCOREseverities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREenum_USCOREseverities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREenum_USCOREseverities, 0, sizeof(struct ns1__mc_USCOREenum_USCOREseverities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREenum_USCOREseverities(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREseverities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREenum_USCOREseverities);
	if (soap_out_ns1__mc_USCOREenum_USCOREseverities(soap, tag?tag:"ns1:mc_enum_severities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREseverities * SOAP_FMAC4 soap_get_ns1__mc_USCOREenum_USCOREseverities(struct soap *soap, struct ns1__mc_USCOREenum_USCOREseverities *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREenum_USCOREseverities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREenum_USCOREseveritiesResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREseveritiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREenum_USCOREseveritiesResponse(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREseveritiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToObjectRefArray(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREenum_USCOREseveritiesResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREenum_USCOREseveritiesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREseveritiesResponse), type))
		return soap->error;
	if (soap_out_PointerToObjectRefArray(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREseveritiesResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREenum_USCOREseveritiesResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREenum_USCOREseveritiesResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREenum_USCOREseveritiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREseveritiesResponse, sizeof(struct ns1__mc_USCOREenum_USCOREseveritiesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREenum_USCOREseveritiesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToObjectRefArray(soap, "return", &a->return_, "ns1:ObjectRef"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREenum_USCOREseveritiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREenum_USCOREseveritiesResponse, 0, sizeof(struct ns1__mc_USCOREenum_USCOREseveritiesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREenum_USCOREseveritiesResponse(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREseveritiesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREenum_USCOREseveritiesResponse);
	if (soap_out_ns1__mc_USCOREenum_USCOREseveritiesResponse(soap, tag?tag:"ns1:mc_enum_severitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREseveritiesResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREenum_USCOREseveritiesResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREseveritiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREenum_USCOREseveritiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREenum_USCOREpriorities(struct soap *soap, struct ns1__mc_USCOREenum_USCOREpriorities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREenum_USCOREpriorities(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREpriorities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREenum_USCOREpriorities(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREenum_USCOREpriorities *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREpriorities), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREpriorities * SOAP_FMAC4 soap_in_ns1__mc_USCOREenum_USCOREpriorities(struct soap *soap, const char *tag, struct ns1__mc_USCOREenum_USCOREpriorities *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREenum_USCOREpriorities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREpriorities, sizeof(struct ns1__mc_USCOREenum_USCOREpriorities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREenum_USCOREpriorities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREenum_USCOREpriorities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREenum_USCOREpriorities, 0, sizeof(struct ns1__mc_USCOREenum_USCOREpriorities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREenum_USCOREpriorities(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREpriorities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREenum_USCOREpriorities);
	if (soap_out_ns1__mc_USCOREenum_USCOREpriorities(soap, tag?tag:"ns1:mc_enum_priorities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREpriorities * SOAP_FMAC4 soap_get_ns1__mc_USCOREenum_USCOREpriorities(struct soap *soap, struct ns1__mc_USCOREenum_USCOREpriorities *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREenum_USCOREpriorities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREenum_USCOREprioritiesResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREprioritiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREenum_USCOREprioritiesResponse(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREprioritiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToObjectRefArray(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREenum_USCOREprioritiesResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREenum_USCOREprioritiesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREprioritiesResponse), type))
		return soap->error;
	if (soap_out_PointerToObjectRefArray(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREprioritiesResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREenum_USCOREprioritiesResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREenum_USCOREprioritiesResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREenum_USCOREprioritiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREprioritiesResponse, sizeof(struct ns1__mc_USCOREenum_USCOREprioritiesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREenum_USCOREprioritiesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToObjectRefArray(soap, "return", &a->return_, "ns1:ObjectRef"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREenum_USCOREprioritiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREenum_USCOREprioritiesResponse, 0, sizeof(struct ns1__mc_USCOREenum_USCOREprioritiesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREenum_USCOREprioritiesResponse(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREprioritiesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREenum_USCOREprioritiesResponse);
	if (soap_out_ns1__mc_USCOREenum_USCOREprioritiesResponse(soap, tag?tag:"ns1:mc_enum_prioritiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREprioritiesResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREenum_USCOREprioritiesResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREprioritiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREenum_USCOREprioritiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREenum_USCOREstatus(struct soap *soap, struct ns1__mc_USCOREenum_USCOREstatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREenum_USCOREstatus(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREstatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREenum_USCOREstatus(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREenum_USCOREstatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREstatus), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREstatus * SOAP_FMAC4 soap_in_ns1__mc_USCOREenum_USCOREstatus(struct soap *soap, const char *tag, struct ns1__mc_USCOREenum_USCOREstatus *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREenum_USCOREstatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREstatus, sizeof(struct ns1__mc_USCOREenum_USCOREstatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREenum_USCOREstatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREenum_USCOREstatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREenum_USCOREstatus, 0, sizeof(struct ns1__mc_USCOREenum_USCOREstatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREenum_USCOREstatus(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREstatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREenum_USCOREstatus);
	if (soap_out_ns1__mc_USCOREenum_USCOREstatus(soap, tag?tag:"ns1:mc_enum_status", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREstatus * SOAP_FMAC4 soap_get_ns1__mc_USCOREenum_USCOREstatus(struct soap *soap, struct ns1__mc_USCOREenum_USCOREstatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREenum_USCOREstatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREenum_USCOREstatusResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREstatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREenum_USCOREstatusResponse(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREstatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToObjectRefArray(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREenum_USCOREstatusResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREenum_USCOREstatusResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREstatusResponse), type))
		return soap->error;
	if (soap_out_PointerToObjectRefArray(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREstatusResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREenum_USCOREstatusResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREenum_USCOREstatusResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREenum_USCOREstatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREstatusResponse, sizeof(struct ns1__mc_USCOREenum_USCOREstatusResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREenum_USCOREstatusResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToObjectRefArray(soap, "return", &a->return_, "ns1:ObjectRef"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREenum_USCOREstatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREenum_USCOREstatusResponse, 0, sizeof(struct ns1__mc_USCOREenum_USCOREstatusResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREenum_USCOREstatusResponse(struct soap *soap, const struct ns1__mc_USCOREenum_USCOREstatusResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREenum_USCOREstatusResponse);
	if (soap_out_ns1__mc_USCOREenum_USCOREstatusResponse(soap, tag?tag:"ns1:mc_enum_statusResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREstatusResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREenum_USCOREstatusResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREstatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREenum_USCOREstatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREversion(struct soap *soap, struct ns1__mc_USCOREversion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREversion(struct soap *soap, const struct ns1__mc_USCOREversion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREversion(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREversion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREversion), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREversion * SOAP_FMAC4 soap_in_ns1__mc_USCOREversion(struct soap *soap, const char *tag, struct ns1__mc_USCOREversion *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREversion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREversion, sizeof(struct ns1__mc_USCOREversion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREversion(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREversion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREversion, 0, sizeof(struct ns1__mc_USCOREversion), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREversion(struct soap *soap, const struct ns1__mc_USCOREversion *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREversion);
	if (soap_out_ns1__mc_USCOREversion(soap, tag?tag:"ns1:mc_version", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREversion * SOAP_FMAC4 soap_get_ns1__mc_USCOREversion(struct soap *soap, struct ns1__mc_USCOREversion *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREversion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__mc_USCOREversionResponse(struct soap *soap, struct ns1__mc_USCOREversionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__mc_USCOREversionResponse(struct soap *soap, const struct ns1__mc_USCOREversionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mc_USCOREversionResponse(struct soap *soap, const char *tag, int id, const struct ns1__mc_USCOREversionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mc_USCOREversionResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__mc_USCOREversionResponse * SOAP_FMAC4 soap_in_ns1__mc_USCOREversionResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREversionResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__mc_USCOREversionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mc_USCOREversionResponse, sizeof(struct ns1__mc_USCOREversionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__mc_USCOREversionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREversionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mc_USCOREversionResponse, 0, sizeof(struct ns1__mc_USCOREversionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__mc_USCOREversionResponse(struct soap *soap, const struct ns1__mc_USCOREversionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__mc_USCOREversionResponse);
	if (soap_out_ns1__mc_USCOREversionResponse(soap, tag?tag:"ns1:mc_versionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREversionResponse * SOAP_FMAC4 soap_get_ns1__mc_USCOREversionResponse(struct soap *soap, struct ns1__mc_USCOREversionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mc_USCOREversionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_CustomFieldLinkForProjectDataArray(struct soap *soap, struct CustomFieldLinkForProjectDataArray *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_CustomFieldLinkForProjectDataArray(struct soap *soap, struct CustomFieldLinkForProjectDataArray const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_CustomFieldLinkForProjectDataArray))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__CustomFieldLinkForProjectData(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_CustomFieldLinkForProjectDataArray(struct soap *soap, const char *tag, int id, const struct CustomFieldLinkForProjectDataArray *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "ns1:CustomFieldLinkForProjectData", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_CustomFieldLinkForProjectDataArray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CustomFieldLinkForProjectData(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct CustomFieldLinkForProjectDataArray * SOAP_FMAC4 soap_in_CustomFieldLinkForProjectDataArray(struct soap *soap, const char *tag, struct CustomFieldLinkForProjectDataArray *a, const char *type)
{	int i, j;
	struct ns1__CustomFieldLinkForProjectData **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct CustomFieldLinkForProjectDataArray *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_CustomFieldLinkForProjectDataArray, sizeof(struct CustomFieldLinkForProjectDataArray), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_CustomFieldLinkForProjectDataArray(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__CustomFieldLinkForProjectData **)soap_malloc(soap, sizeof(struct ns1__CustomFieldLinkForProjectData *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CustomFieldLinkForProjectData(soap, NULL, a->__ptr + i, "ns1:CustomFieldLinkForProjectData"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__CustomFieldLinkForProjectData **)soap_push_block(soap, NULL, sizeof(struct ns1__CustomFieldLinkForProjectData *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CustomFieldLinkForProjectData(soap, NULL, p, "ns1:CustomFieldLinkForProjectData"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns1__CustomFieldLinkForProjectData **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct CustomFieldLinkForProjectDataArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_CustomFieldLinkForProjectDataArray, 0, sizeof(struct CustomFieldLinkForProjectDataArray), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_CustomFieldLinkForProjectDataArray(struct soap *soap, const struct CustomFieldLinkForProjectDataArray *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_CustomFieldLinkForProjectDataArray);
	if (soap_out_CustomFieldLinkForProjectDataArray(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct CustomFieldLinkForProjectDataArray * SOAP_FMAC4 soap_get_CustomFieldLinkForProjectDataArray(struct soap *soap, struct CustomFieldLinkForProjectDataArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_CustomFieldLinkForProjectDataArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_CustomFieldDefinitionDataArray(struct soap *soap, struct CustomFieldDefinitionDataArray *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_CustomFieldDefinitionDataArray(struct soap *soap, struct CustomFieldDefinitionDataArray const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_CustomFieldDefinitionDataArray))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__CustomFieldDefinitionData(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_CustomFieldDefinitionDataArray(struct soap *soap, const char *tag, int id, const struct CustomFieldDefinitionDataArray *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "ns1:CustomFieldDefinitionData", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_CustomFieldDefinitionDataArray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CustomFieldDefinitionData(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct CustomFieldDefinitionDataArray * SOAP_FMAC4 soap_in_CustomFieldDefinitionDataArray(struct soap *soap, const char *tag, struct CustomFieldDefinitionDataArray *a, const char *type)
{	int i, j;
	struct ns1__CustomFieldDefinitionData **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct CustomFieldDefinitionDataArray *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_CustomFieldDefinitionDataArray, sizeof(struct CustomFieldDefinitionDataArray), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_CustomFieldDefinitionDataArray(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__CustomFieldDefinitionData **)soap_malloc(soap, sizeof(struct ns1__CustomFieldDefinitionData *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CustomFieldDefinitionData(soap, NULL, a->__ptr + i, "ns1:CustomFieldDefinitionData"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__CustomFieldDefinitionData **)soap_push_block(soap, NULL, sizeof(struct ns1__CustomFieldDefinitionData *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CustomFieldDefinitionData(soap, NULL, p, "ns1:CustomFieldDefinitionData"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns1__CustomFieldDefinitionData **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct CustomFieldDefinitionDataArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_CustomFieldDefinitionDataArray, 0, sizeof(struct CustomFieldDefinitionDataArray), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_CustomFieldDefinitionDataArray(struct soap *soap, const struct CustomFieldDefinitionDataArray *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_CustomFieldDefinitionDataArray);
	if (soap_out_CustomFieldDefinitionDataArray(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct CustomFieldDefinitionDataArray * SOAP_FMAC4 soap_get_CustomFieldDefinitionDataArray(struct soap *soap, struct CustomFieldDefinitionDataArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_CustomFieldDefinitionDataArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_FilterDataArray(struct soap *soap, struct FilterDataArray *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_FilterDataArray(struct soap *soap, struct FilterDataArray const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_FilterDataArray))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__FilterData(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_FilterDataArray(struct soap *soap, const char *tag, int id, const struct FilterDataArray *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "ns1:FilterData", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_FilterDataArray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__FilterData(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct FilterDataArray * SOAP_FMAC4 soap_in_FilterDataArray(struct soap *soap, const char *tag, struct FilterDataArray *a, const char *type)
{	int i, j;
	struct ns1__FilterData **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct FilterDataArray *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_FilterDataArray, sizeof(struct FilterDataArray), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_FilterDataArray(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__FilterData **)soap_malloc(soap, sizeof(struct ns1__FilterData *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__FilterData(soap, NULL, a->__ptr + i, "ns1:FilterData"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__FilterData **)soap_push_block(soap, NULL, sizeof(struct ns1__FilterData *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__FilterData(soap, NULL, p, "ns1:FilterData"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns1__FilterData **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct FilterDataArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_FilterDataArray, 0, sizeof(struct FilterDataArray), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_FilterDataArray(struct soap *soap, const struct FilterDataArray *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_FilterDataArray);
	if (soap_out_FilterDataArray(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct FilterDataArray * SOAP_FMAC4 soap_get_FilterDataArray(struct soap *soap, struct FilterDataArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_FilterDataArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ProjectVersionDataArray(struct soap *soap, struct ProjectVersionDataArray *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ProjectVersionDataArray(struct soap *soap, struct ProjectVersionDataArray const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_ProjectVersionDataArray))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__ProjectVersionData(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ProjectVersionDataArray(struct soap *soap, const char *tag, int id, const struct ProjectVersionDataArray *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "ns1:ProjectVersionData", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ProjectVersionDataArray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__ProjectVersionData(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ProjectVersionDataArray * SOAP_FMAC4 soap_in_ProjectVersionDataArray(struct soap *soap, const char *tag, struct ProjectVersionDataArray *a, const char *type)
{	int i, j;
	struct ns1__ProjectVersionData **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ProjectVersionDataArray *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ProjectVersionDataArray, sizeof(struct ProjectVersionDataArray), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ProjectVersionDataArray(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__ProjectVersionData **)soap_malloc(soap, sizeof(struct ns1__ProjectVersionData *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__ProjectVersionData(soap, NULL, a->__ptr + i, "ns1:ProjectVersionData"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__ProjectVersionData **)soap_push_block(soap, NULL, sizeof(struct ns1__ProjectVersionData *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__ProjectVersionData(soap, NULL, p, "ns1:ProjectVersionData"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns1__ProjectVersionData **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ProjectVersionDataArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ProjectVersionDataArray, 0, sizeof(struct ProjectVersionDataArray), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ProjectVersionDataArray(struct soap *soap, const struct ProjectVersionDataArray *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ProjectVersionDataArray);
	if (soap_out_ProjectVersionDataArray(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ProjectVersionDataArray * SOAP_FMAC4 soap_get_ProjectVersionDataArray(struct soap *soap, struct ProjectVersionDataArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_ProjectVersionDataArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_IssueHeaderDataArray(struct soap *soap, struct IssueHeaderDataArray *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_IssueHeaderDataArray(struct soap *soap, struct IssueHeaderDataArray const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_IssueHeaderDataArray))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__IssueHeaderData(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_IssueHeaderDataArray(struct soap *soap, const char *tag, int id, const struct IssueHeaderDataArray *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "ns1:IssueHeaderData", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_IssueHeaderDataArray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__IssueHeaderData(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct IssueHeaderDataArray * SOAP_FMAC4 soap_in_IssueHeaderDataArray(struct soap *soap, const char *tag, struct IssueHeaderDataArray *a, const char *type)
{	int i, j;
	struct ns1__IssueHeaderData **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct IssueHeaderDataArray *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_IssueHeaderDataArray, sizeof(struct IssueHeaderDataArray), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_IssueHeaderDataArray(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__IssueHeaderData **)soap_malloc(soap, sizeof(struct ns1__IssueHeaderData *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__IssueHeaderData(soap, NULL, a->__ptr + i, "ns1:IssueHeaderData"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__IssueHeaderData **)soap_push_block(soap, NULL, sizeof(struct ns1__IssueHeaderData *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__IssueHeaderData(soap, NULL, p, "ns1:IssueHeaderData"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns1__IssueHeaderData **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct IssueHeaderDataArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_IssueHeaderDataArray, 0, sizeof(struct IssueHeaderDataArray), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_IssueHeaderDataArray(struct soap *soap, const struct IssueHeaderDataArray *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_IssueHeaderDataArray);
	if (soap_out_IssueHeaderDataArray(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct IssueHeaderDataArray * SOAP_FMAC4 soap_get_IssueHeaderDataArray(struct soap *soap, struct IssueHeaderDataArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_IssueHeaderDataArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_IssueDataArray(struct soap *soap, struct IssueDataArray *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_IssueDataArray(struct soap *soap, struct IssueDataArray const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_IssueDataArray))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__IssueData(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_IssueDataArray(struct soap *soap, const char *tag, int id, const struct IssueDataArray *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "ns1:IssueData", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_IssueDataArray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__IssueData(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct IssueDataArray * SOAP_FMAC4 soap_in_IssueDataArray(struct soap *soap, const char *tag, struct IssueDataArray *a, const char *type)
{	int i, j;
	struct ns1__IssueData **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct IssueDataArray *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_IssueDataArray, sizeof(struct IssueDataArray), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_IssueDataArray(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__IssueData **)soap_malloc(soap, sizeof(struct ns1__IssueData *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__IssueData(soap, NULL, a->__ptr + i, "ns1:IssueData"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__IssueData **)soap_push_block(soap, NULL, sizeof(struct ns1__IssueData *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__IssueData(soap, NULL, p, "ns1:IssueData"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns1__IssueData **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct IssueDataArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_IssueDataArray, 0, sizeof(struct IssueDataArray), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_IssueDataArray(struct soap *soap, const struct IssueDataArray *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_IssueDataArray);
	if (soap_out_IssueDataArray(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct IssueDataArray * SOAP_FMAC4 soap_get_IssueDataArray(struct soap *soap, struct IssueDataArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_IssueDataArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ProjectAttachmentDataArray(struct soap *soap, struct ProjectAttachmentDataArray *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ProjectAttachmentDataArray(struct soap *soap, struct ProjectAttachmentDataArray const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_ProjectAttachmentDataArray))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__ProjectAttachmentData(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ProjectAttachmentDataArray(struct soap *soap, const char *tag, int id, const struct ProjectAttachmentDataArray *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "ns1:ProjectAttachmentData", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ProjectAttachmentDataArray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__ProjectAttachmentData(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ProjectAttachmentDataArray * SOAP_FMAC4 soap_in_ProjectAttachmentDataArray(struct soap *soap, const char *tag, struct ProjectAttachmentDataArray *a, const char *type)
{	int i, j;
	struct ns1__ProjectAttachmentData **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ProjectAttachmentDataArray *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ProjectAttachmentDataArray, sizeof(struct ProjectAttachmentDataArray), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ProjectAttachmentDataArray(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__ProjectAttachmentData **)soap_malloc(soap, sizeof(struct ns1__ProjectAttachmentData *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__ProjectAttachmentData(soap, NULL, a->__ptr + i, "ns1:ProjectAttachmentData"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__ProjectAttachmentData **)soap_push_block(soap, NULL, sizeof(struct ns1__ProjectAttachmentData *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__ProjectAttachmentData(soap, NULL, p, "ns1:ProjectAttachmentData"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns1__ProjectAttachmentData **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ProjectAttachmentDataArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ProjectAttachmentDataArray, 0, sizeof(struct ProjectAttachmentDataArray), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ProjectAttachmentDataArray(struct soap *soap, const struct ProjectAttachmentDataArray *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ProjectAttachmentDataArray);
	if (soap_out_ProjectAttachmentDataArray(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ProjectAttachmentDataArray * SOAP_FMAC4 soap_get_ProjectAttachmentDataArray(struct soap *soap, struct ProjectAttachmentDataArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_ProjectAttachmentDataArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_AccountDataArray(struct soap *soap, struct AccountDataArray *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_AccountDataArray(struct soap *soap, struct AccountDataArray const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_AccountDataArray))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__AccountData(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_AccountDataArray(struct soap *soap, const char *tag, int id, const struct AccountDataArray *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "ns1:AccountData", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_AccountDataArray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__AccountData(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct AccountDataArray * SOAP_FMAC4 soap_in_AccountDataArray(struct soap *soap, const char *tag, struct AccountDataArray *a, const char *type)
{	int i, j;
	struct ns1__AccountData **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct AccountDataArray *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_AccountDataArray, sizeof(struct AccountDataArray), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_AccountDataArray(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__AccountData **)soap_malloc(soap, sizeof(struct ns1__AccountData *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__AccountData(soap, NULL, a->__ptr + i, "ns1:AccountData"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__AccountData **)soap_push_block(soap, NULL, sizeof(struct ns1__AccountData *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__AccountData(soap, NULL, p, "ns1:AccountData"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns1__AccountData **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct AccountDataArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_AccountDataArray, 0, sizeof(struct AccountDataArray), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_AccountDataArray(struct soap *soap, const struct AccountDataArray *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_AccountDataArray);
	if (soap_out_AccountDataArray(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct AccountDataArray * SOAP_FMAC4 soap_get_AccountDataArray(struct soap *soap, struct AccountDataArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_AccountDataArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ObjectRefArray(struct soap *soap, struct ObjectRefArray *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ObjectRefArray(struct soap *soap, struct ObjectRefArray const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_ObjectRefArray))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__ObjectRef(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ObjectRefArray(struct soap *soap, const char *tag, int id, const struct ObjectRefArray *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "ns1:ObjectRef", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ObjectRefArray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__ObjectRef(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ObjectRefArray * SOAP_FMAC4 soap_in_ObjectRefArray(struct soap *soap, const char *tag, struct ObjectRefArray *a, const char *type)
{	int i, j;
	struct ns1__ObjectRef **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ObjectRefArray *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ObjectRefArray, sizeof(struct ObjectRefArray), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ObjectRefArray(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__ObjectRef **)soap_malloc(soap, sizeof(struct ns1__ObjectRef *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__ObjectRef(soap, NULL, a->__ptr + i, "ns1:ObjectRef"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__ObjectRef **)soap_push_block(soap, NULL, sizeof(struct ns1__ObjectRef *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__ObjectRef(soap, NULL, p, "ns1:ObjectRef"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns1__ObjectRef **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ObjectRefArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ObjectRefArray, 0, sizeof(struct ObjectRefArray), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ObjectRefArray(struct soap *soap, const struct ObjectRefArray *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ObjectRefArray);
	if (soap_out_ObjectRefArray(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ObjectRefArray * SOAP_FMAC4 soap_get_ObjectRefArray(struct soap *soap, struct ObjectRefArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_ObjectRefArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_StringArray(struct soap *soap, struct StringArray *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_StringArray(struct soap *soap, struct StringArray const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_StringArray))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_string(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_StringArray(struct soap *soap, const char *tag, int id, const struct StringArray *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "xsd:string", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_StringArray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_string(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct StringArray * SOAP_FMAC4 soap_in_StringArray(struct soap *soap, const char *tag, struct StringArray *a, const char *type)
{	int i, j;
	char **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct StringArray *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_StringArray, sizeof(struct StringArray), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_StringArray(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (char **)soap_malloc(soap, sizeof(char *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_string(soap, NULL, a->__ptr + i, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (char **)soap_push_block(soap, NULL, sizeof(char *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_string(soap, NULL, p, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (char **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct StringArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_StringArray, 0, sizeof(struct StringArray), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_StringArray(struct soap *soap, const struct StringArray *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_StringArray);
	if (soap_out_StringArray(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct StringArray * SOAP_FMAC4 soap_get_StringArray(struct soap *soap, struct StringArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_StringArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__CustomFieldValueForIssueData(struct soap *soap, struct ns1__CustomFieldValueForIssueData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->field = NULL;
	soap_default_string(soap, &a->value);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__CustomFieldValueForIssueData(struct soap *soap, const struct ns1__CustomFieldValueForIssueData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ObjectRef(soap, &a->field);
	soap_serialize_string(soap, &a->value);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CustomFieldValueForIssueData(struct soap *soap, const char *tag, int id, const struct ns1__CustomFieldValueForIssueData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CustomFieldValueForIssueData), type))
		return soap->error;
	if (soap_out_PointerTons1__ObjectRef(soap, "field", -1, &a->field, ""))
		return soap->error;
	if (soap_out_string(soap, "value", -1, &a->value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__CustomFieldValueForIssueData * SOAP_FMAC4 soap_in_ns1__CustomFieldValueForIssueData(struct soap *soap, const char *tag, struct ns1__CustomFieldValueForIssueData *a, const char *type)
{
	size_t soap_flag_field = 1;
	size_t soap_flag_value = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__CustomFieldValueForIssueData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CustomFieldValueForIssueData, sizeof(struct ns1__CustomFieldValueForIssueData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__CustomFieldValueForIssueData(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_field && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ObjectRef(soap, "field", &a->field, "ns1:ObjectRef"))
				{	soap_flag_field--;
					continue;
				}
			if (soap_flag_value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "value", &a->value, "xsd:string"))
				{	soap_flag_value--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__CustomFieldValueForIssueData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CustomFieldValueForIssueData, 0, sizeof(struct ns1__CustomFieldValueForIssueData), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__CustomFieldValueForIssueData(struct soap *soap, const struct ns1__CustomFieldValueForIssueData *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__CustomFieldValueForIssueData);
	if (soap_out_ns1__CustomFieldValueForIssueData(soap, tag?tag:"ns1:CustomFieldValueForIssueData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__CustomFieldValueForIssueData * SOAP_FMAC4 soap_get_ns1__CustomFieldValueForIssueData(struct soap *soap, struct ns1__CustomFieldValueForIssueData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CustomFieldValueForIssueData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__CustomFieldLinkForProjectData(struct soap *soap, struct ns1__CustomFieldLinkForProjectData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->field = NULL;
	a->sequence = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__CustomFieldLinkForProjectData(struct soap *soap, const struct ns1__CustomFieldLinkForProjectData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ObjectRef(soap, &a->field);
	soap_serialize_PointerToxsd__byte(soap, &a->sequence);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CustomFieldLinkForProjectData(struct soap *soap, const char *tag, int id, const struct ns1__CustomFieldLinkForProjectData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CustomFieldLinkForProjectData), type))
		return soap->error;
	if (soap_out_PointerTons1__ObjectRef(soap, "field", -1, &a->field, ""))
		return soap->error;
	if (soap_out_PointerToxsd__byte(soap, "sequence", -1, &a->sequence, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__CustomFieldLinkForProjectData * SOAP_FMAC4 soap_in_ns1__CustomFieldLinkForProjectData(struct soap *soap, const char *tag, struct ns1__CustomFieldLinkForProjectData *a, const char *type)
{
	size_t soap_flag_field = 1;
	size_t soap_flag_sequence = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__CustomFieldLinkForProjectData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CustomFieldLinkForProjectData, sizeof(struct ns1__CustomFieldLinkForProjectData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__CustomFieldLinkForProjectData(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_field && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ObjectRef(soap, "field", &a->field, "ns1:ObjectRef"))
				{	soap_flag_field--;
					continue;
				}
			if (soap_flag_sequence && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__byte(soap, "sequence", &a->sequence, "xsd:byte"))
				{	soap_flag_sequence--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__CustomFieldLinkForProjectData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CustomFieldLinkForProjectData, 0, sizeof(struct ns1__CustomFieldLinkForProjectData), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__CustomFieldLinkForProjectData(struct soap *soap, const struct ns1__CustomFieldLinkForProjectData *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__CustomFieldLinkForProjectData);
	if (soap_out_ns1__CustomFieldLinkForProjectData(soap, tag?tag:"ns1:CustomFieldLinkForProjectData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__CustomFieldLinkForProjectData * SOAP_FMAC4 soap_get_ns1__CustomFieldLinkForProjectData(struct soap *soap, struct ns1__CustomFieldLinkForProjectData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CustomFieldLinkForProjectData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__CustomFieldDefinitionData(struct soap *soap, struct ns1__CustomFieldDefinitionData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->field = NULL;
	soap_default_xsd__integer(soap, &a->type);
	soap_default_string(soap, &a->possible_USCOREvalues);
	soap_default_string(soap, &a->default_USCOREvalue);
	soap_default_string(soap, &a->valid_USCOREregexp);
	soap_default_xsd__integer(soap, &a->access_USCORElevel_USCOREr);
	soap_default_xsd__integer(soap, &a->access_USCORElevel_USCORErw);
	soap_default_xsd__integer(soap, &a->length_USCOREmin);
	soap_default_xsd__integer(soap, &a->length_USCOREmax);
	a->advanced = NULL;
	a->display_USCOREreport = NULL;
	a->display_USCOREupdate = NULL;
	a->display_USCOREresolved = NULL;
	a->display_USCOREclosed = NULL;
	a->require_USCOREreport = NULL;
	a->require_USCOREupdate = NULL;
	a->require_USCOREresolved = NULL;
	a->require_USCOREclosed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__CustomFieldDefinitionData(struct soap *soap, const struct ns1__CustomFieldDefinitionData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ObjectRef(soap, &a->field);
	soap_serialize_xsd__integer(soap, &a->type);
	soap_serialize_string(soap, &a->possible_USCOREvalues);
	soap_serialize_string(soap, &a->default_USCOREvalue);
	soap_serialize_string(soap, &a->valid_USCOREregexp);
	soap_serialize_xsd__integer(soap, &a->access_USCORElevel_USCOREr);
	soap_serialize_xsd__integer(soap, &a->access_USCORElevel_USCORErw);
	soap_serialize_xsd__integer(soap, &a->length_USCOREmin);
	soap_serialize_xsd__integer(soap, &a->length_USCOREmax);
	soap_serialize_PointerToxsd__boolean(soap, &a->advanced);
	soap_serialize_PointerToxsd__boolean(soap, &a->display_USCOREreport);
	soap_serialize_PointerToxsd__boolean(soap, &a->display_USCOREupdate);
	soap_serialize_PointerToxsd__boolean(soap, &a->display_USCOREresolved);
	soap_serialize_PointerToxsd__boolean(soap, &a->display_USCOREclosed);
	soap_serialize_PointerToxsd__boolean(soap, &a->require_USCOREreport);
	soap_serialize_PointerToxsd__boolean(soap, &a->require_USCOREupdate);
	soap_serialize_PointerToxsd__boolean(soap, &a->require_USCOREresolved);
	soap_serialize_PointerToxsd__boolean(soap, &a->require_USCOREclosed);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CustomFieldDefinitionData(struct soap *soap, const char *tag, int id, const struct ns1__CustomFieldDefinitionData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CustomFieldDefinitionData), type))
		return soap->error;
	if (soap_out_PointerTons1__ObjectRef(soap, "field", -1, &a->field, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "type", -1, &a->type, ""))
		return soap->error;
	if (soap_out_string(soap, "possible_values", -1, &a->possible_USCOREvalues, ""))
		return soap->error;
	if (soap_out_string(soap, "default_value", -1, &a->default_USCOREvalue, ""))
		return soap->error;
	if (soap_out_string(soap, "valid_regexp", -1, &a->valid_USCOREregexp, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "access_level_r", -1, &a->access_USCORElevel_USCOREr, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "access_level_rw", -1, &a->access_USCORElevel_USCORErw, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "length_min", -1, &a->length_USCOREmin, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "length_max", -1, &a->length_USCOREmax, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "advanced", -1, &a->advanced, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "display_report", -1, &a->display_USCOREreport, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "display_update", -1, &a->display_USCOREupdate, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "display_resolved", -1, &a->display_USCOREresolved, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "display_closed", -1, &a->display_USCOREclosed, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "require_report", -1, &a->require_USCOREreport, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "require_update", -1, &a->require_USCOREupdate, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "require_resolved", -1, &a->require_USCOREresolved, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "require_closed", -1, &a->require_USCOREclosed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__CustomFieldDefinitionData * SOAP_FMAC4 soap_in_ns1__CustomFieldDefinitionData(struct soap *soap, const char *tag, struct ns1__CustomFieldDefinitionData *a, const char *type)
{
	size_t soap_flag_field = 1;
	size_t soap_flag_type = 1;
	size_t soap_flag_possible_USCOREvalues = 1;
	size_t soap_flag_default_USCOREvalue = 1;
	size_t soap_flag_valid_USCOREregexp = 1;
	size_t soap_flag_access_USCORElevel_USCOREr = 1;
	size_t soap_flag_access_USCORElevel_USCORErw = 1;
	size_t soap_flag_length_USCOREmin = 1;
	size_t soap_flag_length_USCOREmax = 1;
	size_t soap_flag_advanced = 1;
	size_t soap_flag_display_USCOREreport = 1;
	size_t soap_flag_display_USCOREupdate = 1;
	size_t soap_flag_display_USCOREresolved = 1;
	size_t soap_flag_display_USCOREclosed = 1;
	size_t soap_flag_require_USCOREreport = 1;
	size_t soap_flag_require_USCOREupdate = 1;
	size_t soap_flag_require_USCOREresolved = 1;
	size_t soap_flag_require_USCOREclosed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__CustomFieldDefinitionData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CustomFieldDefinitionData, sizeof(struct ns1__CustomFieldDefinitionData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__CustomFieldDefinitionData(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_field && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ObjectRef(soap, "field", &a->field, "ns1:ObjectRef"))
				{	soap_flag_field--;
					continue;
				}
			if (soap_flag_type && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "type", &a->type, "xsd:integer"))
				{	soap_flag_type--;
					continue;
				}
			if (soap_flag_possible_USCOREvalues && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "possible_values", &a->possible_USCOREvalues, "xsd:string"))
				{	soap_flag_possible_USCOREvalues--;
					continue;
				}
			if (soap_flag_default_USCOREvalue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "default_value", &a->default_USCOREvalue, "xsd:string"))
				{	soap_flag_default_USCOREvalue--;
					continue;
				}
			if (soap_flag_valid_USCOREregexp && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "valid_regexp", &a->valid_USCOREregexp, "xsd:string"))
				{	soap_flag_valid_USCOREregexp--;
					continue;
				}
			if (soap_flag_access_USCORElevel_USCOREr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "access_level_r", &a->access_USCORElevel_USCOREr, "xsd:integer"))
				{	soap_flag_access_USCORElevel_USCOREr--;
					continue;
				}
			if (soap_flag_access_USCORElevel_USCORErw && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "access_level_rw", &a->access_USCORElevel_USCORErw, "xsd:integer"))
				{	soap_flag_access_USCORElevel_USCORErw--;
					continue;
				}
			if (soap_flag_length_USCOREmin && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "length_min", &a->length_USCOREmin, "xsd:integer"))
				{	soap_flag_length_USCOREmin--;
					continue;
				}
			if (soap_flag_length_USCOREmax && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "length_max", &a->length_USCOREmax, "xsd:integer"))
				{	soap_flag_length_USCOREmax--;
					continue;
				}
			if (soap_flag_advanced && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "advanced", &a->advanced, "xsd:boolean"))
				{	soap_flag_advanced--;
					continue;
				}
			if (soap_flag_display_USCOREreport && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "display_report", &a->display_USCOREreport, "xsd:boolean"))
				{	soap_flag_display_USCOREreport--;
					continue;
				}
			if (soap_flag_display_USCOREupdate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "display_update", &a->display_USCOREupdate, "xsd:boolean"))
				{	soap_flag_display_USCOREupdate--;
					continue;
				}
			if (soap_flag_display_USCOREresolved && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "display_resolved", &a->display_USCOREresolved, "xsd:boolean"))
				{	soap_flag_display_USCOREresolved--;
					continue;
				}
			if (soap_flag_display_USCOREclosed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "display_closed", &a->display_USCOREclosed, "xsd:boolean"))
				{	soap_flag_display_USCOREclosed--;
					continue;
				}
			if (soap_flag_require_USCOREreport && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "require_report", &a->require_USCOREreport, "xsd:boolean"))
				{	soap_flag_require_USCOREreport--;
					continue;
				}
			if (soap_flag_require_USCOREupdate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "require_update", &a->require_USCOREupdate, "xsd:boolean"))
				{	soap_flag_require_USCOREupdate--;
					continue;
				}
			if (soap_flag_require_USCOREresolved && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "require_resolved", &a->require_USCOREresolved, "xsd:boolean"))
				{	soap_flag_require_USCOREresolved--;
					continue;
				}
			if (soap_flag_require_USCOREclosed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "require_closed", &a->require_USCOREclosed, "xsd:boolean"))
				{	soap_flag_require_USCOREclosed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__CustomFieldDefinitionData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CustomFieldDefinitionData, 0, sizeof(struct ns1__CustomFieldDefinitionData), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__CustomFieldDefinitionData(struct soap *soap, const struct ns1__CustomFieldDefinitionData *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__CustomFieldDefinitionData);
	if (soap_out_ns1__CustomFieldDefinitionData(soap, tag?tag:"ns1:CustomFieldDefinitionData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__CustomFieldDefinitionData * SOAP_FMAC4 soap_get_ns1__CustomFieldDefinitionData(struct soap *soap, struct ns1__CustomFieldDefinitionData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CustomFieldDefinitionData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__FilterData(struct soap *soap, struct ns1__FilterData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__integer(soap, &a->id);
	a->owner = NULL;
	soap_default_xsd__integer(soap, &a->project_USCOREid);
	a->is_USCOREpublic = NULL;
	soap_default_string(soap, &a->name);
	soap_default_string(soap, &a->filter_USCOREstring);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__FilterData(struct soap *soap, const struct ns1__FilterData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__integer(soap, &a->id);
	soap_serialize_PointerTons1__AccountData(soap, &a->owner);
	soap_serialize_xsd__integer(soap, &a->project_USCOREid);
	soap_serialize_PointerToxsd__boolean(soap, &a->is_USCOREpublic);
	soap_serialize_string(soap, &a->name);
	soap_serialize_string(soap, &a->filter_USCOREstring);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FilterData(struct soap *soap, const char *tag, int id, const struct ns1__FilterData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__FilterData), type))
		return soap->error;
	if (soap_out_xsd__integer(soap, "id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_PointerTons1__AccountData(soap, "owner", -1, &a->owner, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "project_id", -1, &a->project_USCOREid, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "is_public", -1, &a->is_USCOREpublic, ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->name, ""))
		return soap->error;
	if (soap_out_string(soap, "filter_string", -1, &a->filter_USCOREstring, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__FilterData * SOAP_FMAC4 soap_in_ns1__FilterData(struct soap *soap, const char *tag, struct ns1__FilterData *a, const char *type)
{
	size_t soap_flag_id = 1;
	size_t soap_flag_owner = 1;
	size_t soap_flag_project_USCOREid = 1;
	size_t soap_flag_is_USCOREpublic = 1;
	size_t soap_flag_name = 1;
	size_t soap_flag_filter_USCOREstring = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__FilterData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FilterData, sizeof(struct ns1__FilterData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__FilterData(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "id", &a->id, "xsd:integer"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_owner && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AccountData(soap, "owner", &a->owner, "ns1:AccountData"))
				{	soap_flag_owner--;
					continue;
				}
			if (soap_flag_project_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "project_id", &a->project_USCOREid, "xsd:integer"))
				{	soap_flag_project_USCOREid--;
					continue;
				}
			if (soap_flag_is_USCOREpublic && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "is_public", &a->is_USCOREpublic, "xsd:boolean"))
				{	soap_flag_is_USCOREpublic--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_filter_USCOREstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "filter_string", &a->filter_USCOREstring, "xsd:string"))
				{	soap_flag_filter_USCOREstring--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__FilterData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__FilterData, 0, sizeof(struct ns1__FilterData), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__FilterData(struct soap *soap, const struct ns1__FilterData *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__FilterData);
	if (soap_out_ns1__FilterData(soap, tag?tag:"ns1:FilterData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__FilterData * SOAP_FMAC4 soap_get_ns1__FilterData(struct soap *soap, struct ns1__FilterData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FilterData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ProjectVersionData(struct soap *soap, struct ns1__ProjectVersionData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__integer(soap, &a->id);
	soap_default_string(soap, &a->name);
	soap_default_xsd__integer(soap, &a->project_USCOREid);
	a->date_USCOREorder = NULL;
	soap_default_string(soap, &a->description);
	a->released = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ProjectVersionData(struct soap *soap, const struct ns1__ProjectVersionData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__integer(soap, &a->id);
	soap_serialize_string(soap, &a->name);
	soap_serialize_xsd__integer(soap, &a->project_USCOREid);
	soap_serialize_PointerTotime(soap, &a->date_USCOREorder);
	soap_serialize_string(soap, &a->description);
	soap_serialize_PointerToxsd__boolean(soap, &a->released);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ProjectVersionData(struct soap *soap, const char *tag, int id, const struct ns1__ProjectVersionData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ProjectVersionData), type))
		return soap->error;
	if (soap_out_xsd__integer(soap, "id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->name, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "project_id", -1, &a->project_USCOREid, ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "date_order", -1, &a->date_USCOREorder, ""))
		return soap->error;
	if (soap_out_string(soap, "description", -1, &a->description, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "released", -1, &a->released, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ProjectVersionData * SOAP_FMAC4 soap_in_ns1__ProjectVersionData(struct soap *soap, const char *tag, struct ns1__ProjectVersionData *a, const char *type)
{
	size_t soap_flag_id = 1;
	size_t soap_flag_name = 1;
	size_t soap_flag_project_USCOREid = 1;
	size_t soap_flag_date_USCOREorder = 1;
	size_t soap_flag_description = 1;
	size_t soap_flag_released = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ProjectVersionData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ProjectVersionData, sizeof(struct ns1__ProjectVersionData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ProjectVersionData(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "id", &a->id, "xsd:integer"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_project_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "project_id", &a->project_USCOREid, "xsd:integer"))
				{	soap_flag_project_USCOREid--;
					continue;
				}
			if (soap_flag_date_USCOREorder && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "date_order", &a->date_USCOREorder, "xsd:dateTime"))
				{	soap_flag_date_USCOREorder--;
					continue;
				}
			if (soap_flag_description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "description", &a->description, "xsd:string"))
				{	soap_flag_description--;
					continue;
				}
			if (soap_flag_released && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "released", &a->released, "xsd:boolean"))
				{	soap_flag_released--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ProjectVersionData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ProjectVersionData, 0, sizeof(struct ns1__ProjectVersionData), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ProjectVersionData(struct soap *soap, const struct ns1__ProjectVersionData *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ProjectVersionData);
	if (soap_out_ns1__ProjectVersionData(soap, tag?tag:"ns1:ProjectVersionData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ProjectVersionData * SOAP_FMAC4 soap_get_ns1__ProjectVersionData(struct soap *soap, struct ns1__ProjectVersionData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ProjectVersionData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ProjectDataArray(struct soap *soap, struct ProjectDataArray *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ProjectDataArray(struct soap *soap, struct ProjectDataArray const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_ProjectDataArray))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__ProjectData(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ProjectDataArray(struct soap *soap, const char *tag, int id, const struct ProjectDataArray *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "ns1:ProjectData", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ProjectDataArray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__ProjectData(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ProjectDataArray * SOAP_FMAC4 soap_in_ProjectDataArray(struct soap *soap, const char *tag, struct ProjectDataArray *a, const char *type)
{	int i, j;
	struct ns1__ProjectData **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ProjectDataArray *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ProjectDataArray, sizeof(struct ProjectDataArray), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ProjectDataArray(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__ProjectData **)soap_malloc(soap, sizeof(struct ns1__ProjectData *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__ProjectData(soap, NULL, a->__ptr + i, "ns1:ProjectData"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__ProjectData **)soap_push_block(soap, NULL, sizeof(struct ns1__ProjectData *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__ProjectData(soap, NULL, p, "ns1:ProjectData"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns1__ProjectData **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ProjectDataArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ProjectDataArray, 0, sizeof(struct ProjectDataArray), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ProjectDataArray(struct soap *soap, const struct ProjectDataArray *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ProjectDataArray);
	if (soap_out_ProjectDataArray(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ProjectDataArray * SOAP_FMAC4 soap_get_ProjectDataArray(struct soap *soap, struct ProjectDataArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_ProjectDataArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ProjectData(struct soap *soap, struct ns1__ProjectData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__integer(soap, &a->id);
	soap_default_string(soap, &a->name);
	a->status = NULL;
	a->enabled = NULL;
	a->view_USCOREstate = NULL;
	a->access_USCOREmin = NULL;
	soap_default_string(soap, &a->file_USCOREpath);
	soap_default_string(soap, &a->description);
	a->subprojects = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ProjectData(struct soap *soap, const struct ns1__ProjectData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__integer(soap, &a->id);
	soap_serialize_string(soap, &a->name);
	soap_serialize_PointerTons1__ObjectRef(soap, &a->status);
	soap_serialize_PointerToxsd__boolean(soap, &a->enabled);
	soap_serialize_PointerTons1__ObjectRef(soap, &a->view_USCOREstate);
	soap_serialize_PointerTons1__ObjectRef(soap, &a->access_USCOREmin);
	soap_serialize_string(soap, &a->file_USCOREpath);
	soap_serialize_string(soap, &a->description);
	soap_serialize_PointerToProjectDataArray(soap, &a->subprojects);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ProjectData(struct soap *soap, const char *tag, int id, const struct ns1__ProjectData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ProjectData), type))
		return soap->error;
	if (soap_out_xsd__integer(soap, "id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->name, ""))
		return soap->error;
	if (soap_out_PointerTons1__ObjectRef(soap, "status", -1, &a->status, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "enabled", -1, &a->enabled, ""))
		return soap->error;
	if (soap_out_PointerTons1__ObjectRef(soap, "view_state", -1, &a->view_USCOREstate, ""))
		return soap->error;
	if (soap_out_PointerTons1__ObjectRef(soap, "access_min", -1, &a->access_USCOREmin, ""))
		return soap->error;
	if (soap_out_string(soap, "file_path", -1, &a->file_USCOREpath, ""))
		return soap->error;
	if (soap_out_string(soap, "description", -1, &a->description, ""))
		return soap->error;
	if (soap_out_PointerToProjectDataArray(soap, "subprojects", -1, &a->subprojects, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ProjectData * SOAP_FMAC4 soap_in_ns1__ProjectData(struct soap *soap, const char *tag, struct ns1__ProjectData *a, const char *type)
{
	size_t soap_flag_id = 1;
	size_t soap_flag_name = 1;
	size_t soap_flag_status = 1;
	size_t soap_flag_enabled = 1;
	size_t soap_flag_view_USCOREstate = 1;
	size_t soap_flag_access_USCOREmin = 1;
	size_t soap_flag_file_USCOREpath = 1;
	size_t soap_flag_description = 1;
	size_t soap_flag_subprojects = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ProjectData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ProjectData, sizeof(struct ns1__ProjectData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ProjectData(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "id", &a->id, "xsd:integer"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ObjectRef(soap, "status", &a->status, "ns1:ObjectRef"))
				{	soap_flag_status--;
					continue;
				}
			if (soap_flag_enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "enabled", &a->enabled, "xsd:boolean"))
				{	soap_flag_enabled--;
					continue;
				}
			if (soap_flag_view_USCOREstate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ObjectRef(soap, "view_state", &a->view_USCOREstate, "ns1:ObjectRef"))
				{	soap_flag_view_USCOREstate--;
					continue;
				}
			if (soap_flag_access_USCOREmin && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ObjectRef(soap, "access_min", &a->access_USCOREmin, "ns1:ObjectRef"))
				{	soap_flag_access_USCOREmin--;
					continue;
				}
			if (soap_flag_file_USCOREpath && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "file_path", &a->file_USCOREpath, "xsd:string"))
				{	soap_flag_file_USCOREpath--;
					continue;
				}
			if (soap_flag_description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "description", &a->description, "xsd:string"))
				{	soap_flag_description--;
					continue;
				}
			if (soap_flag_subprojects && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToProjectDataArray(soap, "subprojects", &a->subprojects, "ns1:ProjectData"))
				{	soap_flag_subprojects--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ProjectData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ProjectData, 0, sizeof(struct ns1__ProjectData), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ProjectData(struct soap *soap, const struct ns1__ProjectData *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ProjectData);
	if (soap_out_ns1__ProjectData(soap, tag?tag:"ns1:ProjectData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ProjectData * SOAP_FMAC4 soap_get_ns1__ProjectData(struct soap *soap, struct ns1__ProjectData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ProjectData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__IssueHeaderData(struct soap *soap, struct ns1__IssueHeaderData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__integer(soap, &a->id);
	soap_default_xsd__integer(soap, &a->view_USCOREstate);
	soap_default_time(soap, &a->last_USCOREupdated);
	soap_default_xsd__integer(soap, &a->project);
	soap_default_string(soap, &a->category);
	soap_default_xsd__integer(soap, &a->priority);
	soap_default_xsd__integer(soap, &a->severity);
	soap_default_xsd__integer(soap, &a->status);
	soap_default_xsd__integer(soap, &a->reporter);
	soap_default_string(soap, &a->summary);
	soap_default_xsd__integer(soap, &a->handler);
	soap_default_xsd__integer(soap, &a->resolution);
	soap_default_xsd__integer(soap, &a->attachments_USCOREcount);
	soap_default_xsd__integer(soap, &a->notes_USCOREcount);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__IssueHeaderData(struct soap *soap, const struct ns1__IssueHeaderData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__integer(soap, &a->id);
	soap_serialize_xsd__integer(soap, &a->view_USCOREstate);
	soap_embedded(soap, &a->last_USCOREupdated, SOAP_TYPE_time);
	soap_serialize_xsd__integer(soap, &a->project);
	soap_serialize_string(soap, &a->category);
	soap_serialize_xsd__integer(soap, &a->priority);
	soap_serialize_xsd__integer(soap, &a->severity);
	soap_serialize_xsd__integer(soap, &a->status);
	soap_serialize_xsd__integer(soap, &a->reporter);
	soap_serialize_string(soap, &a->summary);
	soap_serialize_xsd__integer(soap, &a->handler);
	soap_serialize_xsd__integer(soap, &a->resolution);
	soap_serialize_xsd__integer(soap, &a->attachments_USCOREcount);
	soap_serialize_xsd__integer(soap, &a->notes_USCOREcount);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__IssueHeaderData(struct soap *soap, const char *tag, int id, const struct ns1__IssueHeaderData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__IssueHeaderData), type))
		return soap->error;
	if (soap_out_xsd__integer(soap, "id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "view_state", -1, &a->view_USCOREstate, ""))
		return soap->error;
	if (soap_out_time(soap, "last_updated", -1, &a->last_USCOREupdated, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "project", -1, &a->project, ""))
		return soap->error;
	if (soap_out_string(soap, "category", -1, &a->category, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "priority", -1, &a->priority, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "severity", -1, &a->severity, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "status", -1, &a->status, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "reporter", -1, &a->reporter, ""))
		return soap->error;
	if (soap_out_string(soap, "summary", -1, &a->summary, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "handler", -1, &a->handler, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "resolution", -1, &a->resolution, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "attachments_count", -1, &a->attachments_USCOREcount, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "notes_count", -1, &a->notes_USCOREcount, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__IssueHeaderData * SOAP_FMAC4 soap_in_ns1__IssueHeaderData(struct soap *soap, const char *tag, struct ns1__IssueHeaderData *a, const char *type)
{
	size_t soap_flag_id = 1;
	size_t soap_flag_view_USCOREstate = 1;
	size_t soap_flag_last_USCOREupdated = 1;
	size_t soap_flag_project = 1;
	size_t soap_flag_category = 1;
	size_t soap_flag_priority = 1;
	size_t soap_flag_severity = 1;
	size_t soap_flag_status = 1;
	size_t soap_flag_reporter = 1;
	size_t soap_flag_summary = 1;
	size_t soap_flag_handler = 1;
	size_t soap_flag_resolution = 1;
	size_t soap_flag_attachments_USCOREcount = 1;
	size_t soap_flag_notes_USCOREcount = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__IssueHeaderData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__IssueHeaderData, sizeof(struct ns1__IssueHeaderData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__IssueHeaderData(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "id", &a->id, "xsd:integer"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_view_USCOREstate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "view_state", &a->view_USCOREstate, "xsd:integer"))
				{	soap_flag_view_USCOREstate--;
					continue;
				}
			if (soap_flag_last_USCOREupdated && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "last_updated", &a->last_USCOREupdated, "xsd:dateTime"))
				{	soap_flag_last_USCOREupdated--;
					continue;
				}
			if (soap_flag_project && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "project", &a->project, "xsd:integer"))
				{	soap_flag_project--;
					continue;
				}
			if (soap_flag_category && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "category", &a->category, "xsd:string"))
				{	soap_flag_category--;
					continue;
				}
			if (soap_flag_priority && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "priority", &a->priority, "xsd:integer"))
				{	soap_flag_priority--;
					continue;
				}
			if (soap_flag_severity && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "severity", &a->severity, "xsd:integer"))
				{	soap_flag_severity--;
					continue;
				}
			if (soap_flag_status && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "status", &a->status, "xsd:integer"))
				{	soap_flag_status--;
					continue;
				}
			if (soap_flag_reporter && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "reporter", &a->reporter, "xsd:integer"))
				{	soap_flag_reporter--;
					continue;
				}
			if (soap_flag_summary && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "summary", &a->summary, "xsd:string"))
				{	soap_flag_summary--;
					continue;
				}
			if (soap_flag_handler && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "handler", &a->handler, "xsd:integer"))
				{	soap_flag_handler--;
					continue;
				}
			if (soap_flag_resolution && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "resolution", &a->resolution, "xsd:integer"))
				{	soap_flag_resolution--;
					continue;
				}
			if (soap_flag_attachments_USCOREcount && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "attachments_count", &a->attachments_USCOREcount, "xsd:integer"))
				{	soap_flag_attachments_USCOREcount--;
					continue;
				}
			if (soap_flag_notes_USCOREcount && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "notes_count", &a->notes_USCOREcount, "xsd:integer"))
				{	soap_flag_notes_USCOREcount--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__IssueHeaderData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__IssueHeaderData, 0, sizeof(struct ns1__IssueHeaderData), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0 || soap_flag_view_USCOREstate > 0 || soap_flag_last_USCOREupdated > 0 || soap_flag_project > 0 || soap_flag_category > 0 || soap_flag_priority > 0 || soap_flag_severity > 0 || soap_flag_status > 0 || soap_flag_reporter > 0 || soap_flag_summary > 0 || soap_flag_handler > 0 || soap_flag_resolution > 0 || soap_flag_attachments_USCOREcount > 0 || soap_flag_notes_USCOREcount > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__IssueHeaderData(struct soap *soap, const struct ns1__IssueHeaderData *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__IssueHeaderData);
	if (soap_out_ns1__IssueHeaderData(soap, tag?tag:"ns1:IssueHeaderData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__IssueHeaderData * SOAP_FMAC4 soap_get_ns1__IssueHeaderData(struct soap *soap, struct ns1__IssueHeaderData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__IssueHeaderData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_CustomFieldValueForIssueDataArray(struct soap *soap, struct CustomFieldValueForIssueDataArray *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_CustomFieldValueForIssueDataArray(struct soap *soap, struct CustomFieldValueForIssueDataArray const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_CustomFieldValueForIssueDataArray))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__CustomFieldValueForIssueData(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_CustomFieldValueForIssueDataArray(struct soap *soap, const char *tag, int id, const struct CustomFieldValueForIssueDataArray *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "ns1:CustomFieldValueForIssueData", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_CustomFieldValueForIssueDataArray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CustomFieldValueForIssueData(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct CustomFieldValueForIssueDataArray * SOAP_FMAC4 soap_in_CustomFieldValueForIssueDataArray(struct soap *soap, const char *tag, struct CustomFieldValueForIssueDataArray *a, const char *type)
{	int i, j;
	struct ns1__CustomFieldValueForIssueData **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct CustomFieldValueForIssueDataArray *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_CustomFieldValueForIssueDataArray, sizeof(struct CustomFieldValueForIssueDataArray), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_CustomFieldValueForIssueDataArray(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__CustomFieldValueForIssueData **)soap_malloc(soap, sizeof(struct ns1__CustomFieldValueForIssueData *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CustomFieldValueForIssueData(soap, NULL, a->__ptr + i, "ns1:CustomFieldValueForIssueData"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__CustomFieldValueForIssueData **)soap_push_block(soap, NULL, sizeof(struct ns1__CustomFieldValueForIssueData *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CustomFieldValueForIssueData(soap, NULL, p, "ns1:CustomFieldValueForIssueData"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns1__CustomFieldValueForIssueData **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct CustomFieldValueForIssueDataArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_CustomFieldValueForIssueDataArray, 0, sizeof(struct CustomFieldValueForIssueDataArray), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_CustomFieldValueForIssueDataArray(struct soap *soap, const struct CustomFieldValueForIssueDataArray *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_CustomFieldValueForIssueDataArray);
	if (soap_out_CustomFieldValueForIssueDataArray(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct CustomFieldValueForIssueDataArray * SOAP_FMAC4 soap_get_CustomFieldValueForIssueDataArray(struct soap *soap, struct CustomFieldValueForIssueDataArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_CustomFieldValueForIssueDataArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_IssueNoteDataArray(struct soap *soap, struct IssueNoteDataArray *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_IssueNoteDataArray(struct soap *soap, struct IssueNoteDataArray const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_IssueNoteDataArray))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__IssueNoteData(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_IssueNoteDataArray(struct soap *soap, const char *tag, int id, const struct IssueNoteDataArray *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "ns1:IssueNoteData", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_IssueNoteDataArray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__IssueNoteData(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct IssueNoteDataArray * SOAP_FMAC4 soap_in_IssueNoteDataArray(struct soap *soap, const char *tag, struct IssueNoteDataArray *a, const char *type)
{	int i, j;
	struct ns1__IssueNoteData **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct IssueNoteDataArray *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_IssueNoteDataArray, sizeof(struct IssueNoteDataArray), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_IssueNoteDataArray(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__IssueNoteData **)soap_malloc(soap, sizeof(struct ns1__IssueNoteData *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__IssueNoteData(soap, NULL, a->__ptr + i, "ns1:IssueNoteData"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__IssueNoteData **)soap_push_block(soap, NULL, sizeof(struct ns1__IssueNoteData *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__IssueNoteData(soap, NULL, p, "ns1:IssueNoteData"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns1__IssueNoteData **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct IssueNoteDataArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_IssueNoteDataArray, 0, sizeof(struct IssueNoteDataArray), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_IssueNoteDataArray(struct soap *soap, const struct IssueNoteDataArray *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_IssueNoteDataArray);
	if (soap_out_IssueNoteDataArray(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct IssueNoteDataArray * SOAP_FMAC4 soap_get_IssueNoteDataArray(struct soap *soap, struct IssueNoteDataArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_IssueNoteDataArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_RelationshipDataArray(struct soap *soap, struct RelationshipDataArray *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_RelationshipDataArray(struct soap *soap, struct RelationshipDataArray const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_RelationshipDataArray))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__RelationshipData(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_RelationshipDataArray(struct soap *soap, const char *tag, int id, const struct RelationshipDataArray *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "ns1:RelationshipData", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_RelationshipDataArray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__RelationshipData(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct RelationshipDataArray * SOAP_FMAC4 soap_in_RelationshipDataArray(struct soap *soap, const char *tag, struct RelationshipDataArray *a, const char *type)
{	int i, j;
	struct ns1__RelationshipData **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct RelationshipDataArray *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_RelationshipDataArray, sizeof(struct RelationshipDataArray), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_RelationshipDataArray(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__RelationshipData **)soap_malloc(soap, sizeof(struct ns1__RelationshipData *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__RelationshipData(soap, NULL, a->__ptr + i, "ns1:RelationshipData"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__RelationshipData **)soap_push_block(soap, NULL, sizeof(struct ns1__RelationshipData *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__RelationshipData(soap, NULL, p, "ns1:RelationshipData"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns1__RelationshipData **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct RelationshipDataArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_RelationshipDataArray, 0, sizeof(struct RelationshipDataArray), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_RelationshipDataArray(struct soap *soap, const struct RelationshipDataArray *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_RelationshipDataArray);
	if (soap_out_RelationshipDataArray(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct RelationshipDataArray * SOAP_FMAC4 soap_get_RelationshipDataArray(struct soap *soap, struct RelationshipDataArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_RelationshipDataArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_AttachmentDataArray(struct soap *soap, struct AttachmentDataArray *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_AttachmentDataArray(struct soap *soap, struct AttachmentDataArray const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_AttachmentDataArray))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__AttachmentData(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_AttachmentDataArray(struct soap *soap, const char *tag, int id, const struct AttachmentDataArray *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "ns1:AttachmentData", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_AttachmentDataArray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__AttachmentData(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct AttachmentDataArray * SOAP_FMAC4 soap_in_AttachmentDataArray(struct soap *soap, const char *tag, struct AttachmentDataArray *a, const char *type)
{	int i, j;
	struct ns1__AttachmentData **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct AttachmentDataArray *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_AttachmentDataArray, sizeof(struct AttachmentDataArray), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_AttachmentDataArray(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__AttachmentData **)soap_malloc(soap, sizeof(struct ns1__AttachmentData *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__AttachmentData(soap, NULL, a->__ptr + i, "ns1:AttachmentData"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__AttachmentData **)soap_push_block(soap, NULL, sizeof(struct ns1__AttachmentData *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__AttachmentData(soap, NULL, p, "ns1:AttachmentData"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct ns1__AttachmentData **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct AttachmentDataArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_AttachmentDataArray, 0, sizeof(struct AttachmentDataArray), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_AttachmentDataArray(struct soap *soap, const struct AttachmentDataArray *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_AttachmentDataArray);
	if (soap_out_AttachmentDataArray(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct AttachmentDataArray * SOAP_FMAC4 soap_get_AttachmentDataArray(struct soap *soap, struct AttachmentDataArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_AttachmentDataArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__IssueData(struct soap *soap, struct ns1__IssueData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__integer(soap, &a->id);
	a->view_USCOREstate = NULL;
	a->last_USCOREupdated = NULL;
	a->project = NULL;
	soap_default_string(soap, &a->category);
	a->priority = NULL;
	a->severity = NULL;
	a->status = NULL;
	a->reporter = NULL;
	soap_default_string(soap, &a->summary);
	soap_default_string(soap, &a->version);
	soap_default_string(soap, &a->build);
	soap_default_string(soap, &a->platform);
	soap_default_string(soap, &a->os);
	soap_default_string(soap, &a->os_USCOREbuild);
	a->reproducibility = NULL;
	a->date_USCOREsubmitted = NULL;
	soap_default_xsd__integer(soap, &a->sponsorship_USCOREtotal);
	a->handler = NULL;
	a->projection = NULL;
	a->eta = NULL;
	a->resolution = NULL;
	soap_default_string(soap, &a->fixed_USCOREin_USCOREversion);
	soap_default_string(soap, &a->description);
	soap_default_string(soap, &a->steps_USCOREto_USCOREreproduce);
	soap_default_string(soap, &a->additional_USCOREinformation);
	a->attachments = NULL;
	a->relationships = NULL;
	a->notes = NULL;
	a->custom_USCOREfields = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__IssueData(struct soap *soap, const struct ns1__IssueData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__integer(soap, &a->id);
	soap_serialize_PointerTons1__ObjectRef(soap, &a->view_USCOREstate);
	soap_serialize_PointerTotime(soap, &a->last_USCOREupdated);
	soap_serialize_PointerTons1__ObjectRef(soap, &a->project);
	soap_serialize_string(soap, &a->category);
	soap_serialize_PointerTons1__ObjectRef(soap, &a->priority);
	soap_serialize_PointerTons1__ObjectRef(soap, &a->severity);
	soap_serialize_PointerTons1__ObjectRef(soap, &a->status);
	soap_serialize_PointerTons1__AccountData(soap, &a->reporter);
	soap_serialize_string(soap, &a->summary);
	soap_serialize_string(soap, &a->version);
	soap_serialize_string(soap, &a->build);
	soap_serialize_string(soap, &a->platform);
	soap_serialize_string(soap, &a->os);
	soap_serialize_string(soap, &a->os_USCOREbuild);
	soap_serialize_PointerTons1__ObjectRef(soap, &a->reproducibility);
	soap_serialize_PointerTotime(soap, &a->date_USCOREsubmitted);
	soap_serialize_xsd__integer(soap, &a->sponsorship_USCOREtotal);
	soap_serialize_PointerTons1__AccountData(soap, &a->handler);
	soap_serialize_PointerTons1__ObjectRef(soap, &a->projection);
	soap_serialize_PointerTons1__ObjectRef(soap, &a->eta);
	soap_serialize_PointerTons1__ObjectRef(soap, &a->resolution);
	soap_serialize_string(soap, &a->fixed_USCOREin_USCOREversion);
	soap_serialize_string(soap, &a->description);
	soap_serialize_string(soap, &a->steps_USCOREto_USCOREreproduce);
	soap_serialize_string(soap, &a->additional_USCOREinformation);
	soap_serialize_PointerToAttachmentDataArray(soap, &a->attachments);
	soap_serialize_PointerToRelationshipDataArray(soap, &a->relationships);
	soap_serialize_PointerToIssueNoteDataArray(soap, &a->notes);
	soap_serialize_PointerToCustomFieldValueForIssueDataArray(soap, &a->custom_USCOREfields);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__IssueData(struct soap *soap, const char *tag, int id, const struct ns1__IssueData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__IssueData), type))
		return soap->error;
	if (soap_out_xsd__integer(soap, "id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_PointerTons1__ObjectRef(soap, "view_state", -1, &a->view_USCOREstate, ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "last_updated", -1, &a->last_USCOREupdated, ""))
		return soap->error;
	if (soap_out_PointerTons1__ObjectRef(soap, "project", -1, &a->project, ""))
		return soap->error;
	if (soap_out_string(soap, "category", -1, &a->category, ""))
		return soap->error;
	if (soap_out_PointerTons1__ObjectRef(soap, "priority", -1, &a->priority, ""))
		return soap->error;
	if (soap_out_PointerTons1__ObjectRef(soap, "severity", -1, &a->severity, ""))
		return soap->error;
	if (soap_out_PointerTons1__ObjectRef(soap, "status", -1, &a->status, ""))
		return soap->error;
	if (soap_out_PointerTons1__AccountData(soap, "reporter", -1, &a->reporter, ""))
		return soap->error;
	if (soap_out_string(soap, "summary", -1, &a->summary, ""))
		return soap->error;
	if (soap_out_string(soap, "version", -1, &a->version, ""))
		return soap->error;
	if (soap_out_string(soap, "build", -1, &a->build, ""))
		return soap->error;
	if (soap_out_string(soap, "platform", -1, &a->platform, ""))
		return soap->error;
	if (soap_out_string(soap, "os", -1, &a->os, ""))
		return soap->error;
	if (soap_out_string(soap, "os_build", -1, &a->os_USCOREbuild, ""))
		return soap->error;
	if (soap_out_PointerTons1__ObjectRef(soap, "reproducibility", -1, &a->reproducibility, ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "date_submitted", -1, &a->date_USCOREsubmitted, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "sponsorship_total", -1, &a->sponsorship_USCOREtotal, ""))
		return soap->error;
	if (soap_out_PointerTons1__AccountData(soap, "handler", -1, &a->handler, ""))
		return soap->error;
	if (soap_out_PointerTons1__ObjectRef(soap, "projection", -1, &a->projection, ""))
		return soap->error;
	if (soap_out_PointerTons1__ObjectRef(soap, "eta", -1, &a->eta, ""))
		return soap->error;
	if (soap_out_PointerTons1__ObjectRef(soap, "resolution", -1, &a->resolution, ""))
		return soap->error;
	if (soap_out_string(soap, "fixed_in_version", -1, &a->fixed_USCOREin_USCOREversion, ""))
		return soap->error;
	if (soap_out_string(soap, "description", -1, &a->description, ""))
		return soap->error;
	if (soap_out_string(soap, "steps_to_reproduce", -1, &a->steps_USCOREto_USCOREreproduce, ""))
		return soap->error;
	if (soap_out_string(soap, "additional_information", -1, &a->additional_USCOREinformation, ""))
		return soap->error;
	if (soap_out_PointerToAttachmentDataArray(soap, "attachments", -1, &a->attachments, ""))
		return soap->error;
	if (soap_out_PointerToRelationshipDataArray(soap, "relationships", -1, &a->relationships, ""))
		return soap->error;
	if (soap_out_PointerToIssueNoteDataArray(soap, "notes", -1, &a->notes, ""))
		return soap->error;
	if (soap_out_PointerToCustomFieldValueForIssueDataArray(soap, "custom_fields", -1, &a->custom_USCOREfields, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__IssueData * SOAP_FMAC4 soap_in_ns1__IssueData(struct soap *soap, const char *tag, struct ns1__IssueData *a, const char *type)
{
	size_t soap_flag_id = 1;
	size_t soap_flag_view_USCOREstate = 1;
	size_t soap_flag_last_USCOREupdated = 1;
	size_t soap_flag_project = 1;
	size_t soap_flag_category = 1;
	size_t soap_flag_priority = 1;
	size_t soap_flag_severity = 1;
	size_t soap_flag_status = 1;
	size_t soap_flag_reporter = 1;
	size_t soap_flag_summary = 1;
	size_t soap_flag_version = 1;
	size_t soap_flag_build = 1;
	size_t soap_flag_platform = 1;
	size_t soap_flag_os = 1;
	size_t soap_flag_os_USCOREbuild = 1;
	size_t soap_flag_reproducibility = 1;
	size_t soap_flag_date_USCOREsubmitted = 1;
	size_t soap_flag_sponsorship_USCOREtotal = 1;
	size_t soap_flag_handler = 1;
	size_t soap_flag_projection = 1;
	size_t soap_flag_eta = 1;
	size_t soap_flag_resolution = 1;
	size_t soap_flag_fixed_USCOREin_USCOREversion = 1;
	size_t soap_flag_description = 1;
	size_t soap_flag_steps_USCOREto_USCOREreproduce = 1;
	size_t soap_flag_additional_USCOREinformation = 1;
	size_t soap_flag_attachments = 1;
	size_t soap_flag_relationships = 1;
	size_t soap_flag_notes = 1;
	size_t soap_flag_custom_USCOREfields = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__IssueData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__IssueData, sizeof(struct ns1__IssueData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__IssueData(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "id", &a->id, "xsd:integer"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_view_USCOREstate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ObjectRef(soap, "view_state", &a->view_USCOREstate, "ns1:ObjectRef"))
				{	soap_flag_view_USCOREstate--;
					continue;
				}
			if (soap_flag_last_USCOREupdated && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "last_updated", &a->last_USCOREupdated, "xsd:dateTime"))
				{	soap_flag_last_USCOREupdated--;
					continue;
				}
			if (soap_flag_project && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ObjectRef(soap, "project", &a->project, "ns1:ObjectRef"))
				{	soap_flag_project--;
					continue;
				}
			if (soap_flag_category && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "category", &a->category, "xsd:string"))
				{	soap_flag_category--;
					continue;
				}
			if (soap_flag_priority && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ObjectRef(soap, "priority", &a->priority, "ns1:ObjectRef"))
				{	soap_flag_priority--;
					continue;
				}
			if (soap_flag_severity && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ObjectRef(soap, "severity", &a->severity, "ns1:ObjectRef"))
				{	soap_flag_severity--;
					continue;
				}
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ObjectRef(soap, "status", &a->status, "ns1:ObjectRef"))
				{	soap_flag_status--;
					continue;
				}
			if (soap_flag_reporter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AccountData(soap, "reporter", &a->reporter, "ns1:AccountData"))
				{	soap_flag_reporter--;
					continue;
				}
			if (soap_flag_summary && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "summary", &a->summary, "xsd:string"))
				{	soap_flag_summary--;
					continue;
				}
			if (soap_flag_version && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "version", &a->version, "xsd:string"))
				{	soap_flag_version--;
					continue;
				}
			if (soap_flag_build && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "build", &a->build, "xsd:string"))
				{	soap_flag_build--;
					continue;
				}
			if (soap_flag_platform && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "platform", &a->platform, "xsd:string"))
				{	soap_flag_platform--;
					continue;
				}
			if (soap_flag_os && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "os", &a->os, "xsd:string"))
				{	soap_flag_os--;
					continue;
				}
			if (soap_flag_os_USCOREbuild && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "os_build", &a->os_USCOREbuild, "xsd:string"))
				{	soap_flag_os_USCOREbuild--;
					continue;
				}
			if (soap_flag_reproducibility && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ObjectRef(soap, "reproducibility", &a->reproducibility, "ns1:ObjectRef"))
				{	soap_flag_reproducibility--;
					continue;
				}
			if (soap_flag_date_USCOREsubmitted && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "date_submitted", &a->date_USCOREsubmitted, "xsd:dateTime"))
				{	soap_flag_date_USCOREsubmitted--;
					continue;
				}
			if (soap_flag_sponsorship_USCOREtotal && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "sponsorship_total", &a->sponsorship_USCOREtotal, "xsd:integer"))
				{	soap_flag_sponsorship_USCOREtotal--;
					continue;
				}
			if (soap_flag_handler && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AccountData(soap, "handler", &a->handler, "ns1:AccountData"))
				{	soap_flag_handler--;
					continue;
				}
			if (soap_flag_projection && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ObjectRef(soap, "projection", &a->projection, "ns1:ObjectRef"))
				{	soap_flag_projection--;
					continue;
				}
			if (soap_flag_eta && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ObjectRef(soap, "eta", &a->eta, "ns1:ObjectRef"))
				{	soap_flag_eta--;
					continue;
				}
			if (soap_flag_resolution && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ObjectRef(soap, "resolution", &a->resolution, "ns1:ObjectRef"))
				{	soap_flag_resolution--;
					continue;
				}
			if (soap_flag_fixed_USCOREin_USCOREversion && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "fixed_in_version", &a->fixed_USCOREin_USCOREversion, "xsd:string"))
				{	soap_flag_fixed_USCOREin_USCOREversion--;
					continue;
				}
			if (soap_flag_description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "description", &a->description, "xsd:string"))
				{	soap_flag_description--;
					continue;
				}
			if (soap_flag_steps_USCOREto_USCOREreproduce && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "steps_to_reproduce", &a->steps_USCOREto_USCOREreproduce, "xsd:string"))
				{	soap_flag_steps_USCOREto_USCOREreproduce--;
					continue;
				}
			if (soap_flag_additional_USCOREinformation && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "additional_information", &a->additional_USCOREinformation, "xsd:string"))
				{	soap_flag_additional_USCOREinformation--;
					continue;
				}
			if (soap_flag_attachments && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToAttachmentDataArray(soap, "attachments", &a->attachments, "ns1:AttachmentData"))
				{	soap_flag_attachments--;
					continue;
				}
			if (soap_flag_relationships && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToRelationshipDataArray(soap, "relationships", &a->relationships, "ns1:RelationshipData"))
				{	soap_flag_relationships--;
					continue;
				}
			if (soap_flag_notes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToIssueNoteDataArray(soap, "notes", &a->notes, "ns1:IssueNoteData"))
				{	soap_flag_notes--;
					continue;
				}
			if (soap_flag_custom_USCOREfields && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToCustomFieldValueForIssueDataArray(soap, "custom_fields", &a->custom_USCOREfields, "ns1:CustomFieldValueForIssueData"))
				{	soap_flag_custom_USCOREfields--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__IssueData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__IssueData, 0, sizeof(struct ns1__IssueData), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__IssueData(struct soap *soap, const struct ns1__IssueData *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__IssueData);
	if (soap_out_ns1__IssueData(soap, tag?tag:"ns1:IssueData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__IssueData * SOAP_FMAC4 soap_get_ns1__IssueData(struct soap *soap, struct ns1__IssueData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__IssueData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__IssueNoteData(struct soap *soap, struct ns1__IssueNoteData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__integer(soap, &a->id);
	a->reporter = NULL;
	soap_default_string(soap, &a->text);
	a->view_USCOREstate = NULL;
	a->date_USCOREsubmitted = NULL;
	a->last_USCOREmodified = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__IssueNoteData(struct soap *soap, const struct ns1__IssueNoteData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__integer(soap, &a->id);
	soap_serialize_PointerTons1__AccountData(soap, &a->reporter);
	soap_serialize_string(soap, &a->text);
	soap_serialize_PointerTons1__ObjectRef(soap, &a->view_USCOREstate);
	soap_serialize_PointerTotime(soap, &a->date_USCOREsubmitted);
	soap_serialize_PointerTotime(soap, &a->last_USCOREmodified);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__IssueNoteData(struct soap *soap, const char *tag, int id, const struct ns1__IssueNoteData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__IssueNoteData), type))
		return soap->error;
	if (soap_out_xsd__integer(soap, "id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_PointerTons1__AccountData(soap, "reporter", -1, &a->reporter, ""))
		return soap->error;
	if (soap_out_string(soap, "text", -1, &a->text, ""))
		return soap->error;
	if (soap_out_PointerTons1__ObjectRef(soap, "view_state", -1, &a->view_USCOREstate, ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "date_submitted", -1, &a->date_USCOREsubmitted, ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "last_modified", -1, &a->last_USCOREmodified, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__IssueNoteData * SOAP_FMAC4 soap_in_ns1__IssueNoteData(struct soap *soap, const char *tag, struct ns1__IssueNoteData *a, const char *type)
{
	size_t soap_flag_id = 1;
	size_t soap_flag_reporter = 1;
	size_t soap_flag_text = 1;
	size_t soap_flag_view_USCOREstate = 1;
	size_t soap_flag_date_USCOREsubmitted = 1;
	size_t soap_flag_last_USCOREmodified = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__IssueNoteData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__IssueNoteData, sizeof(struct ns1__IssueNoteData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__IssueNoteData(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "id", &a->id, "xsd:integer"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_reporter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AccountData(soap, "reporter", &a->reporter, "ns1:AccountData"))
				{	soap_flag_reporter--;
					continue;
				}
			if (soap_flag_text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "text", &a->text, "xsd:string"))
				{	soap_flag_text--;
					continue;
				}
			if (soap_flag_view_USCOREstate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ObjectRef(soap, "view_state", &a->view_USCOREstate, "ns1:ObjectRef"))
				{	soap_flag_view_USCOREstate--;
					continue;
				}
			if (soap_flag_date_USCOREsubmitted && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "date_submitted", &a->date_USCOREsubmitted, "xsd:dateTime"))
				{	soap_flag_date_USCOREsubmitted--;
					continue;
				}
			if (soap_flag_last_USCOREmodified && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "last_modified", &a->last_USCOREmodified, "xsd:dateTime"))
				{	soap_flag_last_USCOREmodified--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__IssueNoteData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__IssueNoteData, 0, sizeof(struct ns1__IssueNoteData), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__IssueNoteData(struct soap *soap, const struct ns1__IssueNoteData *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__IssueNoteData);
	if (soap_out_ns1__IssueNoteData(soap, tag?tag:"ns1:IssueNoteData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__IssueNoteData * SOAP_FMAC4 soap_get_ns1__IssueNoteData(struct soap *soap, struct ns1__IssueNoteData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__IssueNoteData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__RelationshipData(struct soap *soap, struct ns1__RelationshipData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__integer(soap, &a->id);
	a->type = NULL;
	soap_default_xsd__integer(soap, &a->target_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__RelationshipData(struct soap *soap, const struct ns1__RelationshipData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__integer(soap, &a->id);
	soap_serialize_PointerTons1__ObjectRef(soap, &a->type);
	soap_serialize_xsd__integer(soap, &a->target_USCOREid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RelationshipData(struct soap *soap, const char *tag, int id, const struct ns1__RelationshipData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RelationshipData), type))
		return soap->error;
	if (soap_out_xsd__integer(soap, "id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_PointerTons1__ObjectRef(soap, "type", -1, &a->type, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "target_id", -1, &a->target_USCOREid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__RelationshipData * SOAP_FMAC4 soap_in_ns1__RelationshipData(struct soap *soap, const char *tag, struct ns1__RelationshipData *a, const char *type)
{
	size_t soap_flag_id = 1;
	size_t soap_flag_type = 1;
	size_t soap_flag_target_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__RelationshipData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RelationshipData, sizeof(struct ns1__RelationshipData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__RelationshipData(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "id", &a->id, "xsd:integer"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ObjectRef(soap, "type", &a->type, "ns1:ObjectRef"))
				{	soap_flag_type--;
					continue;
				}
			if (soap_flag_target_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "target_id", &a->target_USCOREid, "xsd:integer"))
				{	soap_flag_target_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__RelationshipData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RelationshipData, 0, sizeof(struct ns1__RelationshipData), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__RelationshipData(struct soap *soap, const struct ns1__RelationshipData *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__RelationshipData);
	if (soap_out_ns1__RelationshipData(soap, tag?tag:"ns1:RelationshipData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__RelationshipData * SOAP_FMAC4 soap_get_ns1__RelationshipData(struct soap *soap, struct ns1__RelationshipData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RelationshipData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ProjectAttachmentData(struct soap *soap, struct ns1__ProjectAttachmentData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__integer(soap, &a->id);
	soap_default_string(soap, &a->filename);
	soap_default_string(soap, &a->title);
	soap_default_string(soap, &a->description);
	soap_default_xsd__integer(soap, &a->size);
	soap_default_string(soap, &a->content_USCOREtype);
	a->date_USCOREsubmitted = NULL;
	soap_default_xsd__anyURI(soap, &a->download_USCOREurl);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ProjectAttachmentData(struct soap *soap, const struct ns1__ProjectAttachmentData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__integer(soap, &a->id);
	soap_serialize_string(soap, &a->filename);
	soap_serialize_string(soap, &a->title);
	soap_serialize_string(soap, &a->description);
	soap_serialize_xsd__integer(soap, &a->size);
	soap_serialize_string(soap, &a->content_USCOREtype);
	soap_serialize_PointerTotime(soap, &a->date_USCOREsubmitted);
	soap_serialize_xsd__anyURI(soap, &a->download_USCOREurl);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ProjectAttachmentData(struct soap *soap, const char *tag, int id, const struct ns1__ProjectAttachmentData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ProjectAttachmentData), type))
		return soap->error;
	if (soap_out_xsd__integer(soap, "id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_string(soap, "filename", -1, &a->filename, ""))
		return soap->error;
	if (soap_out_string(soap, "title", -1, &a->title, ""))
		return soap->error;
	if (soap_out_string(soap, "description", -1, &a->description, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "size", -1, &a->size, ""))
		return soap->error;
	if (soap_out_string(soap, "content_type", -1, &a->content_USCOREtype, ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "date_submitted", -1, &a->date_USCOREsubmitted, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "download_url", -1, &a->download_USCOREurl, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ProjectAttachmentData * SOAP_FMAC4 soap_in_ns1__ProjectAttachmentData(struct soap *soap, const char *tag, struct ns1__ProjectAttachmentData *a, const char *type)
{
	size_t soap_flag_id = 1;
	size_t soap_flag_filename = 1;
	size_t soap_flag_title = 1;
	size_t soap_flag_description = 1;
	size_t soap_flag_size = 1;
	size_t soap_flag_content_USCOREtype = 1;
	size_t soap_flag_date_USCOREsubmitted = 1;
	size_t soap_flag_download_USCOREurl = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ProjectAttachmentData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ProjectAttachmentData, sizeof(struct ns1__ProjectAttachmentData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ProjectAttachmentData(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "id", &a->id, "xsd:integer"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_filename && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "filename", &a->filename, "xsd:string"))
				{	soap_flag_filename--;
					continue;
				}
			if (soap_flag_title && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "title", &a->title, "xsd:string"))
				{	soap_flag_title--;
					continue;
				}
			if (soap_flag_description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "description", &a->description, "xsd:string"))
				{	soap_flag_description--;
					continue;
				}
			if (soap_flag_size && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "size", &a->size, "xsd:integer"))
				{	soap_flag_size--;
					continue;
				}
			if (soap_flag_content_USCOREtype && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "content_type", &a->content_USCOREtype, "xsd:string"))
				{	soap_flag_content_USCOREtype--;
					continue;
				}
			if (soap_flag_date_USCOREsubmitted && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "date_submitted", &a->date_USCOREsubmitted, "xsd:dateTime"))
				{	soap_flag_date_USCOREsubmitted--;
					continue;
				}
			if (soap_flag_download_USCOREurl && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "download_url", &a->download_USCOREurl, "xsd:anyURI"))
				{	soap_flag_download_USCOREurl--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ProjectAttachmentData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ProjectAttachmentData, 0, sizeof(struct ns1__ProjectAttachmentData), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ProjectAttachmentData(struct soap *soap, const struct ns1__ProjectAttachmentData *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ProjectAttachmentData);
	if (soap_out_ns1__ProjectAttachmentData(soap, tag?tag:"ns1:ProjectAttachmentData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ProjectAttachmentData * SOAP_FMAC4 soap_get_ns1__ProjectAttachmentData(struct soap *soap, struct ns1__ProjectAttachmentData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ProjectAttachmentData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__AttachmentData(struct soap *soap, struct ns1__AttachmentData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__integer(soap, &a->id);
	soap_default_string(soap, &a->filename);
	soap_default_xsd__integer(soap, &a->size);
	soap_default_string(soap, &a->content_USCOREtype);
	a->date_USCOREsubmitted = NULL;
	soap_default_xsd__anyURI(soap, &a->download_USCOREurl);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__AttachmentData(struct soap *soap, const struct ns1__AttachmentData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__integer(soap, &a->id);
	soap_serialize_string(soap, &a->filename);
	soap_serialize_xsd__integer(soap, &a->size);
	soap_serialize_string(soap, &a->content_USCOREtype);
	soap_serialize_PointerTotime(soap, &a->date_USCOREsubmitted);
	soap_serialize_xsd__anyURI(soap, &a->download_USCOREurl);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AttachmentData(struct soap *soap, const char *tag, int id, const struct ns1__AttachmentData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AttachmentData), type))
		return soap->error;
	if (soap_out_xsd__integer(soap, "id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_string(soap, "filename", -1, &a->filename, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "size", -1, &a->size, ""))
		return soap->error;
	if (soap_out_string(soap, "content_type", -1, &a->content_USCOREtype, ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "date_submitted", -1, &a->date_USCOREsubmitted, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "download_url", -1, &a->download_USCOREurl, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__AttachmentData * SOAP_FMAC4 soap_in_ns1__AttachmentData(struct soap *soap, const char *tag, struct ns1__AttachmentData *a, const char *type)
{
	size_t soap_flag_id = 1;
	size_t soap_flag_filename = 1;
	size_t soap_flag_size = 1;
	size_t soap_flag_content_USCOREtype = 1;
	size_t soap_flag_date_USCOREsubmitted = 1;
	size_t soap_flag_download_USCOREurl = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__AttachmentData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AttachmentData, sizeof(struct ns1__AttachmentData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__AttachmentData(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "id", &a->id, "xsd:integer"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_filename && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "filename", &a->filename, "xsd:string"))
				{	soap_flag_filename--;
					continue;
				}
			if (soap_flag_size && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "size", &a->size, "xsd:integer"))
				{	soap_flag_size--;
					continue;
				}
			if (soap_flag_content_USCOREtype && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "content_type", &a->content_USCOREtype, "xsd:string"))
				{	soap_flag_content_USCOREtype--;
					continue;
				}
			if (soap_flag_date_USCOREsubmitted && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "date_submitted", &a->date_USCOREsubmitted, "xsd:dateTime"))
				{	soap_flag_date_USCOREsubmitted--;
					continue;
				}
			if (soap_flag_download_USCOREurl && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "download_url", &a->download_USCOREurl, "xsd:anyURI"))
				{	soap_flag_download_USCOREurl--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__AttachmentData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AttachmentData, 0, sizeof(struct ns1__AttachmentData), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__AttachmentData(struct soap *soap, const struct ns1__AttachmentData *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__AttachmentData);
	if (soap_out_ns1__AttachmentData(soap, tag?tag:"ns1:AttachmentData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__AttachmentData * SOAP_FMAC4 soap_get_ns1__AttachmentData(struct soap *soap, struct ns1__AttachmentData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AttachmentData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__AccountData(struct soap *soap, struct ns1__AccountData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__integer(soap, &a->id);
	soap_default_string(soap, &a->name);
	soap_default_string(soap, &a->real_USCOREname);
	soap_default_string(soap, &a->email);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__AccountData(struct soap *soap, const struct ns1__AccountData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__integer(soap, &a->id);
	soap_serialize_string(soap, &a->name);
	soap_serialize_string(soap, &a->real_USCOREname);
	soap_serialize_string(soap, &a->email);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AccountData(struct soap *soap, const char *tag, int id, const struct ns1__AccountData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AccountData), type))
		return soap->error;
	if (soap_out_xsd__integer(soap, "id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->name, ""))
		return soap->error;
	if (soap_out_string(soap, "real_name", -1, &a->real_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "email", -1, &a->email, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__AccountData * SOAP_FMAC4 soap_in_ns1__AccountData(struct soap *soap, const char *tag, struct ns1__AccountData *a, const char *type)
{
	size_t soap_flag_id = 1;
	size_t soap_flag_name = 1;
	size_t soap_flag_real_USCOREname = 1;
	size_t soap_flag_email = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__AccountData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AccountData, sizeof(struct ns1__AccountData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__AccountData(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "id", &a->id, "xsd:integer"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_real_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "real_name", &a->real_USCOREname, "xsd:string"))
				{	soap_flag_real_USCOREname--;
					continue;
				}
			if (soap_flag_email && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "email", &a->email, "xsd:string"))
				{	soap_flag_email--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__AccountData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AccountData, 0, sizeof(struct ns1__AccountData), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__AccountData(struct soap *soap, const struct ns1__AccountData *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__AccountData);
	if (soap_out_ns1__AccountData(soap, tag?tag:"ns1:AccountData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__AccountData * SOAP_FMAC4 soap_get_ns1__AccountData(struct soap *soap, struct ns1__AccountData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AccountData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ObjectRef(struct soap *soap, struct ns1__ObjectRef *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__integer(soap, &a->id);
	soap_default_string(soap, &a->name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ObjectRef(struct soap *soap, const struct ns1__ObjectRef *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__integer(soap, &a->id);
	soap_serialize_string(soap, &a->name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ObjectRef(struct soap *soap, const char *tag, int id, const struct ns1__ObjectRef *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ObjectRef), type))
		return soap->error;
	if (soap_out_xsd__integer(soap, "id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ObjectRef * SOAP_FMAC4 soap_in_ns1__ObjectRef(struct soap *soap, const char *tag, struct ns1__ObjectRef *a, const char *type)
{
	size_t soap_flag_id = 1;
	size_t soap_flag_name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ObjectRef *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ObjectRef, sizeof(struct ns1__ObjectRef), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ObjectRef(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "id", &a->id, "xsd:integer"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ObjectRef *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ObjectRef, 0, sizeof(struct ns1__ObjectRef), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ObjectRef(struct soap *soap, const struct ns1__ObjectRef *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ObjectRef);
	if (soap_out_ns1__ObjectRef(soap, tag?tag:"ns1:ObjectRef", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ObjectRef * SOAP_FMAC4 soap_get_ns1__ObjectRef(struct soap *soap, struct ns1__ObjectRef *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ObjectRef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__base64Binary(struct soap *soap, struct xsd__base64Binary *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
	a->id = NULL;
	a->type = NULL;
	a->options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__base64Binary(struct soap *soap, struct xsd__base64Binary const*a)
{
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_xsd__base64Binary))
		if (a->id || a->type)
			soap->mode |= SOAP_ENC_DIME;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const struct xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, (struct soap_array*)&a->__ptr, a->id, a->type, a->options, 1, type, SOAP_TYPE_xsd__base64Binary);
#else
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap *soap, const char *tag, struct xsd__base64Binary *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct xsd__base64Binary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(struct xsd__base64Binary), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xsd__base64Binary(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_dime_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (struct xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__base64Binary, 0, sizeof(struct xsd__base64Binary), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__base64Binary(struct soap *soap, const struct xsd__base64Binary *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_xsd__base64Binary);
	if (soap_out_xsd__base64Binary(soap, tag?tag:"xsd:base64Binary", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, struct xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse(struct soap *soap, struct ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse))
		soap_serialize_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse(struct soap *soap, const char *tag, int id, struct ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse ** SOAP_FMAC4 soap_in_PointerTons1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse **)soap_malloc(soap, sizeof(struct ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse, sizeof(struct ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse(struct soap *soap, struct ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse);
	if (soap_out_PointerTons1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse(soap, tag?tag:"ns1:mc_filter_get_issue_headersResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse ** SOAP_FMAC4 soap_get_PointerTons1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse(struct soap *soap, struct ns1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__mc_USCOREfilter_USCOREget_USCOREissue_USCOREheadersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__mc_USCOREfilter_USCOREget_USCOREissuesResponse(struct soap *soap, struct ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse))
		soap_serialize_ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__mc_USCOREfilter_USCOREget_USCOREissuesResponse(struct soap *soap, const char *tag, int id, struct ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse ** SOAP_FMAC4 soap_in_PointerTons1__mc_USCOREfilter_USCOREget_USCOREissuesResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse **)soap_malloc(soap, sizeof(struct ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse, sizeof(struct ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__mc_USCOREfilter_USCOREget_USCOREissuesResponse(struct soap *soap, struct ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__mc_USCOREfilter_USCOREget_USCOREissuesResponse);
	if (soap_out_PointerTons1__mc_USCOREfilter_USCOREget_USCOREissuesResponse(soap, tag?tag:"ns1:mc_filter_get_issuesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse ** SOAP_FMAC4 soap_get_PointerTons1__mc_USCOREfilter_USCOREget_USCOREissuesResponse(struct soap *soap, struct ns1__mc_USCOREfilter_USCOREget_USCOREissuesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__mc_USCOREfilter_USCOREget_USCOREissuesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__mc_USCOREfilter_USCOREgetResponse(struct soap *soap, struct ns1__mc_USCOREfilter_USCOREgetResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__mc_USCOREfilter_USCOREgetResponse))
		soap_serialize_ns1__mc_USCOREfilter_USCOREgetResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__mc_USCOREfilter_USCOREgetResponse(struct soap *soap, const char *tag, int id, struct ns1__mc_USCOREfilter_USCOREgetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__mc_USCOREfilter_USCOREgetResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__mc_USCOREfilter_USCOREgetResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__mc_USCOREfilter_USCOREgetResponse ** SOAP_FMAC4 soap_in_PointerTons1__mc_USCOREfilter_USCOREgetResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREfilter_USCOREgetResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__mc_USCOREfilter_USCOREgetResponse **)soap_malloc(soap, sizeof(struct ns1__mc_USCOREfilter_USCOREgetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__mc_USCOREfilter_USCOREgetResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREfilter_USCOREgetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__mc_USCOREfilter_USCOREgetResponse, sizeof(struct ns1__mc_USCOREfilter_USCOREgetResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__mc_USCOREfilter_USCOREgetResponse(struct soap *soap, struct ns1__mc_USCOREfilter_USCOREgetResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__mc_USCOREfilter_USCOREgetResponse);
	if (soap_out_PointerTons1__mc_USCOREfilter_USCOREgetResponse(soap, tag?tag:"ns1:mc_filter_getResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREfilter_USCOREgetResponse ** SOAP_FMAC4 soap_get_PointerTons1__mc_USCOREfilter_USCOREgetResponse(struct soap *soap, struct ns1__mc_USCOREfilter_USCOREgetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__mc_USCOREfilter_USCOREgetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToFilterDataArray(struct soap *soap, struct FilterDataArray *const*a)
{
	if (*a)
		soap_serialize_FilterDataArray(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToFilterDataArray(struct soap *soap, const char *tag, int id, struct FilterDataArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_FilterDataArray);
	if (id < 0)
		return soap->error;
	return soap_out_FilterDataArray(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct FilterDataArray ** SOAP_FMAC4 soap_in_PointerToFilterDataArray(struct soap *soap, const char *tag, struct FilterDataArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct FilterDataArray **)soap_malloc(soap, sizeof(struct FilterDataArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_FilterDataArray(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct FilterDataArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_FilterDataArray, sizeof(struct FilterDataArray), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToFilterDataArray(struct soap *soap, struct FilterDataArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToFilterDataArray);
	if (soap_out_PointerToFilterDataArray(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct FilterDataArray ** SOAP_FMAC4 soap_get_PointerToFilterDataArray(struct soap *soap, struct FilterDataArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToFilterDataArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse))
		soap_serialize_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse(struct soap *soap, const char *tag, int id, struct ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse ** SOAP_FMAC4 soap_in_PointerTons1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse **)soap_malloc(soap, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse);
	if (soap_out_PointerTons1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse(soap, tag?tag:"ns1:mc_project_get_custom_fieldsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse ** SOAP_FMAC4 soap_get_PointerTons1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__mc_USCOREproject_USCOREget_USCOREcustom_USCOREfieldsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToCustomFieldDefinitionDataArray(struct soap *soap, struct CustomFieldDefinitionDataArray *const*a)
{
	if (*a)
		soap_serialize_CustomFieldDefinitionDataArray(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToCustomFieldDefinitionDataArray(struct soap *soap, const char *tag, int id, struct CustomFieldDefinitionDataArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_CustomFieldDefinitionDataArray);
	if (id < 0)
		return soap->error;
	return soap_out_CustomFieldDefinitionDataArray(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct CustomFieldDefinitionDataArray ** SOAP_FMAC4 soap_in_PointerToCustomFieldDefinitionDataArray(struct soap *soap, const char *tag, struct CustomFieldDefinitionDataArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct CustomFieldDefinitionDataArray **)soap_malloc(soap, sizeof(struct CustomFieldDefinitionDataArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_CustomFieldDefinitionDataArray(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct CustomFieldDefinitionDataArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_CustomFieldDefinitionDataArray, sizeof(struct CustomFieldDefinitionDataArray), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToCustomFieldDefinitionDataArray(struct soap *soap, struct CustomFieldDefinitionDataArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToCustomFieldDefinitionDataArray);
	if (soap_out_PointerToCustomFieldDefinitionDataArray(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct CustomFieldDefinitionDataArray ** SOAP_FMAC4 soap_get_PointerToCustomFieldDefinitionDataArray(struct soap *soap, struct CustomFieldDefinitionDataArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToCustomFieldDefinitionDataArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse))
		soap_serialize_ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse(struct soap *soap, const char *tag, int id, struct ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse ** SOAP_FMAC4 soap_in_PointerTons1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse **)soap_malloc(soap, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse);
	if (soap_out_PointerTons1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse(soap, tag?tag:"ns1:mc_project_get_attachmentsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse ** SOAP_FMAC4 soap_get_PointerTons1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__mc_USCOREproject_USCOREget_USCOREattachmentsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToProjectAttachmentDataArray(struct soap *soap, struct ProjectAttachmentDataArray *const*a)
{
	if (*a)
		soap_serialize_ProjectAttachmentDataArray(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToProjectAttachmentDataArray(struct soap *soap, const char *tag, int id, struct ProjectAttachmentDataArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ProjectAttachmentDataArray);
	if (id < 0)
		return soap->error;
	return soap_out_ProjectAttachmentDataArray(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ProjectAttachmentDataArray ** SOAP_FMAC4 soap_in_PointerToProjectAttachmentDataArray(struct soap *soap, const char *tag, struct ProjectAttachmentDataArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ProjectAttachmentDataArray **)soap_malloc(soap, sizeof(struct ProjectAttachmentDataArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ProjectAttachmentDataArray(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ProjectAttachmentDataArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ProjectAttachmentDataArray, sizeof(struct ProjectAttachmentDataArray), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToProjectAttachmentDataArray(struct soap *soap, struct ProjectAttachmentDataArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToProjectAttachmentDataArray);
	if (soap_out_PointerToProjectAttachmentDataArray(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ProjectAttachmentDataArray ** SOAP_FMAC4 soap_get_PointerToProjectAttachmentDataArray(struct soap *soap, struct ProjectAttachmentDataArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToProjectAttachmentDataArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse))
		soap_serialize_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse(struct soap *soap, const char *tag, int id, struct ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse ** SOAP_FMAC4 soap_in_PointerTons1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse **)soap_malloc(soap, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse);
	if (soap_out_PointerTons1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse(soap, tag?tag:"ns1:mc_project_get_unreleased_versionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse ** SOAP_FMAC4 soap_get_PointerTons1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__mc_USCOREproject_USCOREget_USCOREunreleased_USCOREversionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse))
		soap_serialize_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse(struct soap *soap, const char *tag, int id, struct ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse ** SOAP_FMAC4 soap_in_PointerTons1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse **)soap_malloc(soap, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse);
	if (soap_out_PointerTons1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse(soap, tag?tag:"ns1:mc_project_get_released_versionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse ** SOAP_FMAC4 soap_get_PointerTons1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__mc_USCOREproject_USCOREget_USCOREreleased_USCOREversionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__mc_USCOREproject_USCOREget_USCOREversionsResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse))
		soap_serialize_ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__mc_USCOREproject_USCOREget_USCOREversionsResponse(struct soap *soap, const char *tag, int id, struct ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse ** SOAP_FMAC4 soap_in_PointerTons1__mc_USCOREproject_USCOREget_USCOREversionsResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse **)soap_malloc(soap, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__mc_USCOREproject_USCOREget_USCOREversionsResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__mc_USCOREproject_USCOREget_USCOREversionsResponse);
	if (soap_out_PointerTons1__mc_USCOREproject_USCOREget_USCOREversionsResponse(soap, tag?tag:"ns1:mc_project_get_versionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse ** SOAP_FMAC4 soap_get_PointerTons1__mc_USCOREproject_USCOREget_USCOREversionsResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREversionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__mc_USCOREproject_USCOREget_USCOREversionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToProjectVersionDataArray(struct soap *soap, struct ProjectVersionDataArray *const*a)
{
	if (*a)
		soap_serialize_ProjectVersionDataArray(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToProjectVersionDataArray(struct soap *soap, const char *tag, int id, struct ProjectVersionDataArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ProjectVersionDataArray);
	if (id < 0)
		return soap->error;
	return soap_out_ProjectVersionDataArray(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ProjectVersionDataArray ** SOAP_FMAC4 soap_in_PointerToProjectVersionDataArray(struct soap *soap, const char *tag, struct ProjectVersionDataArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ProjectVersionDataArray **)soap_malloc(soap, sizeof(struct ProjectVersionDataArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ProjectVersionDataArray(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ProjectVersionDataArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ProjectVersionDataArray, sizeof(struct ProjectVersionDataArray), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToProjectVersionDataArray(struct soap *soap, struct ProjectVersionDataArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToProjectVersionDataArray);
	if (soap_out_PointerToProjectVersionDataArray(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ProjectVersionDataArray ** SOAP_FMAC4 soap_get_PointerToProjectVersionDataArray(struct soap *soap, struct ProjectVersionDataArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToProjectVersionDataArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse))
		soap_serialize_ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse(struct soap *soap, const char *tag, int id, struct ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse ** SOAP_FMAC4 soap_in_PointerTons1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse **)soap_malloc(soap, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse);
	if (soap_out_PointerTons1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse(soap, tag?tag:"ns1:mc_project_get_categoriesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse ** SOAP_FMAC4 soap_get_PointerTons1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__mc_USCOREproject_USCOREget_USCOREcategoriesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToStringArray(struct soap *soap, struct StringArray *const*a)
{
	if (*a)
		soap_serialize_StringArray(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToStringArray(struct soap *soap, const char *tag, int id, struct StringArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_StringArray);
	if (id < 0)
		return soap->error;
	return soap_out_StringArray(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct StringArray ** SOAP_FMAC4 soap_in_PointerToStringArray(struct soap *soap, const char *tag, struct StringArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct StringArray **)soap_malloc(soap, sizeof(struct StringArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_StringArray(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct StringArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_StringArray, sizeof(struct StringArray), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToStringArray(struct soap *soap, struct StringArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToStringArray);
	if (soap_out_PointerToStringArray(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct StringArray ** SOAP_FMAC4 soap_get_PointerToStringArray(struct soap *soap, struct StringArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToStringArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse(struct soap *soap, struct ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse))
		soap_serialize_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse(struct soap *soap, const char *tag, int id, struct ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse ** SOAP_FMAC4 soap_in_PointerTons1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse **)soap_malloc(soap, sizeof(struct ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse, sizeof(struct ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse(struct soap *soap, struct ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse);
	if (soap_out_PointerTons1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse(soap, tag?tag:"ns1:mc_projects_get_user_accessibleResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse ** SOAP_FMAC4 soap_get_PointerTons1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse(struct soap *soap, struct ns1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__mc_USCOREprojects_USCOREget_USCOREuser_USCOREaccessibleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__mc_USCOREproject_USCOREget_USCOREusersResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREusersResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREusersResponse))
		soap_serialize_ns1__mc_USCOREproject_USCOREget_USCOREusersResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__mc_USCOREproject_USCOREget_USCOREusersResponse(struct soap *soap, const char *tag, int id, struct ns1__mc_USCOREproject_USCOREget_USCOREusersResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREusersResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__mc_USCOREproject_USCOREget_USCOREusersResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREusersResponse ** SOAP_FMAC4 soap_in_PointerTons1__mc_USCOREproject_USCOREget_USCOREusersResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREproject_USCOREget_USCOREusersResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__mc_USCOREproject_USCOREget_USCOREusersResponse **)soap_malloc(soap, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREusersResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__mc_USCOREproject_USCOREget_USCOREusersResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREproject_USCOREget_USCOREusersResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREusersResponse, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREusersResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__mc_USCOREproject_USCOREget_USCOREusersResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREusersResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__mc_USCOREproject_USCOREget_USCOREusersResponse);
	if (soap_out_PointerTons1__mc_USCOREproject_USCOREget_USCOREusersResponse(soap, tag?tag:"ns1:mc_project_get_usersResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREusersResponse ** SOAP_FMAC4 soap_get_PointerTons1__mc_USCOREproject_USCOREget_USCOREusersResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREusersResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__mc_USCOREproject_USCOREget_USCOREusersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToAccountDataArray(struct soap *soap, struct AccountDataArray *const*a)
{
	if (*a)
		soap_serialize_AccountDataArray(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToAccountDataArray(struct soap *soap, const char *tag, int id, struct AccountDataArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_AccountDataArray);
	if (id < 0)
		return soap->error;
	return soap_out_AccountDataArray(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct AccountDataArray ** SOAP_FMAC4 soap_in_PointerToAccountDataArray(struct soap *soap, const char *tag, struct AccountDataArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct AccountDataArray **)soap_malloc(soap, sizeof(struct AccountDataArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_AccountDataArray(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct AccountDataArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_AccountDataArray, sizeof(struct AccountDataArray), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToAccountDataArray(struct soap *soap, struct AccountDataArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToAccountDataArray);
	if (soap_out_PointerToAccountDataArray(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct AccountDataArray ** SOAP_FMAC4 soap_get_PointerToAccountDataArray(struct soap *soap, struct AccountDataArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToAccountDataArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse))
		soap_serialize_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse(struct soap *soap, const char *tag, int id, struct ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse ** SOAP_FMAC4 soap_in_PointerTons1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse **)soap_malloc(soap, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse);
	if (soap_out_PointerTons1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse(soap, tag?tag:"ns1:mc_project_get_issue_headersResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse ** SOAP_FMAC4 soap_get_PointerTons1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__mc_USCOREproject_USCOREget_USCOREissue_USCOREheadersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToIssueHeaderDataArray(struct soap *soap, struct IssueHeaderDataArray *const*a)
{
	if (*a)
		soap_serialize_IssueHeaderDataArray(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToIssueHeaderDataArray(struct soap *soap, const char *tag, int id, struct IssueHeaderDataArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_IssueHeaderDataArray);
	if (id < 0)
		return soap->error;
	return soap_out_IssueHeaderDataArray(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct IssueHeaderDataArray ** SOAP_FMAC4 soap_in_PointerToIssueHeaderDataArray(struct soap *soap, const char *tag, struct IssueHeaderDataArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct IssueHeaderDataArray **)soap_malloc(soap, sizeof(struct IssueHeaderDataArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_IssueHeaderDataArray(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct IssueHeaderDataArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_IssueHeaderDataArray, sizeof(struct IssueHeaderDataArray), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToIssueHeaderDataArray(struct soap *soap, struct IssueHeaderDataArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToIssueHeaderDataArray);
	if (soap_out_PointerToIssueHeaderDataArray(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct IssueHeaderDataArray ** SOAP_FMAC4 soap_get_PointerToIssueHeaderDataArray(struct soap *soap, struct IssueHeaderDataArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToIssueHeaderDataArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__mc_USCOREproject_USCOREget_USCOREissuesResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse))
		soap_serialize_ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__mc_USCOREproject_USCOREget_USCOREissuesResponse(struct soap *soap, const char *tag, int id, struct ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse ** SOAP_FMAC4 soap_in_PointerTons1__mc_USCOREproject_USCOREget_USCOREissuesResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse **)soap_malloc(soap, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse, sizeof(struct ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__mc_USCOREproject_USCOREget_USCOREissuesResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__mc_USCOREproject_USCOREget_USCOREissuesResponse);
	if (soap_out_PointerTons1__mc_USCOREproject_USCOREget_USCOREissuesResponse(soap, tag?tag:"ns1:mc_project_get_issuesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse ** SOAP_FMAC4 soap_get_PointerTons1__mc_USCOREproject_USCOREget_USCOREissuesResponse(struct soap *soap, struct ns1__mc_USCOREproject_USCOREget_USCOREissuesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__mc_USCOREproject_USCOREget_USCOREissuesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToIssueDataArray(struct soap *soap, struct IssueDataArray *const*a)
{
	if (*a)
		soap_serialize_IssueDataArray(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToIssueDataArray(struct soap *soap, const char *tag, int id, struct IssueDataArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_IssueDataArray);
	if (id < 0)
		return soap->error;
	return soap_out_IssueDataArray(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct IssueDataArray ** SOAP_FMAC4 soap_in_PointerToIssueDataArray(struct soap *soap, const char *tag, struct IssueDataArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct IssueDataArray **)soap_malloc(soap, sizeof(struct IssueDataArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_IssueDataArray(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct IssueDataArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_IssueDataArray, sizeof(struct IssueDataArray), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToIssueDataArray(struct soap *soap, struct IssueDataArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToIssueDataArray);
	if (soap_out_PointerToIssueDataArray(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct IssueDataArray ** SOAP_FMAC4 soap_get_PointerToIssueDataArray(struct soap *soap, struct IssueDataArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToIssueDataArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__base64Binary(struct soap *soap, struct xsd__base64Binary *const*a)
{
	if (*a)
		soap_serialize_xsd__base64Binary(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__base64Binary(struct soap *soap, const char *tag, int id, struct xsd__base64Binary *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__base64Binary(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xsd__base64Binary ** SOAP_FMAC4 soap_in_PointerToxsd__base64Binary(struct soap *soap, const char *tag, struct xsd__base64Binary **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xsd__base64Binary **)soap_malloc(soap, sizeof(struct xsd__base64Binary *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__base64Binary(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xsd__base64Binary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__base64Binary, sizeof(struct xsd__base64Binary), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__base64Binary(struct soap *soap, struct xsd__base64Binary *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__base64Binary);
	if (soap_out_PointerToxsd__base64Binary(soap, tag?tag:"xsd:base64Binary", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xsd__base64Binary ** SOAP_FMAC4 soap_get_PointerToxsd__base64Binary(struct soap *soap, struct xsd__base64Binary **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__integer(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__integer))
		soap_serialize_xsd__integer(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__integer(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__integer);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__integer(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerToxsd__integer(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__integer(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__integer, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__integer(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__integer);
	if (soap_out_PointerToxsd__integer(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerToxsd__integer(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__integer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__mc_USCOREissue_USCOREgetResponse(struct soap *soap, struct ns1__mc_USCOREissue_USCOREgetResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREgetResponse))
		soap_serialize_ns1__mc_USCOREissue_USCOREgetResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__mc_USCOREissue_USCOREgetResponse(struct soap *soap, const char *tag, int id, struct ns1__mc_USCOREissue_USCOREgetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__mc_USCOREissue_USCOREgetResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__mc_USCOREissue_USCOREgetResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREgetResponse ** SOAP_FMAC4 soap_in_PointerTons1__mc_USCOREissue_USCOREgetResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREissue_USCOREgetResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__mc_USCOREissue_USCOREgetResponse **)soap_malloc(soap, sizeof(struct ns1__mc_USCOREissue_USCOREgetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__mc_USCOREissue_USCOREgetResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREissue_USCOREgetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__mc_USCOREissue_USCOREgetResponse, sizeof(struct ns1__mc_USCOREissue_USCOREgetResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__mc_USCOREissue_USCOREgetResponse(struct soap *soap, struct ns1__mc_USCOREissue_USCOREgetResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__mc_USCOREissue_USCOREgetResponse);
	if (soap_out_PointerTons1__mc_USCOREissue_USCOREgetResponse(soap, tag?tag:"ns1:mc_issue_getResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREissue_USCOREgetResponse ** SOAP_FMAC4 soap_get_PointerTons1__mc_USCOREissue_USCOREgetResponse(struct soap *soap, struct ns1__mc_USCOREissue_USCOREgetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__mc_USCOREissue_USCOREgetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse))
		soap_serialize_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse(struct soap *soap, const char *tag, int id, struct ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse ** SOAP_FMAC4 soap_in_PointerTons1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse **)soap_malloc(soap, sizeof(struct ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse, sizeof(struct ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse);
	if (soap_out_PointerTons1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse(soap, tag?tag:"ns1:mc_enum_custom_field_typesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse ** SOAP_FMAC4 soap_get_PointerTons1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__mc_USCOREenum_USCOREcustom_USCOREfield_USCOREtypesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__mc_USCOREenum_USCOREview_USCOREstatesResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse))
		soap_serialize_ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__mc_USCOREenum_USCOREview_USCOREstatesResponse(struct soap *soap, const char *tag, int id, struct ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse ** SOAP_FMAC4 soap_in_PointerTons1__mc_USCOREenum_USCOREview_USCOREstatesResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse **)soap_malloc(soap, sizeof(struct ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse, sizeof(struct ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__mc_USCOREenum_USCOREview_USCOREstatesResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREview_USCOREstatesResponse);
	if (soap_out_PointerTons1__mc_USCOREenum_USCOREview_USCOREstatesResponse(soap, tag?tag:"ns1:mc_enum_view_statesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse ** SOAP_FMAC4 soap_get_PointerTons1__mc_USCOREenum_USCOREview_USCOREstatesResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREview_USCOREstatesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__mc_USCOREenum_USCOREview_USCOREstatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse))
		soap_serialize_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse(struct soap *soap, const char *tag, int id, struct ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse ** SOAP_FMAC4 soap_in_PointerTons1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse **)soap_malloc(soap, sizeof(struct ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse, sizeof(struct ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse);
	if (soap_out_PointerTons1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse(soap, tag?tag:"ns1:mc_enum_project_view_statesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse ** SOAP_FMAC4 soap_get_PointerTons1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__mc_USCOREenum_USCOREproject_USCOREview_USCOREstatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__mc_USCOREenum_USCOREproject_USCOREstatusResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse))
		soap_serialize_ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__mc_USCOREenum_USCOREproject_USCOREstatusResponse(struct soap *soap, const char *tag, int id, struct ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse ** SOAP_FMAC4 soap_in_PointerTons1__mc_USCOREenum_USCOREproject_USCOREstatusResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse **)soap_malloc(soap, sizeof(struct ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse, sizeof(struct ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__mc_USCOREenum_USCOREproject_USCOREstatusResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREproject_USCOREstatusResponse);
	if (soap_out_PointerTons1__mc_USCOREenum_USCOREproject_USCOREstatusResponse(soap, tag?tag:"ns1:mc_enum_project_statusResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse ** SOAP_FMAC4 soap_get_PointerTons1__mc_USCOREenum_USCOREproject_USCOREstatusResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREproject_USCOREstatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__mc_USCOREenum_USCOREproject_USCOREstatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse))
		soap_serialize_ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse(struct soap *soap, const char *tag, int id, struct ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse ** SOAP_FMAC4 soap_in_PointerTons1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse **)soap_malloc(soap, sizeof(struct ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse, sizeof(struct ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse);
	if (soap_out_PointerTons1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse(soap, tag?tag:"ns1:mc_enum_access_levelsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse ** SOAP_FMAC4 soap_get_PointerTons1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__mc_USCOREenum_USCOREaccess_USCORElevelsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__mc_USCOREenum_USCOREresolutionsResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREresolutionsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREresolutionsResponse))
		soap_serialize_ns1__mc_USCOREenum_USCOREresolutionsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__mc_USCOREenum_USCOREresolutionsResponse(struct soap *soap, const char *tag, int id, struct ns1__mc_USCOREenum_USCOREresolutionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__mc_USCOREenum_USCOREresolutionsResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__mc_USCOREenum_USCOREresolutionsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREresolutionsResponse ** SOAP_FMAC4 soap_in_PointerTons1__mc_USCOREenum_USCOREresolutionsResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREenum_USCOREresolutionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__mc_USCOREenum_USCOREresolutionsResponse **)soap_malloc(soap, sizeof(struct ns1__mc_USCOREenum_USCOREresolutionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__mc_USCOREenum_USCOREresolutionsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREenum_USCOREresolutionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREresolutionsResponse, sizeof(struct ns1__mc_USCOREenum_USCOREresolutionsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__mc_USCOREenum_USCOREresolutionsResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREresolutionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREresolutionsResponse);
	if (soap_out_PointerTons1__mc_USCOREenum_USCOREresolutionsResponse(soap, tag?tag:"ns1:mc_enum_resolutionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREresolutionsResponse ** SOAP_FMAC4 soap_get_PointerTons1__mc_USCOREenum_USCOREresolutionsResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREresolutionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__mc_USCOREenum_USCOREresolutionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__mc_USCOREenum_USCOREetasResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREetasResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREetasResponse))
		soap_serialize_ns1__mc_USCOREenum_USCOREetasResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__mc_USCOREenum_USCOREetasResponse(struct soap *soap, const char *tag, int id, struct ns1__mc_USCOREenum_USCOREetasResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__mc_USCOREenum_USCOREetasResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__mc_USCOREenum_USCOREetasResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREetasResponse ** SOAP_FMAC4 soap_in_PointerTons1__mc_USCOREenum_USCOREetasResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREenum_USCOREetasResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__mc_USCOREenum_USCOREetasResponse **)soap_malloc(soap, sizeof(struct ns1__mc_USCOREenum_USCOREetasResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__mc_USCOREenum_USCOREetasResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREenum_USCOREetasResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREetasResponse, sizeof(struct ns1__mc_USCOREenum_USCOREetasResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__mc_USCOREenum_USCOREetasResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREetasResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREetasResponse);
	if (soap_out_PointerTons1__mc_USCOREenum_USCOREetasResponse(soap, tag?tag:"ns1:mc_enum_etasResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREetasResponse ** SOAP_FMAC4 soap_get_PointerTons1__mc_USCOREenum_USCOREetasResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREetasResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__mc_USCOREenum_USCOREetasResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__mc_USCOREenum_USCOREprojectionsResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREprojectionsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREprojectionsResponse))
		soap_serialize_ns1__mc_USCOREenum_USCOREprojectionsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__mc_USCOREenum_USCOREprojectionsResponse(struct soap *soap, const char *tag, int id, struct ns1__mc_USCOREenum_USCOREprojectionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__mc_USCOREenum_USCOREprojectionsResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__mc_USCOREenum_USCOREprojectionsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREprojectionsResponse ** SOAP_FMAC4 soap_in_PointerTons1__mc_USCOREenum_USCOREprojectionsResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREenum_USCOREprojectionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__mc_USCOREenum_USCOREprojectionsResponse **)soap_malloc(soap, sizeof(struct ns1__mc_USCOREenum_USCOREprojectionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__mc_USCOREenum_USCOREprojectionsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREenum_USCOREprojectionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREprojectionsResponse, sizeof(struct ns1__mc_USCOREenum_USCOREprojectionsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__mc_USCOREenum_USCOREprojectionsResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREprojectionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREprojectionsResponse);
	if (soap_out_PointerTons1__mc_USCOREenum_USCOREprojectionsResponse(soap, tag?tag:"ns1:mc_enum_projectionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREprojectionsResponse ** SOAP_FMAC4 soap_get_PointerTons1__mc_USCOREenum_USCOREprojectionsResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREprojectionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__mc_USCOREenum_USCOREprojectionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__mc_USCOREenum_USCOREreproducibilitiesResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREreproducibilitiesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREreproducibilitiesResponse))
		soap_serialize_ns1__mc_USCOREenum_USCOREreproducibilitiesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__mc_USCOREenum_USCOREreproducibilitiesResponse(struct soap *soap, const char *tag, int id, struct ns1__mc_USCOREenum_USCOREreproducibilitiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__mc_USCOREenum_USCOREreproducibilitiesResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__mc_USCOREenum_USCOREreproducibilitiesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREreproducibilitiesResponse ** SOAP_FMAC4 soap_in_PointerTons1__mc_USCOREenum_USCOREreproducibilitiesResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREenum_USCOREreproducibilitiesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__mc_USCOREenum_USCOREreproducibilitiesResponse **)soap_malloc(soap, sizeof(struct ns1__mc_USCOREenum_USCOREreproducibilitiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__mc_USCOREenum_USCOREreproducibilitiesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREenum_USCOREreproducibilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREreproducibilitiesResponse, sizeof(struct ns1__mc_USCOREenum_USCOREreproducibilitiesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__mc_USCOREenum_USCOREreproducibilitiesResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREreproducibilitiesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREreproducibilitiesResponse);
	if (soap_out_PointerTons1__mc_USCOREenum_USCOREreproducibilitiesResponse(soap, tag?tag:"ns1:mc_enum_reproducibilitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREreproducibilitiesResponse ** SOAP_FMAC4 soap_get_PointerTons1__mc_USCOREenum_USCOREreproducibilitiesResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREreproducibilitiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__mc_USCOREenum_USCOREreproducibilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__mc_USCOREenum_USCOREseveritiesResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREseveritiesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREseveritiesResponse))
		soap_serialize_ns1__mc_USCOREenum_USCOREseveritiesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__mc_USCOREenum_USCOREseveritiesResponse(struct soap *soap, const char *tag, int id, struct ns1__mc_USCOREenum_USCOREseveritiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__mc_USCOREenum_USCOREseveritiesResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__mc_USCOREenum_USCOREseveritiesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREseveritiesResponse ** SOAP_FMAC4 soap_in_PointerTons1__mc_USCOREenum_USCOREseveritiesResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREenum_USCOREseveritiesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__mc_USCOREenum_USCOREseveritiesResponse **)soap_malloc(soap, sizeof(struct ns1__mc_USCOREenum_USCOREseveritiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__mc_USCOREenum_USCOREseveritiesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREenum_USCOREseveritiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREseveritiesResponse, sizeof(struct ns1__mc_USCOREenum_USCOREseveritiesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__mc_USCOREenum_USCOREseveritiesResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREseveritiesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREseveritiesResponse);
	if (soap_out_PointerTons1__mc_USCOREenum_USCOREseveritiesResponse(soap, tag?tag:"ns1:mc_enum_severitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREseveritiesResponse ** SOAP_FMAC4 soap_get_PointerTons1__mc_USCOREenum_USCOREseveritiesResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREseveritiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__mc_USCOREenum_USCOREseveritiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__mc_USCOREenum_USCOREprioritiesResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREprioritiesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREprioritiesResponse))
		soap_serialize_ns1__mc_USCOREenum_USCOREprioritiesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__mc_USCOREenum_USCOREprioritiesResponse(struct soap *soap, const char *tag, int id, struct ns1__mc_USCOREenum_USCOREprioritiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__mc_USCOREenum_USCOREprioritiesResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__mc_USCOREenum_USCOREprioritiesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREprioritiesResponse ** SOAP_FMAC4 soap_in_PointerTons1__mc_USCOREenum_USCOREprioritiesResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREenum_USCOREprioritiesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__mc_USCOREenum_USCOREprioritiesResponse **)soap_malloc(soap, sizeof(struct ns1__mc_USCOREenum_USCOREprioritiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__mc_USCOREenum_USCOREprioritiesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREenum_USCOREprioritiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREprioritiesResponse, sizeof(struct ns1__mc_USCOREenum_USCOREprioritiesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__mc_USCOREenum_USCOREprioritiesResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREprioritiesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREprioritiesResponse);
	if (soap_out_PointerTons1__mc_USCOREenum_USCOREprioritiesResponse(soap, tag?tag:"ns1:mc_enum_prioritiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREprioritiesResponse ** SOAP_FMAC4 soap_get_PointerTons1__mc_USCOREenum_USCOREprioritiesResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREprioritiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__mc_USCOREenum_USCOREprioritiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__mc_USCOREenum_USCOREstatusResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREstatusResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREstatusResponse))
		soap_serialize_ns1__mc_USCOREenum_USCOREstatusResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__mc_USCOREenum_USCOREstatusResponse(struct soap *soap, const char *tag, int id, struct ns1__mc_USCOREenum_USCOREstatusResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__mc_USCOREenum_USCOREstatusResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__mc_USCOREenum_USCOREstatusResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREstatusResponse ** SOAP_FMAC4 soap_in_PointerTons1__mc_USCOREenum_USCOREstatusResponse(struct soap *soap, const char *tag, struct ns1__mc_USCOREenum_USCOREstatusResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__mc_USCOREenum_USCOREstatusResponse **)soap_malloc(soap, sizeof(struct ns1__mc_USCOREenum_USCOREstatusResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__mc_USCOREenum_USCOREstatusResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__mc_USCOREenum_USCOREstatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__mc_USCOREenum_USCOREstatusResponse, sizeof(struct ns1__mc_USCOREenum_USCOREstatusResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__mc_USCOREenum_USCOREstatusResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREstatusResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__mc_USCOREenum_USCOREstatusResponse);
	if (soap_out_PointerTons1__mc_USCOREenum_USCOREstatusResponse(soap, tag?tag:"ns1:mc_enum_statusResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__mc_USCOREenum_USCOREstatusResponse ** SOAP_FMAC4 soap_get_PointerTons1__mc_USCOREenum_USCOREstatusResponse(struct soap *soap, struct ns1__mc_USCOREenum_USCOREstatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__mc_USCOREenum_USCOREstatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToObjectRefArray(struct soap *soap, struct ObjectRefArray *const*a)
{
	if (*a)
		soap_serialize_ObjectRefArray(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToObjectRefArray(struct soap *soap, const char *tag, int id, struct ObjectRefArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ObjectRefArray);
	if (id < 0)
		return soap->error;
	return soap_out_ObjectRefArray(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ObjectRefArray ** SOAP_FMAC4 soap_in_PointerToObjectRefArray(struct soap *soap, const char *tag, struct ObjectRefArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ObjectRefArray **)soap_malloc(soap, sizeof(struct ObjectRefArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ObjectRefArray(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ObjectRefArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ObjectRefArray, sizeof(struct ObjectRefArray), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToObjectRefArray(struct soap *soap, struct ObjectRefArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToObjectRefArray);
	if (soap_out_PointerToObjectRefArray(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ObjectRefArray ** SOAP_FMAC4 soap_get_PointerToObjectRefArray(struct soap *soap, struct ObjectRefArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToObjectRefArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CustomFieldValueForIssueData(struct soap *soap, struct ns1__CustomFieldValueForIssueData **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CustomFieldValueForIssueData))
		soap_serialize_PointerTons1__CustomFieldValueForIssueData(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CustomFieldValueForIssueData(struct soap *soap, const char *tag, int id, struct ns1__CustomFieldValueForIssueData **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CustomFieldValueForIssueData);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CustomFieldValueForIssueData(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__CustomFieldValueForIssueData *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CustomFieldValueForIssueData(struct soap *soap, const char *tag, struct ns1__CustomFieldValueForIssueData ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__CustomFieldValueForIssueData ***)soap_malloc(soap, sizeof(struct ns1__CustomFieldValueForIssueData **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CustomFieldValueForIssueData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__CustomFieldValueForIssueData ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CustomFieldValueForIssueData, sizeof(struct ns1__CustomFieldValueForIssueData *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CustomFieldValueForIssueData(struct soap *soap, struct ns1__CustomFieldValueForIssueData **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CustomFieldValueForIssueData);
	if (soap_out_PointerToPointerTons1__CustomFieldValueForIssueData(soap, tag?tag:"ns1:CustomFieldValueForIssueData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__CustomFieldValueForIssueData *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CustomFieldValueForIssueData(struct soap *soap, struct ns1__CustomFieldValueForIssueData ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CustomFieldValueForIssueData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CustomFieldValueForIssueData(struct soap *soap, struct ns1__CustomFieldValueForIssueData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CustomFieldValueForIssueData))
		soap_serialize_ns1__CustomFieldValueForIssueData(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CustomFieldValueForIssueData(struct soap *soap, const char *tag, int id, struct ns1__CustomFieldValueForIssueData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CustomFieldValueForIssueData);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__CustomFieldValueForIssueData(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__CustomFieldValueForIssueData ** SOAP_FMAC4 soap_in_PointerTons1__CustomFieldValueForIssueData(struct soap *soap, const char *tag, struct ns1__CustomFieldValueForIssueData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__CustomFieldValueForIssueData **)soap_malloc(soap, sizeof(struct ns1__CustomFieldValueForIssueData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__CustomFieldValueForIssueData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__CustomFieldValueForIssueData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CustomFieldValueForIssueData, sizeof(struct ns1__CustomFieldValueForIssueData), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CustomFieldValueForIssueData(struct soap *soap, struct ns1__CustomFieldValueForIssueData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CustomFieldValueForIssueData);
	if (soap_out_PointerTons1__CustomFieldValueForIssueData(soap, tag?tag:"ns1:CustomFieldValueForIssueData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__CustomFieldValueForIssueData ** SOAP_FMAC4 soap_get_PointerTons1__CustomFieldValueForIssueData(struct soap *soap, struct ns1__CustomFieldValueForIssueData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CustomFieldValueForIssueData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CustomFieldLinkForProjectData(struct soap *soap, struct ns1__CustomFieldLinkForProjectData **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CustomFieldLinkForProjectData))
		soap_serialize_PointerTons1__CustomFieldLinkForProjectData(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CustomFieldLinkForProjectData(struct soap *soap, const char *tag, int id, struct ns1__CustomFieldLinkForProjectData **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CustomFieldLinkForProjectData);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CustomFieldLinkForProjectData(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__CustomFieldLinkForProjectData *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CustomFieldLinkForProjectData(struct soap *soap, const char *tag, struct ns1__CustomFieldLinkForProjectData ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__CustomFieldLinkForProjectData ***)soap_malloc(soap, sizeof(struct ns1__CustomFieldLinkForProjectData **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CustomFieldLinkForProjectData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__CustomFieldLinkForProjectData ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CustomFieldLinkForProjectData, sizeof(struct ns1__CustomFieldLinkForProjectData *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CustomFieldLinkForProjectData(struct soap *soap, struct ns1__CustomFieldLinkForProjectData **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CustomFieldLinkForProjectData);
	if (soap_out_PointerToPointerTons1__CustomFieldLinkForProjectData(soap, tag?tag:"ns1:CustomFieldLinkForProjectData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__CustomFieldLinkForProjectData *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CustomFieldLinkForProjectData(struct soap *soap, struct ns1__CustomFieldLinkForProjectData ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CustomFieldLinkForProjectData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CustomFieldLinkForProjectData(struct soap *soap, struct ns1__CustomFieldLinkForProjectData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CustomFieldLinkForProjectData))
		soap_serialize_ns1__CustomFieldLinkForProjectData(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CustomFieldLinkForProjectData(struct soap *soap, const char *tag, int id, struct ns1__CustomFieldLinkForProjectData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CustomFieldLinkForProjectData);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__CustomFieldLinkForProjectData(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__CustomFieldLinkForProjectData ** SOAP_FMAC4 soap_in_PointerTons1__CustomFieldLinkForProjectData(struct soap *soap, const char *tag, struct ns1__CustomFieldLinkForProjectData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__CustomFieldLinkForProjectData **)soap_malloc(soap, sizeof(struct ns1__CustomFieldLinkForProjectData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__CustomFieldLinkForProjectData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__CustomFieldLinkForProjectData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CustomFieldLinkForProjectData, sizeof(struct ns1__CustomFieldLinkForProjectData), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CustomFieldLinkForProjectData(struct soap *soap, struct ns1__CustomFieldLinkForProjectData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CustomFieldLinkForProjectData);
	if (soap_out_PointerTons1__CustomFieldLinkForProjectData(soap, tag?tag:"ns1:CustomFieldLinkForProjectData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__CustomFieldLinkForProjectData ** SOAP_FMAC4 soap_get_PointerTons1__CustomFieldLinkForProjectData(struct soap *soap, struct ns1__CustomFieldLinkForProjectData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CustomFieldLinkForProjectData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CustomFieldDefinitionData(struct soap *soap, struct ns1__CustomFieldDefinitionData **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CustomFieldDefinitionData))
		soap_serialize_PointerTons1__CustomFieldDefinitionData(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CustomFieldDefinitionData(struct soap *soap, const char *tag, int id, struct ns1__CustomFieldDefinitionData **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CustomFieldDefinitionData);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CustomFieldDefinitionData(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__CustomFieldDefinitionData *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CustomFieldDefinitionData(struct soap *soap, const char *tag, struct ns1__CustomFieldDefinitionData ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__CustomFieldDefinitionData ***)soap_malloc(soap, sizeof(struct ns1__CustomFieldDefinitionData **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CustomFieldDefinitionData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__CustomFieldDefinitionData ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CustomFieldDefinitionData, sizeof(struct ns1__CustomFieldDefinitionData *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CustomFieldDefinitionData(struct soap *soap, struct ns1__CustomFieldDefinitionData **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CustomFieldDefinitionData);
	if (soap_out_PointerToPointerTons1__CustomFieldDefinitionData(soap, tag?tag:"ns1:CustomFieldDefinitionData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__CustomFieldDefinitionData *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CustomFieldDefinitionData(struct soap *soap, struct ns1__CustomFieldDefinitionData ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CustomFieldDefinitionData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CustomFieldDefinitionData(struct soap *soap, struct ns1__CustomFieldDefinitionData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CustomFieldDefinitionData))
		soap_serialize_ns1__CustomFieldDefinitionData(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CustomFieldDefinitionData(struct soap *soap, const char *tag, int id, struct ns1__CustomFieldDefinitionData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CustomFieldDefinitionData);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__CustomFieldDefinitionData(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__CustomFieldDefinitionData ** SOAP_FMAC4 soap_in_PointerTons1__CustomFieldDefinitionData(struct soap *soap, const char *tag, struct ns1__CustomFieldDefinitionData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__CustomFieldDefinitionData **)soap_malloc(soap, sizeof(struct ns1__CustomFieldDefinitionData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__CustomFieldDefinitionData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__CustomFieldDefinitionData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CustomFieldDefinitionData, sizeof(struct ns1__CustomFieldDefinitionData), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CustomFieldDefinitionData(struct soap *soap, struct ns1__CustomFieldDefinitionData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CustomFieldDefinitionData);
	if (soap_out_PointerTons1__CustomFieldDefinitionData(soap, tag?tag:"ns1:CustomFieldDefinitionData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__CustomFieldDefinitionData ** SOAP_FMAC4 soap_get_PointerTons1__CustomFieldDefinitionData(struct soap *soap, struct ns1__CustomFieldDefinitionData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CustomFieldDefinitionData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__FilterData(struct soap *soap, struct ns1__FilterData **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__FilterData))
		soap_serialize_PointerTons1__FilterData(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__FilterData(struct soap *soap, const char *tag, int id, struct ns1__FilterData **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__FilterData);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__FilterData(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__FilterData *** SOAP_FMAC4 soap_in_PointerToPointerTons1__FilterData(struct soap *soap, const char *tag, struct ns1__FilterData ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__FilterData ***)soap_malloc(soap, sizeof(struct ns1__FilterData **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__FilterData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__FilterData ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__FilterData, sizeof(struct ns1__FilterData *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__FilterData(struct soap *soap, struct ns1__FilterData **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__FilterData);
	if (soap_out_PointerToPointerTons1__FilterData(soap, tag?tag:"ns1:FilterData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__FilterData *** SOAP_FMAC4 soap_get_PointerToPointerTons1__FilterData(struct soap *soap, struct ns1__FilterData ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__FilterData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FilterData(struct soap *soap, struct ns1__FilterData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__FilterData))
		soap_serialize_ns1__FilterData(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FilterData(struct soap *soap, const char *tag, int id, struct ns1__FilterData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__FilterData);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__FilterData(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__FilterData ** SOAP_FMAC4 soap_in_PointerTons1__FilterData(struct soap *soap, const char *tag, struct ns1__FilterData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__FilterData **)soap_malloc(soap, sizeof(struct ns1__FilterData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__FilterData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__FilterData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__FilterData, sizeof(struct ns1__FilterData), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FilterData(struct soap *soap, struct ns1__FilterData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__FilterData);
	if (soap_out_PointerTons1__FilterData(soap, tag?tag:"ns1:FilterData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__FilterData ** SOAP_FMAC4 soap_get_PointerTons1__FilterData(struct soap *soap, struct ns1__FilterData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FilterData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__ProjectVersionData(struct soap *soap, struct ns1__ProjectVersionData **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__ProjectVersionData))
		soap_serialize_PointerTons1__ProjectVersionData(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__ProjectVersionData(struct soap *soap, const char *tag, int id, struct ns1__ProjectVersionData **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__ProjectVersionData);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__ProjectVersionData(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ProjectVersionData *** SOAP_FMAC4 soap_in_PointerToPointerTons1__ProjectVersionData(struct soap *soap, const char *tag, struct ns1__ProjectVersionData ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ProjectVersionData ***)soap_malloc(soap, sizeof(struct ns1__ProjectVersionData **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__ProjectVersionData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ProjectVersionData ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__ProjectVersionData, sizeof(struct ns1__ProjectVersionData *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__ProjectVersionData(struct soap *soap, struct ns1__ProjectVersionData **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__ProjectVersionData);
	if (soap_out_PointerToPointerTons1__ProjectVersionData(soap, tag?tag:"ns1:ProjectVersionData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ProjectVersionData *** SOAP_FMAC4 soap_get_PointerToPointerTons1__ProjectVersionData(struct soap *soap, struct ns1__ProjectVersionData ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__ProjectVersionData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ProjectVersionData(struct soap *soap, struct ns1__ProjectVersionData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ProjectVersionData))
		soap_serialize_ns1__ProjectVersionData(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ProjectVersionData(struct soap *soap, const char *tag, int id, struct ns1__ProjectVersionData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ProjectVersionData);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ProjectVersionData(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ProjectVersionData ** SOAP_FMAC4 soap_in_PointerTons1__ProjectVersionData(struct soap *soap, const char *tag, struct ns1__ProjectVersionData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ProjectVersionData **)soap_malloc(soap, sizeof(struct ns1__ProjectVersionData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ProjectVersionData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ProjectVersionData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ProjectVersionData, sizeof(struct ns1__ProjectVersionData), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ProjectVersionData(struct soap *soap, struct ns1__ProjectVersionData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ProjectVersionData);
	if (soap_out_PointerTons1__ProjectVersionData(soap, tag?tag:"ns1:ProjectVersionData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ProjectVersionData ** SOAP_FMAC4 soap_get_PointerTons1__ProjectVersionData(struct soap *soap, struct ns1__ProjectVersionData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ProjectVersionData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__ProjectData(struct soap *soap, struct ns1__ProjectData **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__ProjectData))
		soap_serialize_PointerTons1__ProjectData(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__ProjectData(struct soap *soap, const char *tag, int id, struct ns1__ProjectData **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__ProjectData);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__ProjectData(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ProjectData *** SOAP_FMAC4 soap_in_PointerToPointerTons1__ProjectData(struct soap *soap, const char *tag, struct ns1__ProjectData ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ProjectData ***)soap_malloc(soap, sizeof(struct ns1__ProjectData **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__ProjectData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ProjectData ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__ProjectData, sizeof(struct ns1__ProjectData *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__ProjectData(struct soap *soap, struct ns1__ProjectData **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__ProjectData);
	if (soap_out_PointerToPointerTons1__ProjectData(soap, tag?tag:"ns1:ProjectData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ProjectData *** SOAP_FMAC4 soap_get_PointerToPointerTons1__ProjectData(struct soap *soap, struct ns1__ProjectData ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__ProjectData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ProjectData(struct soap *soap, struct ns1__ProjectData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ProjectData))
		soap_serialize_ns1__ProjectData(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ProjectData(struct soap *soap, const char *tag, int id, struct ns1__ProjectData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ProjectData);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ProjectData(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ProjectData ** SOAP_FMAC4 soap_in_PointerTons1__ProjectData(struct soap *soap, const char *tag, struct ns1__ProjectData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ProjectData **)soap_malloc(soap, sizeof(struct ns1__ProjectData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ProjectData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ProjectData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ProjectData, sizeof(struct ns1__ProjectData), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ProjectData(struct soap *soap, struct ns1__ProjectData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ProjectData);
	if (soap_out_PointerTons1__ProjectData(soap, tag?tag:"ns1:ProjectData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ProjectData ** SOAP_FMAC4 soap_get_PointerTons1__ProjectData(struct soap *soap, struct ns1__ProjectData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ProjectData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__IssueHeaderData(struct soap *soap, struct ns1__IssueHeaderData **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__IssueHeaderData))
		soap_serialize_PointerTons1__IssueHeaderData(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__IssueHeaderData(struct soap *soap, const char *tag, int id, struct ns1__IssueHeaderData **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__IssueHeaderData);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__IssueHeaderData(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__IssueHeaderData *** SOAP_FMAC4 soap_in_PointerToPointerTons1__IssueHeaderData(struct soap *soap, const char *tag, struct ns1__IssueHeaderData ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__IssueHeaderData ***)soap_malloc(soap, sizeof(struct ns1__IssueHeaderData **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__IssueHeaderData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__IssueHeaderData ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__IssueHeaderData, sizeof(struct ns1__IssueHeaderData *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__IssueHeaderData(struct soap *soap, struct ns1__IssueHeaderData **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__IssueHeaderData);
	if (soap_out_PointerToPointerTons1__IssueHeaderData(soap, tag?tag:"ns1:IssueHeaderData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__IssueHeaderData *** SOAP_FMAC4 soap_get_PointerToPointerTons1__IssueHeaderData(struct soap *soap, struct ns1__IssueHeaderData ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__IssueHeaderData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__IssueHeaderData(struct soap *soap, struct ns1__IssueHeaderData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__IssueHeaderData))
		soap_serialize_ns1__IssueHeaderData(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__IssueHeaderData(struct soap *soap, const char *tag, int id, struct ns1__IssueHeaderData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__IssueHeaderData);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__IssueHeaderData(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__IssueHeaderData ** SOAP_FMAC4 soap_in_PointerTons1__IssueHeaderData(struct soap *soap, const char *tag, struct ns1__IssueHeaderData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__IssueHeaderData **)soap_malloc(soap, sizeof(struct ns1__IssueHeaderData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__IssueHeaderData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__IssueHeaderData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__IssueHeaderData, sizeof(struct ns1__IssueHeaderData), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__IssueHeaderData(struct soap *soap, struct ns1__IssueHeaderData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__IssueHeaderData);
	if (soap_out_PointerTons1__IssueHeaderData(soap, tag?tag:"ns1:IssueHeaderData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__IssueHeaderData ** SOAP_FMAC4 soap_get_PointerTons1__IssueHeaderData(struct soap *soap, struct ns1__IssueHeaderData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__IssueHeaderData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__IssueData(struct soap *soap, struct ns1__IssueData **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__IssueData))
		soap_serialize_PointerTons1__IssueData(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__IssueData(struct soap *soap, const char *tag, int id, struct ns1__IssueData **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__IssueData);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__IssueData(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__IssueData *** SOAP_FMAC4 soap_in_PointerToPointerTons1__IssueData(struct soap *soap, const char *tag, struct ns1__IssueData ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__IssueData ***)soap_malloc(soap, sizeof(struct ns1__IssueData **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__IssueData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__IssueData ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__IssueData, sizeof(struct ns1__IssueData *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__IssueData(struct soap *soap, struct ns1__IssueData **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__IssueData);
	if (soap_out_PointerToPointerTons1__IssueData(soap, tag?tag:"ns1:IssueData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__IssueData *** SOAP_FMAC4 soap_get_PointerToPointerTons1__IssueData(struct soap *soap, struct ns1__IssueData ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__IssueData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__IssueData(struct soap *soap, struct ns1__IssueData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__IssueData))
		soap_serialize_ns1__IssueData(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__IssueData(struct soap *soap, const char *tag, int id, struct ns1__IssueData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__IssueData);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__IssueData(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__IssueData ** SOAP_FMAC4 soap_in_PointerTons1__IssueData(struct soap *soap, const char *tag, struct ns1__IssueData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__IssueData **)soap_malloc(soap, sizeof(struct ns1__IssueData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__IssueData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__IssueData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__IssueData, sizeof(struct ns1__IssueData), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__IssueData(struct soap *soap, struct ns1__IssueData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__IssueData);
	if (soap_out_PointerTons1__IssueData(soap, tag?tag:"ns1:IssueData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__IssueData ** SOAP_FMAC4 soap_get_PointerTons1__IssueData(struct soap *soap, struct ns1__IssueData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__IssueData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__IssueNoteData(struct soap *soap, struct ns1__IssueNoteData **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__IssueNoteData))
		soap_serialize_PointerTons1__IssueNoteData(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__IssueNoteData(struct soap *soap, const char *tag, int id, struct ns1__IssueNoteData **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__IssueNoteData);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__IssueNoteData(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__IssueNoteData *** SOAP_FMAC4 soap_in_PointerToPointerTons1__IssueNoteData(struct soap *soap, const char *tag, struct ns1__IssueNoteData ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__IssueNoteData ***)soap_malloc(soap, sizeof(struct ns1__IssueNoteData **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__IssueNoteData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__IssueNoteData ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__IssueNoteData, sizeof(struct ns1__IssueNoteData *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__IssueNoteData(struct soap *soap, struct ns1__IssueNoteData **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__IssueNoteData);
	if (soap_out_PointerToPointerTons1__IssueNoteData(soap, tag?tag:"ns1:IssueNoteData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__IssueNoteData *** SOAP_FMAC4 soap_get_PointerToPointerTons1__IssueNoteData(struct soap *soap, struct ns1__IssueNoteData ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__IssueNoteData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__IssueNoteData(struct soap *soap, struct ns1__IssueNoteData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__IssueNoteData))
		soap_serialize_ns1__IssueNoteData(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__IssueNoteData(struct soap *soap, const char *tag, int id, struct ns1__IssueNoteData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__IssueNoteData);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__IssueNoteData(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__IssueNoteData ** SOAP_FMAC4 soap_in_PointerTons1__IssueNoteData(struct soap *soap, const char *tag, struct ns1__IssueNoteData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__IssueNoteData **)soap_malloc(soap, sizeof(struct ns1__IssueNoteData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__IssueNoteData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__IssueNoteData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__IssueNoteData, sizeof(struct ns1__IssueNoteData), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__IssueNoteData(struct soap *soap, struct ns1__IssueNoteData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__IssueNoteData);
	if (soap_out_PointerTons1__IssueNoteData(soap, tag?tag:"ns1:IssueNoteData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__IssueNoteData ** SOAP_FMAC4 soap_get_PointerTons1__IssueNoteData(struct soap *soap, struct ns1__IssueNoteData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__IssueNoteData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__RelationshipData(struct soap *soap, struct ns1__RelationshipData **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__RelationshipData))
		soap_serialize_PointerTons1__RelationshipData(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__RelationshipData(struct soap *soap, const char *tag, int id, struct ns1__RelationshipData **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__RelationshipData);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__RelationshipData(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__RelationshipData *** SOAP_FMAC4 soap_in_PointerToPointerTons1__RelationshipData(struct soap *soap, const char *tag, struct ns1__RelationshipData ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__RelationshipData ***)soap_malloc(soap, sizeof(struct ns1__RelationshipData **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__RelationshipData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__RelationshipData ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__RelationshipData, sizeof(struct ns1__RelationshipData *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__RelationshipData(struct soap *soap, struct ns1__RelationshipData **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__RelationshipData);
	if (soap_out_PointerToPointerTons1__RelationshipData(soap, tag?tag:"ns1:RelationshipData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__RelationshipData *** SOAP_FMAC4 soap_get_PointerToPointerTons1__RelationshipData(struct soap *soap, struct ns1__RelationshipData ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__RelationshipData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RelationshipData(struct soap *soap, struct ns1__RelationshipData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__RelationshipData))
		soap_serialize_ns1__RelationshipData(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RelationshipData(struct soap *soap, const char *tag, int id, struct ns1__RelationshipData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__RelationshipData);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__RelationshipData(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__RelationshipData ** SOAP_FMAC4 soap_in_PointerTons1__RelationshipData(struct soap *soap, const char *tag, struct ns1__RelationshipData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__RelationshipData **)soap_malloc(soap, sizeof(struct ns1__RelationshipData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__RelationshipData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__RelationshipData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__RelationshipData, sizeof(struct ns1__RelationshipData), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RelationshipData(struct soap *soap, struct ns1__RelationshipData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__RelationshipData);
	if (soap_out_PointerTons1__RelationshipData(soap, tag?tag:"ns1:RelationshipData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__RelationshipData ** SOAP_FMAC4 soap_get_PointerTons1__RelationshipData(struct soap *soap, struct ns1__RelationshipData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RelationshipData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__ProjectAttachmentData(struct soap *soap, struct ns1__ProjectAttachmentData **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__ProjectAttachmentData))
		soap_serialize_PointerTons1__ProjectAttachmentData(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__ProjectAttachmentData(struct soap *soap, const char *tag, int id, struct ns1__ProjectAttachmentData **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__ProjectAttachmentData);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__ProjectAttachmentData(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ProjectAttachmentData *** SOAP_FMAC4 soap_in_PointerToPointerTons1__ProjectAttachmentData(struct soap *soap, const char *tag, struct ns1__ProjectAttachmentData ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ProjectAttachmentData ***)soap_malloc(soap, sizeof(struct ns1__ProjectAttachmentData **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__ProjectAttachmentData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ProjectAttachmentData ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__ProjectAttachmentData, sizeof(struct ns1__ProjectAttachmentData *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__ProjectAttachmentData(struct soap *soap, struct ns1__ProjectAttachmentData **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__ProjectAttachmentData);
	if (soap_out_PointerToPointerTons1__ProjectAttachmentData(soap, tag?tag:"ns1:ProjectAttachmentData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ProjectAttachmentData *** SOAP_FMAC4 soap_get_PointerToPointerTons1__ProjectAttachmentData(struct soap *soap, struct ns1__ProjectAttachmentData ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__ProjectAttachmentData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ProjectAttachmentData(struct soap *soap, struct ns1__ProjectAttachmentData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ProjectAttachmentData))
		soap_serialize_ns1__ProjectAttachmentData(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ProjectAttachmentData(struct soap *soap, const char *tag, int id, struct ns1__ProjectAttachmentData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ProjectAttachmentData);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ProjectAttachmentData(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ProjectAttachmentData ** SOAP_FMAC4 soap_in_PointerTons1__ProjectAttachmentData(struct soap *soap, const char *tag, struct ns1__ProjectAttachmentData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ProjectAttachmentData **)soap_malloc(soap, sizeof(struct ns1__ProjectAttachmentData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ProjectAttachmentData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ProjectAttachmentData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ProjectAttachmentData, sizeof(struct ns1__ProjectAttachmentData), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ProjectAttachmentData(struct soap *soap, struct ns1__ProjectAttachmentData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ProjectAttachmentData);
	if (soap_out_PointerTons1__ProjectAttachmentData(soap, tag?tag:"ns1:ProjectAttachmentData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ProjectAttachmentData ** SOAP_FMAC4 soap_get_PointerTons1__ProjectAttachmentData(struct soap *soap, struct ns1__ProjectAttachmentData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ProjectAttachmentData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__AttachmentData(struct soap *soap, struct ns1__AttachmentData **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__AttachmentData))
		soap_serialize_PointerTons1__AttachmentData(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__AttachmentData(struct soap *soap, const char *tag, int id, struct ns1__AttachmentData **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__AttachmentData);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__AttachmentData(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__AttachmentData *** SOAP_FMAC4 soap_in_PointerToPointerTons1__AttachmentData(struct soap *soap, const char *tag, struct ns1__AttachmentData ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__AttachmentData ***)soap_malloc(soap, sizeof(struct ns1__AttachmentData **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__AttachmentData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__AttachmentData ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__AttachmentData, sizeof(struct ns1__AttachmentData *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__AttachmentData(struct soap *soap, struct ns1__AttachmentData **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__AttachmentData);
	if (soap_out_PointerToPointerTons1__AttachmentData(soap, tag?tag:"ns1:AttachmentData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__AttachmentData *** SOAP_FMAC4 soap_get_PointerToPointerTons1__AttachmentData(struct soap *soap, struct ns1__AttachmentData ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__AttachmentData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AttachmentData(struct soap *soap, struct ns1__AttachmentData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AttachmentData))
		soap_serialize_ns1__AttachmentData(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AttachmentData(struct soap *soap, const char *tag, int id, struct ns1__AttachmentData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AttachmentData);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__AttachmentData(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__AttachmentData ** SOAP_FMAC4 soap_in_PointerTons1__AttachmentData(struct soap *soap, const char *tag, struct ns1__AttachmentData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__AttachmentData **)soap_malloc(soap, sizeof(struct ns1__AttachmentData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__AttachmentData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__AttachmentData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AttachmentData, sizeof(struct ns1__AttachmentData), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AttachmentData(struct soap *soap, struct ns1__AttachmentData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__AttachmentData);
	if (soap_out_PointerTons1__AttachmentData(soap, tag?tag:"ns1:AttachmentData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__AttachmentData ** SOAP_FMAC4 soap_get_PointerTons1__AttachmentData(struct soap *soap, struct ns1__AttachmentData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AttachmentData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__AccountData(struct soap *soap, struct ns1__AccountData **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__AccountData))
		soap_serialize_PointerTons1__AccountData(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__AccountData(struct soap *soap, const char *tag, int id, struct ns1__AccountData **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__AccountData);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__AccountData(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__AccountData *** SOAP_FMAC4 soap_in_PointerToPointerTons1__AccountData(struct soap *soap, const char *tag, struct ns1__AccountData ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__AccountData ***)soap_malloc(soap, sizeof(struct ns1__AccountData **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__AccountData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__AccountData ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__AccountData, sizeof(struct ns1__AccountData *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__AccountData(struct soap *soap, struct ns1__AccountData **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__AccountData);
	if (soap_out_PointerToPointerTons1__AccountData(soap, tag?tag:"ns1:AccountData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__AccountData *** SOAP_FMAC4 soap_get_PointerToPointerTons1__AccountData(struct soap *soap, struct ns1__AccountData ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__AccountData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__ObjectRef(struct soap *soap, struct ns1__ObjectRef **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__ObjectRef))
		soap_serialize_PointerTons1__ObjectRef(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__ObjectRef(struct soap *soap, const char *tag, int id, struct ns1__ObjectRef **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__ObjectRef);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__ObjectRef(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ObjectRef *** SOAP_FMAC4 soap_in_PointerToPointerTons1__ObjectRef(struct soap *soap, const char *tag, struct ns1__ObjectRef ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ObjectRef ***)soap_malloc(soap, sizeof(struct ns1__ObjectRef **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__ObjectRef(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ObjectRef ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__ObjectRef, sizeof(struct ns1__ObjectRef *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__ObjectRef(struct soap *soap, struct ns1__ObjectRef **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__ObjectRef);
	if (soap_out_PointerToPointerTons1__ObjectRef(soap, tag?tag:"ns1:ObjectRef", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ObjectRef *** SOAP_FMAC4 soap_get_PointerToPointerTons1__ObjectRef(struct soap *soap, struct ns1__ObjectRef ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__ObjectRef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostring(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_string))
		soap_serialize_string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostring(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_string);
	if (id < 0)
		return soap->error;
	return soap_out_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTostring(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostring);
	if (soap_out_PointerTostring(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTostring(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__byte(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__byte);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__byte(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__byte);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__byte(soap, tag, id, *a, type);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_in_PointerToxsd__byte(struct soap *soap, const char *tag, char **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char **)soap_malloc(soap, sizeof(char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__byte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__byte, sizeof(char), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__byte(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__byte);
	if (soap_out_PointerToxsd__byte(soap, tag?tag:"xsd:byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_PointerToxsd__byte(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToProjectDataArray(struct soap *soap, struct ProjectDataArray *const*a)
{
	if (*a)
		soap_serialize_ProjectDataArray(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToProjectDataArray(struct soap *soap, const char *tag, int id, struct ProjectDataArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ProjectDataArray);
	if (id < 0)
		return soap->error;
	return soap_out_ProjectDataArray(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ProjectDataArray ** SOAP_FMAC4 soap_in_PointerToProjectDataArray(struct soap *soap, const char *tag, struct ProjectDataArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ProjectDataArray **)soap_malloc(soap, sizeof(struct ProjectDataArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ProjectDataArray(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ProjectDataArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ProjectDataArray, sizeof(struct ProjectDataArray), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToProjectDataArray(struct soap *soap, struct ProjectDataArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToProjectDataArray);
	if (soap_out_PointerToProjectDataArray(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ProjectDataArray ** SOAP_FMAC4 soap_get_PointerToProjectDataArray(struct soap *soap, struct ProjectDataArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToProjectDataArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__boolean);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__boolean(struct soap *soap, const char *tag, int id, enum xsd__boolean *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__boolean);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__boolean(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum xsd__boolean ** SOAP_FMAC4 soap_in_PointerToxsd__boolean(struct soap *soap, const char *tag, enum xsd__boolean **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum xsd__boolean **)soap_malloc(soap, sizeof(enum xsd__boolean *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__boolean(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum xsd__boolean **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__boolean);
	if (soap_out_PointerToxsd__boolean(soap, tag?tag:"xsd:boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum xsd__boolean ** SOAP_FMAC4 soap_get_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToCustomFieldValueForIssueDataArray(struct soap *soap, struct CustomFieldValueForIssueDataArray *const*a)
{
	if (*a)
		soap_serialize_CustomFieldValueForIssueDataArray(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToCustomFieldValueForIssueDataArray(struct soap *soap, const char *tag, int id, struct CustomFieldValueForIssueDataArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_CustomFieldValueForIssueDataArray);
	if (id < 0)
		return soap->error;
	return soap_out_CustomFieldValueForIssueDataArray(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct CustomFieldValueForIssueDataArray ** SOAP_FMAC4 soap_in_PointerToCustomFieldValueForIssueDataArray(struct soap *soap, const char *tag, struct CustomFieldValueForIssueDataArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct CustomFieldValueForIssueDataArray **)soap_malloc(soap, sizeof(struct CustomFieldValueForIssueDataArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_CustomFieldValueForIssueDataArray(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct CustomFieldValueForIssueDataArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_CustomFieldValueForIssueDataArray, sizeof(struct CustomFieldValueForIssueDataArray), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToCustomFieldValueForIssueDataArray(struct soap *soap, struct CustomFieldValueForIssueDataArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToCustomFieldValueForIssueDataArray);
	if (soap_out_PointerToCustomFieldValueForIssueDataArray(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct CustomFieldValueForIssueDataArray ** SOAP_FMAC4 soap_get_PointerToCustomFieldValueForIssueDataArray(struct soap *soap, struct CustomFieldValueForIssueDataArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToCustomFieldValueForIssueDataArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToIssueNoteDataArray(struct soap *soap, struct IssueNoteDataArray *const*a)
{
	if (*a)
		soap_serialize_IssueNoteDataArray(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToIssueNoteDataArray(struct soap *soap, const char *tag, int id, struct IssueNoteDataArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_IssueNoteDataArray);
	if (id < 0)
		return soap->error;
	return soap_out_IssueNoteDataArray(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct IssueNoteDataArray ** SOAP_FMAC4 soap_in_PointerToIssueNoteDataArray(struct soap *soap, const char *tag, struct IssueNoteDataArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct IssueNoteDataArray **)soap_malloc(soap, sizeof(struct IssueNoteDataArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_IssueNoteDataArray(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct IssueNoteDataArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_IssueNoteDataArray, sizeof(struct IssueNoteDataArray), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToIssueNoteDataArray(struct soap *soap, struct IssueNoteDataArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToIssueNoteDataArray);
	if (soap_out_PointerToIssueNoteDataArray(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct IssueNoteDataArray ** SOAP_FMAC4 soap_get_PointerToIssueNoteDataArray(struct soap *soap, struct IssueNoteDataArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToIssueNoteDataArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToRelationshipDataArray(struct soap *soap, struct RelationshipDataArray *const*a)
{
	if (*a)
		soap_serialize_RelationshipDataArray(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToRelationshipDataArray(struct soap *soap, const char *tag, int id, struct RelationshipDataArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_RelationshipDataArray);
	if (id < 0)
		return soap->error;
	return soap_out_RelationshipDataArray(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct RelationshipDataArray ** SOAP_FMAC4 soap_in_PointerToRelationshipDataArray(struct soap *soap, const char *tag, struct RelationshipDataArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct RelationshipDataArray **)soap_malloc(soap, sizeof(struct RelationshipDataArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_RelationshipDataArray(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct RelationshipDataArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_RelationshipDataArray, sizeof(struct RelationshipDataArray), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToRelationshipDataArray(struct soap *soap, struct RelationshipDataArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToRelationshipDataArray);
	if (soap_out_PointerToRelationshipDataArray(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct RelationshipDataArray ** SOAP_FMAC4 soap_get_PointerToRelationshipDataArray(struct soap *soap, struct RelationshipDataArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToRelationshipDataArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToAttachmentDataArray(struct soap *soap, struct AttachmentDataArray *const*a)
{
	if (*a)
		soap_serialize_AttachmentDataArray(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToAttachmentDataArray(struct soap *soap, const char *tag, int id, struct AttachmentDataArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_AttachmentDataArray);
	if (id < 0)
		return soap->error;
	return soap_out_AttachmentDataArray(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct AttachmentDataArray ** SOAP_FMAC4 soap_in_PointerToAttachmentDataArray(struct soap *soap, const char *tag, struct AttachmentDataArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct AttachmentDataArray **)soap_malloc(soap, sizeof(struct AttachmentDataArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_AttachmentDataArray(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct AttachmentDataArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_AttachmentDataArray, sizeof(struct AttachmentDataArray), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToAttachmentDataArray(struct soap *soap, struct AttachmentDataArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToAttachmentDataArray);
	if (soap_out_PointerToAttachmentDataArray(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct AttachmentDataArray ** SOAP_FMAC4 soap_get_PointerToAttachmentDataArray(struct soap *soap, struct AttachmentDataArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToAttachmentDataArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AccountData(struct soap *soap, struct ns1__AccountData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AccountData))
		soap_serialize_ns1__AccountData(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AccountData(struct soap *soap, const char *tag, int id, struct ns1__AccountData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AccountData);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__AccountData(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__AccountData ** SOAP_FMAC4 soap_in_PointerTons1__AccountData(struct soap *soap, const char *tag, struct ns1__AccountData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__AccountData **)soap_malloc(soap, sizeof(struct ns1__AccountData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__AccountData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__AccountData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AccountData, sizeof(struct ns1__AccountData), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AccountData(struct soap *soap, struct ns1__AccountData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__AccountData);
	if (soap_out_PointerTons1__AccountData(soap, tag?tag:"ns1:AccountData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__AccountData ** SOAP_FMAC4 soap_get_PointerTons1__AccountData(struct soap *soap, struct ns1__AccountData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AccountData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ObjectRef(struct soap *soap, struct ns1__ObjectRef *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ObjectRef))
		soap_serialize_ns1__ObjectRef(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ObjectRef(struct soap *soap, const char *tag, int id, struct ns1__ObjectRef *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ObjectRef);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ObjectRef(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ObjectRef ** SOAP_FMAC4 soap_in_PointerTons1__ObjectRef(struct soap *soap, const char *tag, struct ns1__ObjectRef **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ObjectRef **)soap_malloc(soap, sizeof(struct ns1__ObjectRef *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ObjectRef(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ObjectRef **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ObjectRef, sizeof(struct ns1__ObjectRef), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ObjectRef(struct soap *soap, struct ns1__ObjectRef *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ObjectRef);
	if (soap_out_PointerTons1__ObjectRef(soap, tag?tag:"ns1:ObjectRef", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ObjectRef ** SOAP_FMAC4 soap_get_PointerTons1__ObjectRef(struct soap *soap, struct ns1__ObjectRef **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ObjectRef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotime(struct soap *soap, time_t *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_time);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_time);
	if (id < 0)
		return soap->error;
	return soap_out_time(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTotime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_time(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_time, sizeof(time_t), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotime);
	if (soap_out_PointerTotime(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTotime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__integer(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__integer);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__integer(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__integer, 1, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__integer(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__integer);
	if (soap_out_xsd__integer(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__integer(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__integer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedByte);
	if (soap_out_PointerTounsignedByte(soap, tag?tag:"unsignedByte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__anyURI);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__anyURI, 1, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__anyURI);
	if (soap_out_xsd__anyURI(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.c */
