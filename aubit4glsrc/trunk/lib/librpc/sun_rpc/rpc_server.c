/**
 * @file
 *
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 *
 * @todo Take the prototypes here declared. See if the functions are static
 * or to be externally seen
 * @todo Doxygen comments to add to functions
 */

#include "a4gl_pointers.h"
#include "./rpc_stack.h"
#include "a4gl_debug.h"

double pop_double();
int push_double(double a);
float pop_float();
int push_float(float a);

void *find_pointer(char *c,char a);

extern int status;

return_values * 
call_remote_func_1_svc(call arg,  struct svc_req *rqstp)
{
int a;
int z;
int d,s;
call *arg1;
void *p;
int async=0;
char func_name[64];

	static return_values result={0,0};
	object_data	 *ptr;
arg1=&arg;
strcpy(func_name,arg1->function_name);
if (func_name[0]=='!') {
         strcpy(func_name,&arg1->function_name[1]);
	 async=1;
}

	debug("%s\n",arg1->function_name);
	debug("%d arguments\n", arg1->parameters.parameters_len);
	for (a=arg1->parameters.parameters_len-1;a>=0;a--) {
		ptr=arg1->parameters.parameters_val;
		debug(" %d Type %d : ",a,ptr[a].dtype);
		switch(arg1->parameters.parameters_val[a].dtype) {
		case 0: push_char(ptr[a].single_dtype_u.chardata); break;
		case 1: push_int(ptr[a].single_dtype_u.shortval); break;
		case 2:
		case 6:
		case 7:
		case 8:	push_long(ptr[a].single_dtype_u.longval); break;
		case 3:	
debug("RPC Double:%lf",ptr[a].single_dtype_u.floatval);
push_double(ptr[a].single_dtype_u.floatval);
 break;
		case 4:	push_float(ptr[a].single_dtype_u.smfltval); break;
		default:  exitwith("Unprintable datatype");return 0;
		}
	}


	if (async==1) {
		result.return_values_len=1;
		result.return_values_val=malloc(sizeof(object_data)*1);
		result.return_values_val[0].dtype=2;	
		result.return_values_val[0].single_dtype_u.longval=0;
	        fgl_rpc_reply(&result);
	}


/************************************************************/

	z=call_func(func_name,arg1->parameters.parameters_len);

/************************************************************/

	debug("Function returns %d values",z);
	result.return_values_len=z;

        if (result.return_values_val) free(result.return_values_val);

	result.return_values_val=malloc(sizeof(object_data)*z);
	result.return_values_val[0].dtype=2;	
	result.return_values_val[0].single_dtype_u.longval=status;

	for (a=z;a>1;a--) {
		ptr=result.return_values_val;
		get_top_of_stack(1,&d,&s,&p);

		debug("Top of stack return %d %d %p (%d)",d,s,p);
		ptr[a-1].dtype=d&15;

		switch (d&15) {
			case 0: ptr[a-1].single_dtype_u.chardata=(char *)char_pop(); break;
			case 1: ptr[a-1].single_dtype_u.shortval=pop_int();break;
			case 6:
			case 7:
			case 8:	
			case 2: ptr[a-1].single_dtype_u.longval=pop_long();break;

			case 3:	ptr[a-1].single_dtype_u.floatval=pop_double();break;
			case 4:	ptr[a-1].single_dtype_u.smfltval=pop_float(); break;
			default :	exitwith("Untransmittable data");
		}
	}

	if (async==1) {
		/* might have returned results but ignore them... */
		result.return_values_len=1;
		return 0;
	}

	return(&result);
}


/**
 * Call a function registred in the pointer tree.
 *
 * @param s The function name to be called.
 * @param a The number of parameters to be passed by the stack.
 * @return 
 *   - 1 : The function was not registered.
 */
call_func(char *s,int a) {
void *ptr;
int z;
int (*func)(int a);
	debug("In call_func");
	if (has_pointer(s,RPC_FUNC)) {
		debug("Function has been registered");
		func=find_pointer(s,RPC_FUNC);
		z=func(a);
		return z+1;
	} else {
		exitwith("Function not registered");
		return 1;
	}
}


