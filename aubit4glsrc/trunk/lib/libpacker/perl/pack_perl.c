/*
# +----------------------------------------------------------------------+
# | Aubit 4gl Language Compiler Version $.0                              |
# +----------------------------------------------------------------------+
# | Copyright (c) 2000-2005 Aubit Development Team (See Credits file)    |
# +----------------------------------------------------------------------+
# | This program is free software; you can redistribute it and/or modify |
# | it under the terms of one of the following licenses:                 |
# |                                                                      |
# |  A) the GNU General Public License as published by the Free Software |
# |     Foundation; either version 2 of the License, or (at your option) |
# |     any later version.                                               |
# |                                                                      |
# |  B) the Aubit License as published by the Aubit Development Team and |
# |     included in the distribution in the file: LICENSE                |
# |                                                                      |
# | This program is distributed in the hope that it will be useful,      |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of       |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        |
# | GNU General Public License for more details.                         |
# |                                                                      |
# | You should have received a copy of both licenses referred to here.   |
# | If you did not, or have any questions about Aubit licensing, please  |
# | contact afalout@ihug.co.nz                                           |
# +----------------------------------------------------------------------+
#
# $Id: pack_perl.c,v 1.15 2008-02-11 17:13:13 mikeaubury Exp $
#*/

/**
 * @file
 * XML packer
 *
 * This will write correct XML but will only read XML generated by these output
 * routines. This is because we didn't want to write a full XML parser, so the
 * input routines make assumptions on the data being read and its format WRT
 * whitespace
 *
 *
 *
 * @todo Doxygen comments to add to functions
 */



/*
=====================================================================
		                    Includes
=====================================================================
*/

#include "a4gl_lib_packer_perl_int.h"
#include <ctype.h>

/*
=====================================================================
                    Constants definitions
=====================================================================
*/

/* Do we want the output indented ? */
#define INDENT

/*
=====================================================================
                    Variables definitions
=====================================================================
*/

FILE *infile = 0;
FILE *outfile = 0;


char ibuff[20000];		/* Input line buffer */

int attrok = 0;
int contentok = 0;
int structs[1000];
int structs_cnt = 0;


/*
=====================================================================
                    Functions prototypes
=====================================================================
*/

char *A4GL_find_attr (char *s, char *n);	/* Extract a specified attribute from a string */
char *A4GL_find_contents (char *s);	/* Extract the tag contents from a string */

char *A4GL_escape_str (char *s, char q, char e);
void A4GL_pr_nl (void);
void A4GL_pr1 (void);

/*
--------------------------------
 Internal helper functions
--------------------------------
*/
#ifdef _TESTING_
static chk (void *x);
#endif
static void out_only (void);


/*
=====================================================================
                    Functions definitions
=====================================================================
*/

/*
--------------------------------
--- API Functions
--------------------------------
*/

/*
-------------------------------------------------------------
 File IO routines
-------------------------------------------------------------
*/

int A4GLPacker_A4GL_pack_remove_file(char *fname) {
        char buff[512];
        sprintf (buff, "%s.pl",fname);
        return A4GL_delete_file(buff);
}


/**
 *
 * @todo Describe function
 */
int
A4GLPacker_A4GL_open_packer (char *basename, char dir,char *packname)
{
  char buff[256];
  sprintf (buff, "%s.pl", basename);


  if (toupper (dir) == 'O')
    {
      outfile = fopen (buff, "w");
      if (outfile)
	{
	  fprintf (outfile, "#!/bin/perl\n");
	  fprintf (outfile, "%%report=(\n");	/* warning: unknown conversion type character `r' in format */

	  return 1;
	}
      return 0;
    }

  if (toupper (dir) == 'I')
    {
      out_only ();
      return 0;
    }

  return 0;

}

/**
 *
 * @todo Describe function
 */
void
A4GLPacker_A4GL_close_packer (char dir)
{
  if (toupper (dir) == 'O')
    {
      fprintf (outfile, ");\n");

      fclose (outfile);
    }

  if (toupper (dir) == 'I')
    out_only ();
}

/*
----------------------------------------------------------------------------
 Output routines
----------------------------------------------------------------------------
*/

/**
 *
 * @todo Describe function
 */
int
A4GLPacker_output_start_array (char *s, int type, int len)
{
  A4GL_pr1 ();
  structs_cnt++;
  structs[structs_cnt] = 0;
  fprintf (outfile, "\"%s\"=>{", s);	/* Was [ */
  A4GL_pr_nl ();
  return 1;
}

/**
 *
 * @todo Describe function
 */
int
A4GLPacker_output_end_array (char *s, int type,int len)
{
  fprintf (outfile, "}");	/* Was ] */
  structs_cnt--;
  A4GL_pr_nl ();
  return 1;
}

/**
 *
 * @todo Describe function
 */
void
A4GL_pr1 (void)
{
  if (structs[structs_cnt])
    {
      fprintf (outfile, ",");
      A4GL_pr_nl ();
    }
  structs[structs_cnt]++;
}

/**
 *
 * @todo Describe function
 */
int
A4GLPacker_output_int (char *name, int val, int ptr, int isarr)
{
  A4GL_pr1 ();
  if (isarr >= 0)
    fprintf (outfile, "%d => %d", isarr, val);
  else
    fprintf (outfile, "\"%s\"=>%d", name, val);
  return 1;
}


int
A4GLPacker_output_short (char *name, short val, int ptr, int isarr)
{
  A4GL_pr1 ();
  if (isarr >= 0)
    fprintf (outfile, "%d => %d", isarr, val);
  else
    fprintf (outfile, "\"%s\"=>%d", name, val);
  return 1;
}

/**
 *
 * @todo Describe function
 */
int
A4GLPacker_output_long (char *name, long val, int ptr, int isarr)
{
  A4GL_pr1 ();
  if (isarr >= 0)
    fprintf (outfile, "%d=>%d", isarr, (int) val);
  else
    fprintf (outfile, "\"%s\"=>%d", name, (int) val);
  return 1;
}


/**
 *
 * @todo Describe function
 */
int
A4GLPacker_output_bool (char *name, int val, int ptr, int isarr)
{
  A4GL_pr1 ();
  if (isarr >= 0)
    fprintf (outfile, "%d=>%d", isarr, val);
  else
    fprintf (outfile, "\"%s\"=>%d", name, val);

  return 1;
}

/**
 *
 * @todo Describe function
 */
int
A4GLPacker_output_string (char *name, char *val, int ptr, int isarr)
{
  A4GL_pr1 ();
  if (isarr >= 0)
    fprintf (outfile, "%d=>\'%s\'", isarr, A4GL_escape_str (val, '\'', '\\'));
  else
    fprintf (outfile, "\"%s\"=>\'%s\'", name, A4GL_escape_str (val, '\'', '\\'));
  return 1;
}

int
A4GLPacker_output_char (char *name, char valc, int ptr, int isarr)
{
	char val[255];
	val[0]=valc;
	val[1]=0;

  A4GL_pr1 ();
  if (isarr >= 0)
    fprintf (outfile, "%d=>%d", isarr, valc);
  else
    fprintf (outfile, "\"%s\"=>%d", name, valc);
  return 1;
}

/**
 *
 * @todo Describe function
 */
int
A4GLPacker_output_double (char *name, double val, int ptr, int isarr)
{
  A4GL_pr1 ();
  if (isarr >= 0)
    fprintf (outfile, "%d=>%f", isarr, val);
  else
    fprintf (outfile, "\"%s\"=>%f", name, val);
  return 1;
}

/**
 *
 * @todo Describe function
 */
int
A4GLPacker_output_start_struct (char *s, char *n, int ptr, int isarr)
{
  A4GL_pr1 ();
  structs_cnt++;
  structs[structs_cnt] = 0;

  if (isarr == -1)
    fprintf (outfile, "\"%s\"=> {", n);	/*, s); */
  else
    fprintf (outfile, "\"%d\"=> {", isarr);	/* , s); */
  return 1;
}

/**
 *
 * @todo Describe function
 */
int
A4GLPacker_output_end_struct (char *s, char *n)
{
  structs_cnt--;
  fprintf (outfile, "}");	/*, n, s); */
  A4GL_pr_nl ();
  return 1;
}

/**
 *
 * @todo Describe function
 */
int
A4GLPacker_output_start_union (char *s, char *en, int e, char *n, int ptr, int isarr)
{
  if (!output_int(en,e,ptr,isarr)) return 0;
  A4GL_pr1 ();
  structs_cnt++;
  structs[structs_cnt] = 0;
  if (isarr == -1)
    {
      fprintf (outfile, "\"%s\"=> {", n);
    }
  else
    {
      fprintf (outfile, "\"%d\"=> {", isarr);
    }
  return 1;
}

/**
 *
 * @todo Describe function
 */
int
A4GLPacker_output_nullptr (char *s,char *sname, int isunion)
{
  A4GL_pr1 ();
  fprintf (outfile, " \"hasvalue\"=>0 ");
  return 1;
}

/**
 *
 * @todo Describe function
 */
int
A4GLPacker_output_okptr (char *s)
{
  A4GL_pr1 ();
  fprintf (outfile, " \"hasvalue\"=>1 ");
  return 1;
}

/**
 *
 * @todo Describe function
 */
int
A4GLPacker_output_end_union (char *s, char *en, int e, char *n)
{
  structs_cnt--;
  fprintf (outfile, "}");
  A4GL_pr_nl ();
  return 1;
}

/**
 *
 * @todo Describe function
 */
int
A4GLPacker_output_enum (char *rn, char *name, char *s, int d)
{
  A4GL_pr1 ();
  fprintf (outfile, "\"%s\"=>\"%s\"", rn, s);
  return 1;
}



/**
 *
 * @todo Describe function
 */
void
A4GL_pr_nl (void)
{
  int a;
  fprintf (outfile, "\n");
  for (a = 0; a < structs_cnt; a++)
    fprintf (outfile, "  ");
}

/*
------------------------------------------------------------------------------
 Input Routines
------------------------------------------------------------------------------
*/

/**
 *
 * @todo Describe function
 */
static void
out_only (void)
{
  printf ("Error - this is an output only library...\n");
}

/**
 *
 * @todo Describe function
 */
int
A4GLPacker_input_start_array (char *s, int type, int *len)
{
  out_only ();
  return 0;
}

/**
 *
 * @todo Describe function
 */
int
A4GLPacker_input_end_array (char *s, int type)
{
  out_only ();
  return 0;
}


/**
 *
 * @todo Describe function
 */
int
A4GLPacker_input_int (char *name, int *val, int ptr, int isarr)
{
  out_only ();
  return 0;
}

/**
 *
 * @todo Describe function
 */
int
A4GLPacker_input_long (char *name, long *val, int ptr, int isarr)
{
  out_only ();
  return 0;
}


/**
 *
 * @todo Describe function
 */
int
A4GLPacker_input_bool (char *name, int *val, int ptr, int isarr)
{
  out_only ();
  return 0;
}


/**
 *
 * @todo Describe function
 */
int
A4GLPacker_input_string (char *name, char **val, int ptr, int isarr)
{
  out_only ();
  return 0;
}

/**
 *
 * @todo Describe function
 */
int
A4GLPacker_input_double (char *name, double *val, int ptr, int isarr)
{
  out_only ();
  return 0;
}

/**
 *
 * @todo Describe function
 */
int
A4GLPacker_input_start_struct (char *s, char *n, int ptr, int isarr)
{
  out_only ();
  return 0;
}

/**
 *
 * @todo Describe function
 */
int
A4GLPacker_input_end_struct (char *s, char *n)
{
  out_only ();
  return 0;
}

/**
 *
 * @todo Describe function
 */
int A4GLPacker_input_start_union(char* s,char* enumname,int* enum_val,char* n,int ptr,int isarr)
{
  out_only ();
  return 0;
}

/**
 *
 * @todo Describe function
 */
int
A4GLPacker_input_ptr_ok (void)
{
  out_only ();
  return 0;
}

/**
 *
 * @todo Describe function
 */
int
A4GLPacker_input_end_union (char *s,  char *en, int e,char *n)
{
  out_only ();
  return 0;
}

/**
 *
 * @todo Describe function
 */
int
A4GLPacker_input_enum (char *rn, char *name, int *d)
{
  out_only ();
  return 0;
}


/**
 *
 * @todo Describe function
 */
char *
A4GL_escape_str (char *s, char q, char e)
{
  static char buff[2000];
  int buffcnt = 0;
  int a;
  for (a = 0; a < strlen (s); a++)
    {
      if (s[a] == e)
	{			/* Escape our escape character */
	  buff[buffcnt++] = e;
	  buff[buffcnt++] = e;
	  continue;
	}
      if (s[a] == q)
	{			/* Escape a quote */
	  buff[buffcnt++] = e;
	  buff[buffcnt++] = q;
	  continue;
	}

      buff[buffcnt++] = s[a];
    }

  buff[buffcnt++] = 0;

  return buff;
}


/**
 *
 * @todo Describe function
 */
int
A4GLPacker_A4GL_can_pack_all (char *name)
{
  return 0;
}

/* =================================== EOF ============================== */
