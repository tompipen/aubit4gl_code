/*
# +----------------------------------------------------------------------+
# | Aubit 4gl Language Compiler Version $.0                              |
# +----------------------------------------------------------------------+
# | Copyright (c) 2000-1 Aubit Development Team (See Credits file)       |
# +----------------------------------------------------------------------+
# | This program is free software; you can redistribute it and/or modify |
# | it under the terms of one of the following licenses:                 |
# |                                                                      |
# |  A) the GNU General Public License as published by the Free Software |
# |     Foundation; either version 2 of the License, or (at your option) |
# |     any later version.                                               |
# |                                                                      |
# |  B) the Aubit License as published by the Aubit Development Team and |
# |     included in the distribution in the file: LICENSE                |
# |                                                                      |
# | This program is distributed in the hope that it will be useful,      |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of       |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        |
# | GNU General Public License for more details.                         |
# |                                                                      |
# | You should have received a copy of both licenses referred to here.   |
# | If you did not, or have any questions about Aubit licensing, please  |
# | contact afalout@ihug.co.nz                                           |
# +----------------------------------------------------------------------+
#
# $Id: pack_perl.c,v 1.3 2002-07-31 15:30:29 mikeaubury Exp $
#*/

/**
 * @file
 * XML packer
 *
 * This will write correct XML but will only read XML generated by these output
 * routines. This is because we didn't want to write a full XML parser, so the
 * input routines make assumptions on the data being read and its format WRT
 * whitespace
 *
 *
 *
 * @todo Doxygen comments to add to functions
 */



/*
=====================================================================
		                    Includes
=====================================================================
*/

#ifdef OLD_INCL
	#include <stdlib.h>
	#include <stdio.h>
	#include <string.h>
#else
    #define _NO_FORM_X_H_
	/* FIXME: this should be a4gl_lib_packer_perl_int.h */
	#include "a4gl_libaubit4gl.h"
#endif


/*
=====================================================================
                    Constants definitions
=====================================================================
*/

/* Do we want the output indented ? */
#define INDENT

/*
=====================================================================
                    Variables definitions
=====================================================================
*/

FILE *infile = 0;
FILE *outfile = 0;


char ibuff[20000];		/* Input line buffer */

int attrok = 0;
int contentok = 0;
int structs[1000];
int structs_cnt=0;


/*
=====================================================================
                    Functions prototypes
=====================================================================
*/

char *find_attr (char *s, char *n);	/* Extract a specified attribute from a string */
char *find_contents (char *s);		/* Extract the tag contents from a string */

int input_int (char *name, int *val, int ptr, int isarr);
int input_long (char *name, long *val, int ptr, int isarr);
int input_bool (char *name, int *val, int ptr, int isarr);
int input_string (char *name, char **val, int ptr, int isarr);
int input_double (char *name, double *val, int ptr, int isarr);
int input_start_struct (char *s, char *n, int ptr, int isarr);
int input_end_struct (char *s, char *n);
int input_start_union (char *s, char *n, int ptr, int isarr);
int input_ptr_ok (void);
int input_end_union (char *s, char *n);
int input_enum (char *name, int *d);

int output_int (char *name, int val, int ptr, int isarr);
int output_long (char *name, long val, int ptr, int isarr);
int output_bool (char *name, int val, int ptr, int isarr);
int output_string (char *name, char *val, int ptr, int isarr);
int output_double (char *name, double val, int ptr, int isarr);
int output_start_struct (char *s, char *n, int ptr, int isarr);
int output_end_struct (char *s, char *n);
int output_start_union (char *s, char *n, int ptr, int isarr);
int output_nullptr (char *s);
int output_okptr (char *s);
int output_end_union (char *s, char *n);
int output_enum (char *name, char *s, int d);

char *escape_str(char *s,char q,char e) ;

int input_start_array (char *s, int type, int *len);
int input_end_array (char *s, int type);
int can_pack_all(char *name);
void pr_nl(void);
int open_packer (char *basename, char dir);
void close_packer (char dir);
int output_start_array (char *s, int type, int len);
void pr1(void);
int output_end_array (char *s, int type);

/*
--------------------------------
 Internal helper functions
--------------------------------
*/
#ifdef _TESTING_
	static chk (void *x);
#endif
static void out_only(void) ;


/*
=====================================================================
                    Functions definitions
=====================================================================
*/

/*
--------------------------------
--- API Functions
--------------------------------
*/

/*
-------------------------------------------------------------
 File IO routines
-------------------------------------------------------------
*/


/**
 *
 * @todo Describe function
 */
int
open_packer (char *basename, char dir)
{
  char buff[256];
  sprintf (buff, "%s.pl", basename);


  if (toupper (dir) == 'O')
    {
      outfile = fopen (buff, "w");
      if (outfile) {
         fprintf(outfile,"#!/bin/perl\n");
         fprintf(outfile,"%%report=(\n"); /* warning: unknown conversion type character `r' in format */

	 return 1;
      }
      return 0;
    }

  if (toupper (dir) == 'I')
    {
	out_only();
	return 0;
    }

  return 0;

}

/**
 *
 * @todo Describe function
 */
void
close_packer (char dir)
{
  if (toupper (dir) == 'O') {
         fprintf(outfile,");\n");

    fclose (outfile);
  }

  if (toupper (dir) == 'I')
	out_only();
}

/*
----------------------------------------------------------------------------
 Output routines
----------------------------------------------------------------------------
*/

/**
 *
 * @todo Describe function
 */
int
output_start_array (char *s, int type, int len)
{
  pr1();
  structs_cnt++;
  structs[structs_cnt]=0;
  fprintf (outfile, "\"%s\"=>{", s); /* Was [ */
	pr_nl();
  return 1;
}

/**
 *
 * @todo Describe function
 */
int
output_end_array (char *s, int type)
{
  fprintf (outfile, "}"); /* Was ] */
  structs_cnt--;
	pr_nl();
  return 1;
}

/**
 *
 * @todo Describe function
 */
void
pr1(void)
{
	if (structs[structs_cnt]) {
		fprintf(outfile,",");
		pr_nl();
	}
	structs[structs_cnt]++;
}

/**
 *
 * @todo Describe function
 */
int
output_int (char *name, int val, int ptr, int isarr)
{
pr1();
     if (isarr>=0) fprintf (outfile, "%d => %d",isarr,val);
     else fprintf (outfile, "\"%s\"=>%d", name,val);
  return 1;
}

/**
 *
 * @todo Describe function
 */
int
output_long (char *name, long val, int ptr, int isarr)
{
pr1();
  if (isarr>=0) fprintf (outfile, "%d=>%d",isarr,(int)val);
  else	fprintf (outfile, "\"%s\"=>%d", name,(int)val);
  return 1;
}


/**
 *
 * @todo Describe function
 */
int
output_bool (char *name, int val, int ptr, int isarr)
{
pr1();
  if (isarr>=0) fprintf (outfile, "%d=>%d",isarr,val);
  else fprintf (outfile, "\"%s\"=>%d", name,val);

  return 1;
}

/**
 *
 * @todo Describe function
 */
int
output_string (char *name, char *val, int ptr, int isarr)
{
pr1();
  if (isarr>=0) fprintf (outfile, "%d=>\'%s\'", isarr,escape_str(val,'\'','\\'));
	else fprintf (outfile, "\"%s\"=>\'%s\'", name,escape_str(val,'\'','\\'));
  return 1;
}

/**
 *
 * @todo Describe function
 */
int
output_double (char *name, double val, int ptr, int isarr)
{
  pr1();
  if (isarr>=0) fprintf (outfile, "%d=>%f",isarr,val);
  else fprintf (outfile, "\"%s\"=>%f", name,val);
  return 1;
}

/**
 *
 * @todo Describe function
 */
int
output_start_struct (char *s, char *n, int ptr, int isarr)
{
pr1();
  structs_cnt++;
  structs[structs_cnt]=0;

if (isarr==-1)
  fprintf (outfile, "\"%s\"=> {", n); /*, s);*/
else
  fprintf (outfile, "\"%d\"=> {", isarr); /* , s); */
  return 1;
}

/**
 *
 * @todo Describe function
 */
int
output_end_struct (char *s, char *n)
{
  structs_cnt--;
  fprintf (outfile, "}"); /*, n, s); */
	pr_nl();
  return 1;
}

/**
 *
 * @todo Describe function
 */
int
output_start_union (char *s, char *n, int ptr, int isarr)
{
pr1();
	  structs_cnt++;
	  structs[structs_cnt]=0;
	 if (isarr==-1) {
	  fprintf (outfile, "\"%s\"=> {",  n);
	} else {
	  fprintf (outfile, "\"%d\"=> {",  isarr);
	}
	  return 1;
}

/**
 *
 * @todo Describe function
 */
int
output_nullptr (char *s)
{
pr1();
  fprintf (outfile, " \"hasvalue\"=>0 ");
  return 1;
}

/**
 *
 * @todo Describe function
 */
int
output_okptr (char *s)
{
pr1();
  fprintf (outfile, " \"hasvalue\"=>1 ");
  return 1;
}

/**
 *
 * @todo Describe function
 */
int
output_end_union (char *s, char *n)
{
  structs_cnt--;
  fprintf (outfile, "}");
	pr_nl();
  return 1;
}

/**
 *
 * @todo Describe function
 */
int
output_enum (char *name, char *s, int d)
{
pr1();
  fprintf (outfile, "\"%s\"=>\"%s\"", name,  s);
  return 1;
}



/**
 *
 * @todo Describe function
 */
void
pr_nl(void)
{
int a;
	fprintf(outfile,"\n");
	for (a=0;a<structs_cnt;a++) fprintf(outfile,"  ");
}

/*
------------------------------------------------------------------------------
 Input Routines
------------------------------------------------------------------------------
*/

/**
 *
 * @todo Describe function
 */
static void 
out_only(void) 
{
	printf("Error - this is an output only library...\n");
}

/**
 *
 * @todo Describe function
 */
int
input_start_array (char *s, int type, int *len)
{
	out_only(); return 0;
}

/**
 *
 * @todo Describe function
 */
int
input_end_array (char *s, int type)
{
	out_only(); return 0;
}


/**
 *
 * @todo Describe function
 */
int
input_int (char *name, int *val, int ptr, int isarr)
{
	out_only(); return 0;
}

/**
 *
 * @todo Describe function
 */
int
input_long (char *name, long *val, int ptr, int isarr)
{
	out_only(); return 0;
}


/**
 *
 * @todo Describe function
 */
int
input_bool (char *name, int *val, int ptr, int isarr)
{
	out_only(); return 0;
}


/**
 *
 * @todo Describe function
 */
int
input_string (char *name, char **val, int ptr, int isarr)
{
	out_only(); return 0;
}

/**
 *
 * @todo Describe function
 */
int
input_double (char *name, double *val, int ptr, int isarr)
{
	out_only(); return 0;
}

/**
 *
 * @todo Describe function
 */
int
input_start_struct (char *s, char *n, int ptr, int isarr)
{
	out_only(); return 0;
}

/**
 *
 * @todo Describe function
 */
int
input_end_struct (char *s, char *n)
{
	out_only(); return 0;
}

/**
 *
 * @todo Describe function
 */
int
input_start_union (char *s, char *n, int ptr, int isarr)
{
	out_only(); return 0;
}

/**
 *
 * @todo Describe function
 */
int
input_ptr_ok (void)
{
	out_only(); return 0;
}

/**
 *
 * @todo Describe function
 */
int
input_end_union (char *s, char *n)
{
	out_only(); return 0;
}

/**
 *
 * @todo Describe function
 */
int
input_enum (char *name, int *d)
{
	out_only(); return 0;
}


/**
 *
 * @todo Describe function
 */
char *
escape_str(char *s,char q,char e)
{
static char buff[2000];
int buffcnt=0;
int a;
	for (a=0;a<strlen(s);a++) {
		if (s[a]==e) { /* Escape our escape character */
				buff[buffcnt++]=e;
				buff[buffcnt++]=e;
				continue;
		}
		if (s[a]==q) { /* Escape a quote */
				buff[buffcnt++]=e;
				buff[buffcnt++]=q;
				continue;
		}

		buff[buffcnt++]=s[a];
	}

	buff[buffcnt++]=0;

	return buff;
}


/**
 *
 * @todo Describe function
 */
int
can_pack_all(char *name)
{
	return 0;
}

/* =================================== EOF ============================== */

