// XML packer.
//
//  NOTE : This will write correct XML
//         but will only read XML generated by these output routines...
//         (This is because we didn't want to write a full XML parser, so the 
//          input routines make assumptions on the data being read and its format WRT whitespace)
//
//

// Do we want the output indented ?
#define INDENT
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

FILE *infile = 0;
FILE *outfile = 0;


char ibuff[20000];		// Input line buffer
char *find_attr (char *s, char *n);	// Extract a specified attribute from a string
char *find_contents (char *s);	// Extract the tag contents from a string

int attrok = 0;
int contentok = 0;

int input_int (char *name, int *val, int ptr, int isarr);
int input_long (char *name, long *val, int ptr, int isarr);
int input_bool (char *name, int *val, int ptr, int isarr);
int input_string (char *name, char **val, int ptr, int isarr);
int input_double (char *name, double *val, int ptr, int isarr);
int input_start_struct (char *s, char *n, int ptr, int isarr);
int input_end_struct (char *s, char *n);
int input_start_union (char *s, char *n, int ptr, int isarr);
int input_ptr_ok (void);
int input_end_union (char *s, char *n);
int input_enum (char *name, int *d);

int output_int (char *name, int val, int ptr, int isarr);
int output_long (char *name, long val, int ptr, int isarr);
int output_bool (char *name, int val, int ptr, int isarr);
int output_string (char *name, char *val, int ptr, int isarr);
int output_double (char *name, double val, int ptr, int isarr);
int output_start_struct (char *s, char *n, int ptr, int isarr);
int output_end_struct (char *s, char *n);
int output_start_union (char *s, char *n, int ptr, int isarr);
int output_nullptr (char *s);
int output_okptr (char *s);
int output_end_union (char *s, char *n);
int output_enum (char *name, char *s, int d);

int structs[1000];
int structs_cnt=0;
char *escape_str(char *s,char q,char e) ;

//--------------------------------
// Internal helper functions
//--------------------------------
static chk (void *x);

static void out_only() ;




//--------------------------------
//--- API Functions
//--------------------------------


//-------------------------------------------------------------
// File IO routines
//-------------------------------------------------------------

int
open_packer (char *basename, char dir)
{
  char buff[256];
  sprintf (buff, "%s.pl", basename);


  if (toupper (dir) == 'O')
    {
      outfile = fopen (buff, "w");
      if (outfile) {
         fprintf(outfile,"#!/bin/perl\n");
         fprintf(outfile,"%report=(\n");
	
	 return 1;
      }
      return 0;
    }

  if (toupper (dir) == 'I')
    {
	out_only();
	return 0;
    }

  return 0;

}

void
close_packer (char dir)
{
  if (toupper (dir) == 'O') {
         fprintf(outfile,");\n");
	
    fclose (outfile);
  }

  if (toupper (dir) == 'I') 
	out_only();
}

//----------------------------------------------------------------------------
// Output routines
//----------------------------------------------------------------------------

int
output_start_array (char *s, int type, int len)
{
  pr1();
  structs_cnt++;
  structs[structs_cnt]=0;
  fprintf (outfile, "\"%s\"=>{", s); // Was [
	pr_nl();
  return 1;
}

int
output_end_array (char *s, int type)
{
  fprintf (outfile, "}"); // Was ]
  structs_cnt--;
	pr_nl();
  return 1;
}

pr1() {

if (structs[structs_cnt]) {
	fprintf(outfile,",");
	pr_nl();
}
structs[structs_cnt]++;
}

int
output_int (char *name, int val, int ptr, int isarr)
{
pr1();
     if (isarr>=0) fprintf (outfile, "%d => %d",isarr,val);
     else fprintf (outfile, "\"%s\"=>%d", name,val);
  return 1;
}

int
output_long (char *name, long val, int ptr, int isarr)
{
pr1();
  if (isarr>=0) fprintf (outfile, "%d=>%d",isarr,val); 
  else	fprintf (outfile, "\"%s\"=>%d", name,val);
  return 1;
}


int
output_bool (char *name, int val, int ptr, int isarr)
{
pr1();
  if (isarr>=0) fprintf (outfile, "%d=>%d",isarr,val); 
  else fprintf (outfile, "\"%s\"=>%d", name,val);

  return 1;
}

int
output_string (char *name, char *val, int ptr, int isarr)
{
pr1();
  if (isarr>=0) fprintf (outfile, "%d=>\"%s\"", isarr,escape_str(val,'"','\\'));
	else fprintf (outfile, "\"%s\"=>\"%s\"", name,escape_str(val,'"','\\'));
  return 1;
}

int
output_double (char *name, double val, int ptr, int isarr)
{
  pr1();
  if (isarr>=0) fprintf (outfile, "%d=>%f",isarr,val); 
  else fprintf (outfile, "\"%s\"=>%f", name,val);
  return 1;
}

int
output_start_struct (char *s, char *n, int ptr, int isarr)
{
pr1();
  structs_cnt++;
  structs[structs_cnt]=0;

if (isarr==-1) 
  fprintf (outfile, "\"%s\"=> {", n, s);
else
  fprintf (outfile, "\"%d\"=> {", isarr, s);
  return 1;
}

int
output_end_struct (char *s, char *n)
{
  structs_cnt--;
  fprintf (outfile, "}", n, s);
	pr_nl();
  return 1;
}

int
output_start_union (char *s, char *n, int ptr, int isarr)
{
pr1();
  structs_cnt++;
  structs[structs_cnt]=0;
 if (isarr==-1) {
  fprintf (outfile, "\"%s\"=> {",  n);
} else {
  fprintf (outfile, "\"%d\"=> {",  isarr);
}
  return 1;
}

int
output_nullptr (char *s)
{
pr1();
  fprintf (outfile, " \"hasvalue\"=>0 ");
  return 1;
}

int
output_okptr (char *s)
{
pr1();
  fprintf (outfile, " \"hasvalue\"=>1 ");
  return 1;
}

int
output_end_union (char *s, char *n)
{
  structs_cnt--;
  fprintf (outfile, "}");
	pr_nl();
  return 1;
}

int
output_enum (char *name, char *s, int d)
{
pr1();
  fprintf (outfile, "\"%s\"=>\"%s\"", name,  s);
  return 1;
}



pr_nl() {
int a;
fprintf(outfile,"\n");
for (a=0;a<structs_cnt;a++) fprintf(outfile,"  ");
}
//------------------------------------------------------------------------------
// Input Routines
//------------------------------------------------------------------------------

static void out_only() {
	printf("Error - this is an output only library...\n");
}

int
input_start_array (char *s, int type, int *len)
{
	out_only(); return 0;
}

int
input_end_array (char *s, int type)
{
	out_only(); return 0;
}


int
input_int (char *name, int *val, int ptr, int isarr)
{
	out_only(); return 0;
}

int
input_long (char *name, long *val, int ptr, int isarr)
{
	out_only(); return 0;
}


int
input_bool (char *name, int *val, int ptr, int isarr)
{
	out_only(); return 0;
}


int
input_string (char *name, char **val, int ptr, int isarr)
{
	out_only(); return 0;
}

int
input_double (char *name, double *val, int ptr, int isarr)
{
	out_only(); return 0;
}

int
input_start_struct (char *s, char *n, int ptr, int isarr)
{
	out_only(); return 0;
}

int
input_end_struct (char *s, char *n)
{
	out_only(); return 0;
}

int
input_start_union (char *s, char *n, int ptr, int isarr)
{
	out_only(); return 0;
}

int
input_ptr_ok ()
{
	out_only(); return 0;
}

int
input_end_union (char *s, char *n)
{
	out_only(); return 0;
}

int
input_enum (char *name, int *d)
{
	out_only(); return 0;
}


char *escape_str(char *s,char q,char e) {
static char buff[2000];
int buffcnt=0;
int a;
for (a=0;a<strlen(s);a++) {
	if (s[a]==e) { // Escape our escape character
			buff[buffcnt++]=e;
			buff[buffcnt++]=e;
			continue;
	} 
	if (s[a]==q) { // Escape a quote
			buff[buffcnt++]=e;
			buff[buffcnt++]=q;
			continue;
	}

	buff[buffcnt++]=s[a];
}

buff[buffcnt++]=0;

return buff;
}


int can_pack_all(char *name) {
	return 0;
}
