// XML packer.
//
//  NOTE : This will write correct XML
//         but will only read XML generated by these output routines...
//         (This is because we didn't want to write a full XML parser, so the 
//          input routines make assumptions on the data being read and its format WRT whitespace)
//
//

// Do we want the output indented ?
#define INDENT
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "a4gl_debug.h"

FILE *infile = 0;
FILE *outfile = 0;


//-----------------------------------------------------------------------------
// PORTABLE
//   Set if we are going to use network style integers
//   Not set if we are going to use native integers
// (On some platforms these may be the same, on others they won't be)
//-----------------------------------------------------------------------------

#ifdef PORTABLE

#include <netinet/in.h>
#else
#define htonl(x) (x)
#define htons(x) (x)

#define ntohl(x) (x)
#define ntohs(x) (x)
#endif

char ibuff[20000];		// Input line buffer
char *find_attr (char *s, char *n);	// Extract a specified attribute from a string
char *find_contents (char *s);	// Extract the tag contents from a string

int attrok = 0;
int contentok = 0;

int input_int (char *name, int *val, int ptr, int isarr);
int input_long (char *name, long *val, int ptr, int isarr);
int input_bool (char *name, int *val, int ptr, int isarr);
int input_string (char *name, char **val, int ptr, int isarr);
int input_double (char *name, double *val, int ptr, int isarr);
int input_start_struct (char *s, char *n, int ptr, int isarr);
int input_end_struct (char *s, char *n);
int input_start_union (char *s, char *n, int ptr, int isarr);
int input_ptr_ok (void);
int input_end_union (char *s, char *n);
int input_enum (char *name, int *d);

int output_int (char *name, int val, int ptr, int isarr);
int output_long (char *name, long val, int ptr, int isarr);
int output_bool (char *name, short val, int ptr, int isarr);
int output_string (char *name, char *val, int ptr, int isarr);
int output_double (char *name, double val, int ptr, int isarr);
int output_start_struct (char *s, char *n, int ptr, int isarr);
int output_end_struct (char *s, char *n);
int output_start_union (char *s, char *n, int ptr, int isarr);
int output_nullptr (char *s);
int output_okptr (char *s);
int output_end_union (char *s, char *n);
int output_enum (char *name, char *s, int d);


//--------------------------------
// Internal helper functions
//--------------------------------
static chk (void *x);

static
chk (void *x)
{
  if (x < 10000)
    {
      printf ("Suspect pointer...\n");
      exit (0);
    }
}


//--------------------------------
//--- API Functions
//--------------------------------


//-------------------------------------------------------------
// File IO routines
//-------------------------------------------------------------

int
open_packer (char *basename,char dir)
{
  char buff[256];
  sprintf (buff, "%s.dat", basename);


  if (toupper (dir) == 'O')
    {
      outfile = fopen (buff, "w");
      if (outfile)
	return 1;
      return 0;
    }

  if (toupper (dir) == 'I')
    {
      infile = open_file_dbpath (buff);
      if (infile)
	return 1;
      return 0;
    }

  return 0;

}

void
close_packer (char dir)
{
  if (toupper (dir) == 'O')
    fclose (outfile);

  if (toupper (dir) == 'I')
    fclose (infile);
}

//----------------------------------------------------------------------------
// Output routines
//----------------------------------------------------------------------------

int
output_start_array (char *s, int type, int len)
{
 
  return output_long(s,len,0,-1);
  //return fwrite(&len,1,sizeof(len),outfile);
}

int
output_end_array (char *s, int type)
{
  return 1;
}


int
output_short (char *name, short val, int ptr, int isarr)
{
  val=htons(val);
  return fwrite(&val,1,sizeof(val),outfile);
}


int
output_int (char *name, int val, int ptr, int isarr)
{
if (sizeof(int)==sizeof(long)) {
	return output_long(name,val,ptr,isarr);
} else {
	return output_short(name,val,ptr,isarr);
}
}

int
output_long (char *name, long val, int ptr, int isarr)
{
int a;
  debug("Outputing %s\n",name);
  val=htonl(val);
 a=fwrite(&val,1,sizeof(val),outfile);
	debug("a=%d\n",a);
 return a;
}


int
output_bool (char *name, short val, int ptr, int isarr)
{
return output_short(name,val,ptr,isarr);
}

int
output_string (char *name, char *val, int ptr, int isarr)
{
int a;
  debug("Output string");

  output_long(name,strlen(val),ptr,isarr);
  a=fwrite(val,1,strlen(val),outfile);

  if (strlen(val)==0) a=1;
  return a;
}

int
output_double (char *name, double val, int ptr, int isarr)
{
// FIX PORTABILITY....
  return fwrite(&val,1,sizeof(val),outfile);
}

int
output_start_struct (char *s, char *n, int ptr, int isarr)
{
  debug("Starting struct %s\n",s);
  return 1;
}

int
output_end_struct (char *s, char *n)
{
  return 1;
}

int
output_start_union (char *s, char *n, int ptr, int isarr)
{
  return 1;
}

int
output_nullptr (char *s)
{
  char n=0;
  return fwrite(&n,1,sizeof(n),outfile);
}

int
output_okptr (char *s)
{
  char n=1;
  return fwrite(&n,1,sizeof(n),outfile);
}

int
output_end_union (char *s, char *n)
{
  return 1;
}

int
output_enum (char *name, char *s, int d)
{
  return output_int (name, d, 0, -1);
}



//------------------------------------------------------------------------------
// Input Routines
//------------------------------------------------------------------------------



int
input_start_array (char *s, int type, int *len)
{
int a;
  a=input_int(s,len,0,-1);
  debug("ARRAY %s - Length of array=%d",s,*len);
return a;
}

int
input_end_array (char *s, int type)
{
  return 1;
}

int
input_short (char *name, short *val, int ptr, int isarr)
{
int a;
  a=fread(val,1,sizeof(short),infile);
  *val=ntohs(*val);
  return a;

}


int
input_int (char *name, int *val, int ptr, int isarr)
{
if (sizeof(int)==sizeof(long)) {
 return input_long(name,(long *)val,ptr,isarr);
} else {
 return input_short(name,(short *)val,ptr,isarr);
}
}

int
input_long (char *name, long *val, int ptr, int isarr)
{
  int a;
  long n;
  debug("Input_long val=%p",val);
  a=fread(val,1,sizeof(long),infile);

  debug("Got long as %d\n",*val);
  *val=ntohl(*val);
  debug("->Got long as %d\n",*val);
  return a;
}


int
input_bool (char *name, int *val, int ptr, int isarr)
{
	return input_short(name,(short *)val,ptr,isarr);
}


int
input_string (char *name, char **val, int ptr, int isarr)
{
long l;
int a;
debug("Inputing string %s",name);
if (!input_long("",&l,0,-1)) return 0;
debug("Got length as %d",l);
*val=malloc(l+1); // Extra 1 for the \0
a=fread(*val,1,l,infile);
if (a==0&&l==0) return 1;
return a;
}

int
input_double (char *name, double *val, int ptr, int isarr)
{
  return fread(&val,1,sizeof(val),infile);
}

int
input_start_struct (char *s, char *n, int ptr, int isarr)
{
  return 1;
}

int
input_end_struct (char *s, char *n)
{
  return 1;
}

int
input_start_union (char *s, char *n, int ptr, int isarr)
{
  return 1;
}

int
input_ptr_ok ()
{
char n;
fread(&n,1,sizeof(n),infile);
if (n) return 1;
else   return 0;
}

int
input_end_union (char *s, char *n)
{
  return 1;
}

int
input_enum (char *name, int *d)
{
return input_int(name,d,0,-1);
}

int can_pack_all() {
	return 0;
}

