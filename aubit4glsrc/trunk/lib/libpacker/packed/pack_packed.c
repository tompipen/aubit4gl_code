/*
# +----------------------------------------------------------------------+
# | Aubit 4gl Language Compiler Version $.0                              |
# +----------------------------------------------------------------------+
# | Copyright (c) 2000-1 Aubit Development Team (See Credits file)       |
# +----------------------------------------------------------------------+
# | This program is free software; you can redistribute it and/or modify |
# | it under the terms of one of the following licenses:                 |
# |                                                                      |
# |  A) the GNU General Public License as published by the Free Software |
# |     Foundation; either version 2 of the License, or (at your option) |
# |     any later version.                                               |
# |                                                                      |
# |  B) the Aubit License as published by the Aubit Development Team and |
# |     included in the distribution in the file: LICENSE                |
# |                                                                      |
# | This program is distributed in the hope that it will be useful,      |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of       |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        |
# | GNU General Public License for more details.                         |
# |                                                                      |
# | You should have received a copy of both licenses referred to here.   |
# | If you did not, or have any questions about Aubit licensing, please  |
# | contact afalout@ihug.co.nz                                           |
# +----------------------------------------------------------------------+
#
# $Id: pack_packed.c,v 1.7 2003-05-12 14:24:23 mikeaubury Exp $
#*/

/**
 * @file
 * XML packer
 *
 * This will write correct XML but will only read XML generated by these output
 * routines. This is because we didn't want to write a full XML parser, so the
 * input routines make assumptions on the data being read and its format WRT
 * whitespace
 *
 *
 *
 * @todo Doxygen comments to add to functions
 */

/*
=====================================================================
		                    Includes
=====================================================================
*/

#include "a4gl_lib_packer_packed_int.h"

/*
=====================================================================
                    Constants definitions
=====================================================================
*/

/*  Do we want the output indented ? */
#define INDENT


/*
-----------------------------------------------------------------------------
 PORTABLE
   Set if we are going to use network style integers
   Not set if we are going to use native integers
 (On some platforms these may be the same, on others they won't be)
-----------------------------------------------------------------------------
*/

#ifdef PORTABLE
#include <netinet/in.h>
#else
#ifndef htonl
#define htonl(x) (x)
#define htons(x) (x)
#define ntohl(x) (x)
#define ntohs(x) (x)
#endif
#endif

/*
=====================================================================
                    Variables definitions
=====================================================================
*/


FILE *infile = 0;
FILE *outfile = 0;

char ibuff[20000];		/* Input line buffer */

int attrok = 0;
int contentok = 0;
int is_in_mem = 0;

/*
=====================================================================
                    Functions prototypes
=====================================================================
*/

char *find_attr (char *s, char *n);	/* Extract a specified attribute from a string */
char *find_contents (char *s);	/* Extract the tag contents from a string */

/*
int input_int (char *name, int *val, int ptr, int isarr);
int input_long (char *name, long *val, int ptr, int isarr);
int input_bool (char *name, int *val, int ptr, int isarr);
int input_string (char *name, char **val, int ptr, int isarr);
int input_double (char *name, double *val, int ptr, int isarr);
int input_start_struct (char *s, char *n, int ptr, int isarr);
int input_end_struct (char *s, char *n);
int input_start_union (char *s, char *n, int ptr, int isarr);
int input_ptr_ok (void);
int input_end_union (char *s, char *n);
int input_enum (char *name, int *d);
int input_start_array (char *s, int type, int *len);
int input_end_array (char *s, int type);

int output_int (char *name, int val, int ptr, int isarr);
int output_long (char *name, long val, int ptr, int isarr);
int output_bool (char *name, short val, int ptr, int isarr);
int output_string (char *name, char *val, int ptr, int isarr);
int output_double (char *name, double val, int ptr, int isarr);
int output_start_struct (char *s, char *n, int ptr, int isarr);
int output_end_struct (char *s, char *n);
int output_start_union (char *s, char *n, int ptr, int isarr);
int output_nullptr (char *s);
int output_okptr (char *s);
int output_end_union (char *s, char *n);
int output_enum (char *name, char *s, int d);

int open_packer (char *basename,char dir);
void close_packer (char dir);
int output_start_array (char *s, int type, int len);
int output_end_array (char *s, int type);
int can_pack_all(void);
*/

int input_short (char *name, short *val, int ptr, int isarr);
int output_short (char *name, short val, int ptr, int isarr);

/*
=====================================================================
                    Functions definitions
=====================================================================
*/

#ifdef _TESTING_
/**
 * Internal helper function
 *
 * @todo Describe function
 */
static void chk (void *x);

static void
chk (void *x)
{
  if ((int) x < 10000)
    {
      printf ("Suspect pointer...\n");
      exit (0);
    }
}
#endif

/*
--------------------------------
--- API Functions
--------------------------------
*/

/*
-------------------------------------------------------------
 File IO routines
-------------------------------------------------------------
*/

/**
 *
 * @todo Describe function
 */
int
open_packer (char *basename, char dir)
{
  char buff[256];
  is_in_mem = 0;

  if (toupper (dir) == 'O')
    {
      sprintf (buff, "%s.dat", basename);
      outfile = fopen (buff, "w");

      if (outfile)
	{
	  set_last_outfile (buff);
	  return 1;
	}
      return 0;
    }

  if (toupper (dir) == 'I')
    {
      sprintf (buff, "%s.dat", basename);
      infile = open_file_dbpath (buff);
      if (infile)
	return 1;
      return 0;

    }





  return 0;

}

/**
 *
 * @todo Describe function
 */
void
close_packer (char dir)
{
  if (toupper (dir) == 'O')
    fclose (outfile);

  if (toupper (dir) == 'I')
    fclose (infile);
}

/*
----------------------------------------------------------------------------
 Output routines
----------------------------------------------------------------------------
*/

/**
 *
 * @todo Describe function
 */
int
output_start_array (char *s, int type, int len)
{

  return output_long (s, len, 0, -1);
  /* return fwrite(&len,1,sizeof(len),outfile); */
}

/**
 *
 * @todo Describe function
 */
int
output_end_array (char *s, int type)
{
  return 1;
}


/**
 *
 * @todo Describe function
 */
int
output_short (char *name, short val, int ptr, int isarr)
{
  debug ("Outputing SHORT %s : 0x%x", name, val);
  val = htons (val);
  return fwrite (&val, 1, sizeof (val), outfile);
}


/**
 *
 * @todo Describe function
 */
int
output_int (char *name, int val, int ptr, int isarr)
{
  if (sizeof (int) == sizeof (long))
    {
      return output_long (name, val, ptr, isarr);
    }
  else
    {
      return output_short (name, val, ptr, isarr);
    }
}

/**
 *
 * @todo Describe function
 */
int
output_long (char *name, long val, int ptr, int isarr)
{
  int a;
  debug ("Outputing LONG %s - 0x%x\n", name, val);
  val = htonl (val);
  a = fwrite (&val, 1, sizeof (val), outfile);
  debug ("a=%d\n", a);
  return a;
}


/**
 *
 * @todo Describe function
 */
int
//output_bool (char *name, short val, int ptr, int isarr)
output_bool (char *name, int val, int ptr, int isarr)
{
  return output_short (name, val, ptr, isarr);
}

/**
 *
 * @todo Describe function
 */
int
output_string (char *name, char *val, int ptr, int isarr)
{
  int a;
  debug ("Output string - length first (%d) pos=%d", strlen (val),
	 ftell (outfile));
  output_long (name, strlen (val), ptr, isarr);
  debug ("outputing string itself (%s)", val);
  a = fwrite (val, 1, strlen (val), outfile);

  if (strlen (val) == 0)
    a = 1;
  debug ("pos now = %d", ftell (outfile));
  return a;
}

/**
 *
 * @todo Describe function
 */
int
output_double (char *name, double val, int ptr, int isarr)
{
/*  FIX PORTABILITY.... */
  return fwrite (&val, 1, sizeof (val), outfile);
}

/**
 *
 * @todo Describe function
 */
int
output_start_struct (char *s, char *n, int ptr, int isarr)
{
  debug ("Starting struct %s\n", s);
  return 1;
}

/**
 *
 * @todo Describe function
 */
int
output_end_struct (char *s, char *n)
{
  return 1;
}

/**
 *
 * @todo Describe function
 */
int
output_start_union (char *s, char *n, int ptr, int isarr)
{
  return 1;
}

/**
 *
 * @todo Describe function
 */
int
output_nullptr (char *s)
{
  char n = 0;
  return fwrite (&n, 1, sizeof (n), outfile);
}

/**
 *
 * @todo Describe function
 */
int
output_okptr (char *s)
{
  char n = 1;
  return fwrite (&n, 1, sizeof (n), outfile);
}

/**
 *
 * @todo Describe function
 */
int
output_end_union (char *s, char *n)
{
  return 1;
}

/**
 *
 * @todo Describe function
 */
int
output_enum (char *name, char *s, int d)
{
  return output_int (name, d, 0, -1);
}


/*
------------------------------------------------------------------------------
 Input Routines
------------------------------------------------------------------------------
*/


/**
 *
 * @todo Describe function
 */
int
input_start_array (char *s, int type, int *len)
{
  int a;
  a = input_int (s, len, 0, -1);
  debug ("ARRAY %s - Length of array=%d", s, *len);
  return a;
}

/**
 *
 * @todo Describe function
 */
int
input_end_array (char *s, int type)
{
  return 1;
}

/**
 *
 * @todo Describe function
 */
int
input_short (char *name, short *val, int ptr, int isarr)
{
  int a;
  a = fread (val, 1, sizeof (short), infile);
  *val = ntohs (*val);
  return a;

}


/**
 *
 * @todo Describe function
 */
int
input_int (char *name, int *val, int ptr, int isarr)
{
  if (sizeof (int) == sizeof (long))
    {
      return input_long (name, (long *) val, ptr, isarr);
    }
  else
    {
      return input_short (name, (short *) val, ptr, isarr);
    }
}

/**
 *
 * @todo Describe function
 */
int
input_long (char *name, long *val, int ptr, int isarr)
{
  int a;
  /* long n; */
  debug ("Input_long val=%p", val);
  a = fread (val, 1, sizeof (long), infile);

  debug ("Got long as %d\n", *val);
  *val = ntohl (*val);
  debug ("->Got long as %d\n", *val);
  return a;
}


/**
 *
 * @todo Describe function
 */
int
input_bool (char *name, int *val, int ptr, int isarr)
{
  return input_short (name, (short *) val, ptr, isarr);
}


/**
 *
 * @todo Describe function
 */
int
input_string (char *name, char **val, int ptr, int isarr)
{
  long l;
  int a;
  debug ("Inputing string %s", name);
  if (!input_long ("", &l, 0, -1))
    return 0;
  debug ("Got length as %d", l);
  *val = malloc (l + 1);	/* Extra 1 for the \0 */
  a = fread (*val, 1, l, infile);
  if (a == 0 && l == 0)
    return 1;
  return a;
}

/**
 *
 * @todo Describe function
 */
int
input_double (char *name, double *val, int ptr, int isarr)
{
  return fread (&val, 1, sizeof (val), infile);
}

/**
 *
 * @todo Describe function
 */
int
input_start_struct (char *s, char *n, int ptr, int isarr)
{
  return 1;
}

/**
 *
 * @todo Describe function
 */
int
input_end_struct (char *s, char *n)
{
  return 1;
}

/**
 *
 * @todo Describe function
 */
int
input_start_union (char *s, char *n, int ptr, int isarr)
{
  return 1;
}

/**
 *
 * @todo Describe function
 */
int
input_ptr_ok ()
{
  char n;
  fread (&n, 1, sizeof (n), infile);
  if (n)
    return 1;
  else
    return 0;
}

/**
 *
 * @todo Describe function
 */
int
input_end_union (char *s, char *n)
{
  return 1;
}

/**
 *
 * @todo Describe function
 */
int
input_enum (char *name, int *d)
{
  return input_int (name, d, 0, -1);
}

/**
 *
 * @todo Describe function
 */
int
//can_pack_all(void)
can_pack_all (char *name)
{
  return 0;
}


/* ====================================== EOF ============================ */
