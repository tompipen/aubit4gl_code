##############################################################################
# This file contatins information about operational status of all SQL/db
# realated features used in Aubit regression tests, and therefore hopefully
# all db/SQL related features that exist in x4GL grammar.
#
# It is loaded in incl/functions_incl.sh file, in function define_sql_features()
#
# All lines STARTING with # are treated as comments and discarded when loading.
#
# General goal is to distinguish (describe) between known (documented) and 
# therefore expected and unknown and therefore unexpected (as per documented) 
# behaviour.
#
# Problems which this approach is trying to solve are:
#
# a) Preserving testing results integrity
#    ------------------------------------
#    Purpose of any testing is to determine which functionality is working and 
#    which is not, so it can be documented, and ideally fixed/implemented. 
#    But there are situations in which feature/functionality/test 
#    is not working, but this cannot be fixed, since it depends on functionality 
#    outside of software which we are testing, or this functionality is not
#    implemented, and therefore cannot be expected to work . Allowing such tests 
#    to run will
#    allways result in failure, which will corrupt the result of all testing.
#    Using information stored in this file, and comparing it with information
#    stored in each tests descriptions (in its makefile) we can determine this
#    kind of sittuations and skip the test we know cannot work (not because of
#    the bug, but because it is not compatible, and never will be, or because
#    finctionality needed for it to work was not implemented) and therefore
#    preserve the integrity of the testing results.
#
#    An example: if one of the tests a car manufacturer has to perform before
#    shipping a car out of the factory would be to test if a car can fly, all
#    cars would fail that test, and result of testing would be a failure. This 
#    would be an example of not implemented feature - in theory possible,
#    but not implemented. OTOH, if they would test if car engine works under
#    water, all engines would fail. This would be an example of functionality 
#    not possible because of external factors - namely lack of oxigen. If they
#    run a significant number of such obviously ridicolous tests, like we did
#    in the past, they would end up with results such as that car passed only
#    50% of all tests. If you looked at that result, and did not know what 
#    they did, what would you think about that car? If you did know what they 
#    did, what would you think about there testing procedure? And this is 
#    exactly what we had before this functionality was introduced.
#    For example, we would run a test trying to create stored procedure 
#    using Informix-only syntax, agains PostgreSQL database. It would of course 
#    fail, and after running a number of such (pointless) tests we would end 
#    up with result showing that Aubit compiler using PostgreSQL database
#    passes less then 55% of all database tests, which is meaningless.
#    
#
# b) Gap analysis
#    ------------
#    having a knowlage of features used in tests, allow us to run regression
#    tests against any database type, database version, configuration,
#    environment, operating system, connectivity method, etc., and instantly 
#    collect information about all working and non-working features. This is
#    also usefull for creating initial status informtion for some database
#    in this file - all passed features would receive initial (S)upported status,
#    while all passed features would receive initial (P)ossible. Then, an developer
#    with knowlage of Aubit functionality AND knowlage of used database wolud
#    manually sort out P status - changing it to:
#		(S)upported if feature should work and functionality needed for it is implemented, 
#         but does not because of Aubit bug, OR in the case when test containing
#         this feature failed for some other reason, and feature does work.
#       (I)mposible if feature is not possble using this database no matter what we do
#       ...or leave it as (P)ossible if feature CAN in theory work with this database,
#         but it does not because supporting functionality needed for it to work
#         is not (yet) implemented in Aubit compiler.
#   
#
# c) DB/SQL features support status reporting
#    ----------------------------------------
#    after a status of each feature is recorded in this file, we can instantly 
#    produce comphensive report of
#    support status for any database with maintained status, which is absolutely
#    nececery to have in manual/documentation, for users to know what they can
#    use with particular database, and what not to use. This is also needed to 
#    plan porting applications to different databases.
#
# To make all this work, developers adding or modifying Aubit regression tests
# need to perform following tasks:
#
# 1) Maintain the list of DB/SQL features used in every test that needs a database
#    in the makefile of each test, in make target "sql_features_used:" If the feature
#    used in test allready exists in this file, use its name/descriptor. If it 
#    does not, add new descriptor to this file, as well as in makefile
#
# 2) Maintain the list of DB/SQL features used in regression tests, and there
#    status in this file. 
#
# TO-DO
# ------
# rename in makefiles:
# CLUSTER_INDEX -> CREATE_INDEX_CLUSTER
# DESC_INDEX -> XXX
# DDL_SYNONYM -> CREATE_SYSNONYM
#
# SQL_UNIQUE - what is that?
#
# Create documentation describing what each feature name refers to
#
# Legend for feature status fields:
# ---------------------------------
# (P)OSSIBLE - all non-ANSI compatible SQL or db features that is posible
# to translate/emulate, but this is __NOT__ currently working because
# it is not implemented (NOT because there is a bug in it - if this is
# the case, list it as supported and let it fail so we can see it as a 
# bug [Should we create another status for it, like (B)ug maybe?] and 
# list it as expected to fail in fail_list_inc.sh)
# It is anticipated that support for them will be/can be implemented in the 
# near future.
#
# (S)UPPORTED - all non-ANSI compatible SQL or db features that is posible
# to translate/emulate, and is implemented in Aubit and fully working
#
# (D)EPENDS - all non-ANSI compatible SQL or db features that is NOT posible
# to translate/emulate, so there behaviour will depend on functionality
# and/or configuration of the database back-end used. Only ANSI and 
# ANSI-CNV should use this status type.
#
# (I)MPOSSIBLE - all non-ANSI compatible SQL or db features that is NOT posible
# to translate/emulate, and never will be since it depends on the
# functionality of the back-end that CANNOT be emulated, translated
# or subsitituted

# Legend for feature type field:
# ------------------------------
# D=DDL statement  (Data Definition Language statement)
# S=SQL statement (Datata Manipulation Statement)
# C=Conectivity statement
# P=Procedure & trigger (Server Side Statement) 
# F=Functions (Server Side)
# X=miXed - feature refers to more then one of above types
#
#
# Fields:
# -------
# Field 1 - Feature status for any ANSI 92 compliant database (that has .cnv file)
# Field 2 - Feature status for any ANSI 92 compliant database (that does NOT have .cnv file)
# Field 3 - Feature status for Informix On-Line (5.x, 7.x, 9.x) databases
# Field 4 - Feature status for Informix SE (All versions) databases
# Field 5 - Feature status for PG 7.4 with Informix compatibility patch
# Field 6 - Feature status for vanilla (not patched) PostgreSQL 7.4 and 8
# Field 7 - Feature status for SQLite version xyz (via ODBC)
#   TODO - add ODBC/native connections
# Field x - Feature status for MySQL version xyz
# Field x - Feature status for MaxDB (SAP DB) version xyz
# Field x - Feature status for Oracle version xyz
# Field x - Feature status for DB2 version xyz
# Field x - Feature status for MS SQL server version xyz
# Field x - Feature status for Sybase version xyz
# Field x - Feature status for Progress version xyz
# Field x - Feature status for Ingres version xyz
# Field x - Feature status for FireFox version xyz
# Field 8 - Feature type
# Field 9 - Feature name
##############################################################################


#Fields:    1-2-3-4-5-6-7-8-9
			I I S I I I I D ADD_CONSTRAINT 
			I I S S S S S D ALTER_INDEX 
			P P S S I I S D ALTER_TABLE 
			I I S S I I S D ALTER_TABLE_ADD 
			I I S S I I S D ALTER_TABLE_ADD_BEFORE 
			I I S S I I S D ALTER_TABLE_DROP 
			I I S S I I S D ALTER_TABLE_LOCK_MODE 
			S S S S S S S S ANSI_DELETE 
			S S S S S S S S ANSI_INSERT 
			S S S S S S S S ANSI_SELECT 
			S S S S S S S S ANSI_UPDATE 
			S S S S S S S S BEGIN_WORK 
			S S S S S S S S CLOSE_CURSOR 
			S S S S S S S C CLOSE_DATABASE 
			I I S S I I S D CLUSTER_INDEX 
			S S S S S S S S COMMIT_WORK 
			I I I S S S S D CREATE_AUDIT 
			P P S S S S S D CREATE_DATABASE 
			I I S S S S S D CREATE_DATABASE_IN 
			I I S I S S S D CREATE_DATABASE_MODE_ANSI 
			I I S S S S S D CREATE_DATABASE_WITH_LOG 
			S S S S S S S D CREATE_INDEX 
			P P S S S S S D CREATE_INDEX_ASC 
			I I S S S S S D CREATE_INDEX_ASC_DESC 
			I I S S S S S D CREATE_INDEX_CLUSTER 
			I I S S S S S D CREATE_INDEX_COMPOSITE 
			I I S S S S S D CREATE_INDEX_DESC 
			S S S S S S S D CREATE_INDEX_UNIQUE 
			I I S S S S S D CREATE_INDEX_UNIQUE_COMPOSITE 
			I I S I S S S P CREATE_PROCEDURE 
			I I S S I I S D CREATE_SYNONYM 
			S S S S S S S D CREATE_TABLE 
			I I S I I I I D CREATE_TABLE_EXTENT 
			I I S S I I I D CREATE_TABLE_IN 
			I I S S I I I D CREATE_TABLE_LOCK_MODE 
			I I S I I I I D CREATE_TABLE_NEXT_SIZE 
			S S S S S S S D CREATE_TEMP_TABLE 
			I I S S S S S D CREATE_TEMP_TABLE_NO_LOG 
			S S S S S S S D CREATE_VIEW_AS_SELECT 
			S S S S S S S D CREATE_VIEW_AS_SELECT_MULTI_TABLE 
			I I S S I I S D CREATE_VIEW_SELECT_WITH_CHECK 
			S S S S S S S S CURSOR_SELECT 
			S S S S S S S S CURSOR_SELECT_FOR_UPDATE 
			S S S S S S S C DATABASE 
			I I S S S S S C DATABASE_EXCLUSIVE 
			P S S S S S S F DATETIME_EXTEND 
			P S S S S S S D DDL_BYTE 
			I I S S S S S D DDL_CHECK 
			I I S S I I S D DDL_CONSTRAINT 
			S S S S S S S D DDL_DATE 
			S S S S S S S D DDL_DATETIME 
			S S S S S S S D DDL_DEFAULT_VALUE 
			P P S S S S S D DDL_DOUBLE_PRECISION 
			P P S S I I S D DDL_FOREIGN_KEY 
			I I S S S S S D DDL_INTERVAL 
			S S S S S S S D DDL_MONEY 
			P P S S S S S D DDL_NCHAR 
			I I S I I I I D DDL_NEXT_SIZE 
			S S S S S S S D DDL_NOT_NULL 
			P P S S S S S D DDL_NVARCHAR 
			P P S S S S S D DDL_PRIMARY_KEY 
			I I S S S S S D DDL_REFERENCES 
			P P S S S S S D DDL_SERIAL 
			I I S S S S S D DDL_SET_CONSTRAINT 
			I I S S I I S D DDL_SYNONYM 
			P P S S S S S D DDL_TEXT 
			P P S S S S S D DDL_UNIQUE 
			S S S S S S S X DEFINE_LIKE 
			P P S S S S S X DEFINE_LIKE_QUALIFIED_PATH 
			I I S S S S S S DELETE_FROM_WHERE_ALL_SUBSELECT 
			I I S S S S S S DELETE_FROM_WHERE_ANY_SUBSELECT 
			P P S S S S S S DELETE_FROM_WHERE_EXISTS_SUBSELECT 
			S S S S S S S S DELETE_FROM_WHERE_NULL 
			I I S S S S S S DELETE_FROM_WHERE_SOME_SUBSELECT 
			S S S S S S S S DELETE_FROM_WHERE_WITH_SUBSELECT 
			I I S S I I S S DELETE_WHERE_CURRENT_OF 
			I I S S I I S D DESC_INDEX 
			I I I S S S S D DROP_AUDIT 
			I I S I I I I D DROP_CONSTRAINT 
			P P S S S S S D DROP_DATABASE 
			S S S S S S S D DROP_INDEX 
			I I S I S S S F DROP_PROCEDURE 
			I I S S I I S D DROP_SYNONYM 
			S S S S S S S D DROP_TABLE 
			I I S I S S S F DROP_TRIGGER 
			S S S S S S S D DROP_VIEW 
			S S S S S S S S EXECUTE_INTO_USING 
			S S S S S S S S EXECUTE_USING 
			P P S S I S S S FETCH_RELATIVE 
			S S S S S S S S FREE_CURSOR 
			S S S S S S S X FREE_LOB 
			P P S S I S S F FUNC_EXTEND 
			P P S S I I S F FUNC_INTERVAL 
			D D S S S S S F FUNC_SUBSTR 
			S S S S S S S D GRANT 
			S S S S S S S S GROUP_BY 
			S S S S S S S S GROUP_BY_NUMBER 
			I I S S S S S D IFX_SYSTABLES 
			I I S I I I I D INDEX_FILLFACTOR 
			S S S S S S S X INITIALIZE_LIKE 
			S S S S S S S S INSERT_COLUMNLIST_EQ_VALUELIST 
			S S S S S S S S INSERT_INTO_SELECT_FROM 
			S S S S S S S X LOAD_FROM_INSERT_INTO 
			I I S S S S S S LOCK_TABLE 
			I I S S S S S S LOCK_TABLE_EXCLUSIVE 
			I I S S S S S S LOCK_TABLE_SHARED 
			I I S S I I S S META_DELETE_FROM_SYNONYM 
			P P S S I I S S META_DELETE_FROM_VIEW 
			P P S S S S S S META_DELETE_FROM_VIEW_MULTI_TABLE 
			I I S S S S S S META_INSERT_MULTITABLE_VIEW 
			I I S S I I S S META_INSERT_SYNONYM 
			I I S S I I S S META_INSERT_VIEW 
			P P S S S S S S META_SELECT_AS_ALIAS 
			I I S S I I S S META_SELECT_FROM_SYNONYM 
			S S S S I I S S META_SELECT_FROM_VIEW 
			I I S S S S S S META_UPDATE_MULTI_TABLE_VIEW 
			I I S S I I S S META_UPDATE_VIEW 
			S S S S S S S S ORDER_BY 
			S S S S S S S S ORDER_BY_ASC 
			I I S S S S S S ORDER_BY_DESC 
			S S S S S S S S ORDER_BY_NUMBER 
			P P S S I S S S PUT_CURSOR 
			I I I S S S S D RECOVER_TABLE 
			I I S S S S S D RENAME_COLUMN 
			I I S S S S S D RENAME_TABLE 
			S S S S S S S X REPORT_ORDER_BY 
			S S S S I I S D REVOKE 
			S S S S S S S S ROLLBACK_WORK 
			I I I S S S S D ROLLFORWARD_DATABASE 
			I I S S S S S D ROWID 
			I I S S I S S S SCROLL_CURSOR 
			S S S S S S S S SELECT_ALL 
			S S S S S S S S SELECT_AS 
			S S S S S S S F SELECT_AVG 
			S S S S S S S F SELECT_AVG_ALL 
			S S S S S S S F SELECT_COUNT 
			I I S S S S S F SELECT_COUNT_DISTINCT 
			S S S S S S S S SELECT_DISTINCT 
			S S S S S S S S SELECT_FOR_UPDATE 
			S S S S I I S S SELECT_FOR_UPDATE_CURSOR 
			S S S S S S S X SELECT_HAVING_COUNT 
			S S S S S S S S SELECT_INTO_TEMP 
			P P S S S S S X SELECT_INTO_TEMP_WITH_NO_LOG 
			S S S S S S S F SELECT_MAX 
			S S S S S S S X SELECT_MAX_ALL 
			S S S S S S S F SELECT_MIN 
			S S S S S S S X SELECT_MIN_ALL 
			I I S S I I S S SELECT_OUTER 
			D D S S I S S S SELECT_RELATIVE 
			D D S S S S S F SELECT_SUBSTRING 
			S S S S S S S F SELECT_SUM 
			S S S S S S S X SELECT_SUM_ALL 
			D D S S S S S S SELECT_UNION 
			D D S S S S S S SELECT_UNION_ALL 
			D D S S S S S S SELECT_WHERE_ALL_SUBSELECT 
			S S S S S S S S SELECT_WHERE_BETWEEN 
			S S S S S S S S SELECT_WHERE_EXISTS_SUBSELECT 
			S S S S S S S S SELECT_WHERE_IN 
			S S S S S S S S SELECT_WHERE_IN_SUBSELECT 
			S S S S S S S S SELECT_WHERE_LIKE 
			S S S S I I S S SELECT_WHERE_MATCHES 
			S S S S S S S S SELECT_WHERE_NULL 
			I I S S I I S D SET_BUFFERED_LOG 
			I I S S S S S F SET_EXPLAIN 
			I I S S S S S X SET_ISOLATION 
			D D S S S S S X SET_LOCK_MODE 
			D D I S I I S X SET_LOG 
			S S S S S S S X SQLCA_SQLAWARN1 
			S S S S S S S X SQLCA_SQLAWARN2 
			S S S S I I S X SQLCA_SQLAWARN3 
			S S S S I I S X SQLCA_SQLAWARN4 
			S S S S S S S X SQLCA_SQLCODE 
			S S S S I I S X SQLCA_SQLERRD1 
			S S S S I I S X SQLCA_SQLERRD2 
			S S S S S S S X SQLCA_SQLERRD3 
			S S S S I I S X SQLCA_SQLERRD4 
			S S S S I I S X SQLCA_SQLERRD5 
			S S S S S S S X SQLCA_SQLERRD6 
			S S S S I I S X SQLCA_SQLERRM 
			S S S S I S S X SQL_END_SQL_BLOCK 
			I I I S S S S D START_DATABASE 
			I I I S S S S D START_DATABASE_WITH_LOG 
			I I I S S S S D START_DATABASE_WITH_LOG_MODE_ANSI 
			D D S S S S S X TABLENAME_DB_SERVER_USER_TABLE 
			D D S S S S S X TABLENAME_DB_TABLE 
			D D S S S S S X TABLENAME_DB_USER_TABLE 
			P P S S S S S X UNLOAD_PATH_RELATIVE 
			S S S S I I S X UNLOAD_TO 
			S S S S S S S X UNLOAD_TO_SELECT_FROM 
			S S S S I I S X UNLOAD_TO_SELECT_FROM_WHERE 
			D D S S S S S S UNLOCK_TABLE 
			S S S S S S S S UPDATE_COLUMNLIST_EQ_VALUELIST 
			P P S S S S S S UPDATE_COLUMNLIST_EQ_VALUELIST_WITH_THRU 
			S S S S S S S S UPDATE_SET_STAR 
			S S S S S S S S UPDATE_SET_VALUE_WITH_SUBSELECT 
			I I S S S S S D UPDATE_STATISTICS 
			D D S S S S S S UPDATE_WHERE_CURRENT_OF 
			S S S S S S S X VALIDATE_LIKE 
			S S S S S S S S WHERE_ANY_SUBSELECT 
			S S S S S S S S WHERE_BETWEEN 
			S S S S S S S S WHERE_LIKE 
			I I S S I I S S WHERE_LIKE_ESCAPE 
			S S S S I I S S WHERE_MATCHES 
			I I S S I I S S WHERE_MATCHES_ESCAPE 
			S S S S S S S S WHERE_NOT_IN 
			S S S S I I S S WHERE_NULL 
			I I S S S S S S WHERE_SOME_SUBSELECT 

# ------------------------------------- EOF ---------------------------------

