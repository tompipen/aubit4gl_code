###########################################################################
# 		Use this script to run unit tests (see -help)
#
###########################################################################

START_TIME=`date +%s`


###########################################
#Include task specific shell script files:
#List of all tests expected to fail:
. incl/fail_list_inc.sh
#Definitions of all functions used in this script:
. incl/functions_inc.sh
#Tests descriptions for old style makefiles:
. incl/legacy_descriptions_inc.sh
#Global variables and setting, and utility flags and flags pre-processing:
. incl/init_inc.sh
#Loop for runing multiple configurations of tests and tests matrix:
. incl/multiple_test_inc.sh

#Make sure we don't have a left-over watcher
WATCHIT_SH="./bin/watchit.sh"
WATCH_PID=`ps -ef | grep -v "grep" | grep "bash $WATCHIT_SH" | head -1 | awk '{print $2}'`

if test "$WATCH_PID" != "" -a "$WATCH_PID" != "0"; then
	echo "Killing left-over watcher (pid $WATCH_PID)"
	kill $WATCH_PID > /dev/null 2>&1
	KILL_RET=$?
	if test "$VERBOSE" = "1" ; then
		echo "Killing watcher (pid $WATCH_PID) returned code $KILL_RET"
	fi
	WATCH_PID=`ps -ef | grep -v "grep" | grep "bash $WATCHIT_SH" | head -1 | awk '{print $2}'`
	if test "$WATCH_PID" != ""; then
		echo "error: still have one or more running:"
		ps -ef | grep -v "grep" | grep "bash $WATCHIT_SH"
		exit 5
	fi
fi
unset WATCH_PID

##############################################################################
#                           Process command line switches
##############################################################################

#process comand line parameters that affect processing of other parameters:
###################
for a in $FLAGS; do
###################
	##########
	case $a in
	##########
			
        -noecho)    #Don't show any non-critical messages while running tests
                    #NOTE: this is NOT the same as -silent
			NO_ECHO=1
			;;
		-shdbg) 	#run_tests shell script debugging 
			SH_DBG=1
			;;
        -verbose | --verbose)   #Show more information about what is going on
            VERBOSE=1
			;;
        -verbose-results | --verbose-results)   #Show more information about results			
			VERBOSE_RESULTS=1
			;;

		-help-all | --help-all)			
			FLAGS="-help -help-general -help-utility -help-test -help-debug \
				-help-db -help-other -help-results -help-short -help-examples "
			HELP_ALL=1
			;;
			
			
	####
	esac
	####
####
done
####

#######################
#Create list of all available tests
ALL_DIRS=[0-9]*
ALL_TESTS=`echo $ALL_DIRS | tr " " "\n" | $SORT -n |  tr "\n" " "`
LIBS_DIR="$AUBITDIR_UNIX/lib"

#process comand line parameters:
###################
for a in $FLAGS; do
###################
   ##########
   case $a in
   ##########

   -sqlt)
   #test of SQL translation using SQLFairy
   #http://sqlfairy.sourceforge.net/
   	# Parsers:
		# DBI DBI-MySQL DBI-PostgreSQL DBI-SQLite DBI-Sybase
		# Excel MySQL Oracle PostgreSQL SQLite Storable Sybase
		# XML XML-SQLFairy YAML xSV
    # Producers:
		# ClassDBI Diagram GraphViz HTML MySQL Oracle POD PostgreSQL
		# SQLite Storable Sybase TTSchema XML XML-SQLFairy YAML
      # General Options:
        # -d|--debug         Print debug info
        # -v|--validate      Validate the schema
        # --trace            Print parser trace info
        # --show-warnings    Print warnings to STDERR
      # DBI Parser Options:
        # --dsn              DSN for connecting to database
        # --db-user          Database user
        # --db-password      Database password              
      # DB Producer Options:
        # --add-drop-table   Add 'DROP TABLE' statements before creates
        # --no-comments      Don't include comments in SQL output
      # Diagram Producer Options:
        # --imap-file        Filename to put image map data
        # --imap-url         URL to use for image map

		#PG:
		cat ./testdb-ddl.sql | grep -v "^/\*" | grep -v "^\*/" | grep -v "^//" | sed -e 's/128,0/128/g' | tr "\"" "'" > testdb-tmp.sql
		#$PSQL -d $TEST_DB -f testdb-tmp.sql  > /tmp/testdb.log 2>&1
		
		TO=XML
		OUTFILE=testdb.xml
		OPTIONS=
		
		#can't load GD.pm
		TO=Diagram
		OUTFILE=testdb.dia
		OPTIONS=		

		#Can't locate GraphViz.pm
		TO=GraphViz
		OUTFILE=testdb.gv
		OPTIONS=		
		
		TO=SQLite
		OUTFILE=testdb-$TO.sql
		OPTIONS=		
		
		
		DOIT="sqlt --from PostgreSQL --to $TO $OPTIONS testdb-tmp.sql > $OUTFILE"
		echo $DOIT
		eval $DOIT
		RET=$?
		if test "$RET" != "0"; then 
			echo "ERROR: sqlt failed"
		else
			less $OUTFILE
		fi
		exit $RET
		;;

	-check-dump-screen)
		#Make sure we have IS_DUMP_SCREEN_TEST set right
		ALL_DIRS=[0-9]*
		ALL_TESTS=`echo $ALL_DIRS | tr " " "\n" | $SORT -n |  tr "\n" " "`
		for TEST_NO in $ALL_TESTS
		do
			IN_MAKE=0
			IN_STRING=0
			IS_DUMP_SCREEN_TEST=0
			x=0
			for b in $INVALID_TESTS; do
				if test "$b" = "$TEST_NO"; then
					x=1
					continue
				fi
			done
			if test "$x" = "1"; then 
				continue
			fi
			
			#check list
			for b in $DUMP_SCREEN_TESTS; do
				if test "$b" = "$TEST_NO"; then
					IS_DUMP_SCREEN_TEST=1
					IN_STRING=1
				fi
			done
			if test "$IS_DUMP_SCREEN_TEST" = "0"; then 
				#check makefile
				IS_DUMP_SCREEN_TEST=`$MAKE -s -C $TEST_NO dump_screen_test 2>/dev/null`
				if test "$IS_DUMP_SCREEN_TEST" = ""; then
					IS_DUMP_SCREEN_TEST=0
				fi
				if test "$IS_DUMP_SCREEN_TEST" = "1"; then
					IN_MAKE=1
				fi
			fi
			
			#check for real
			TMP1=`$FIND $CURR_DIR/$TEST_NO -name "*.4gl" -exec grep -l -i aclfgl_dump_screen {} \;`
			if test "$TMP1" != ""; then 
				REALLY_IS_DUMP_SCREEN_TEST=1
			else
				REALLY_IS_DUMP_SCREEN_TEST=0
			fi
			TMP1=`$FIND $CURR_DIR/$TEST_NO -name "*.4gl" -exec grep -l -i A4GL_clr_window {} \;`
			if test "$TMP1" != ""; then 
				REALLY_IS_CLR_WINDOW_TEST=1
			else
				REALLY_IS_CLR_WINDOW_TEST=0
			fi
			TMP1=`$FIND $CURR_DIR/$TEST_NO -name "*.4gl" -exec grep -l -i aclfgl_fgl_drawbox {} \;`
			if test "$TMP1" != ""; then 
				REALLY_IS_FGL_DRAWBOX_TEST=1
			else
				REALLY_IS_FGL_DRAWBOX_TEST=0
			fi
			
			if test "$REALLY_IS_FGL_DRAWBOX_TEST" = "1" -o "$REALLY_IS_CLR_WINDOW_TEST" = "1" -o "$REALLY_IS_DUMP_SCREEN_TEST" = "1"; then 
				SHOULD_BE=1
			else
				SHOULD_BE=0
			fi
			if test "$SHOULD_BE" != "$IS_DUMP_SCREEN_TEST"; then
				echo "$TEST_NO : SHOULD_BE=$SHOULD_BE but $IS_DUMP_SCREEN_TEST (IN_MAKE=$IN_MAKE IN_STRING=$IN_STRING)"
				echo "DUMP_SCREEN=$REALLY_IS_DUMP_SCREEN_TEST CLR_WINDOW=$REALLY_IS_CLR_WINDOW_TEST FGL_DRAWBOX=$REALLY_IS_FGL_DRAWBOX_TEST"
			fi
		done
		exit 0
		;;
		
	-info) 	#Show information about the test; allready procesed before - skip it
		;;
	-show-config)
		#don't run any tests - just show configuration under which they would be executed
		SHOW_CONFIG=1
		#break
		;;
		
	-show-make) 	
		#Dont run "run" target in makefile - run "show" target instead
		MAKE_TARGET=show
		;;
	-runner-ifx) 	#Create p-code runner for Informix P-code compiler 
		create_runner informix
		exit 0
		;;
	-runner-4js) 	#Create p-code runner for Four J's P-code compiler 
		create_runner 4js
		exit 0
		;;
	-noecho)    #Don't show any non-critical messages while running tests
        #we already got this one set
		;;
	-shdbg) 	#run_tests shell script debugging
		#got that allready
		;;

    -verbose | --verbose)   #Show more information about what is going on
        #we already got this one set
        ;;
    -verbose-results | --verbose-results)   #Show more information about results
        #we already got this one set
        ;;
	-new-unl-db)
		create_unl_db_tables
		exit 0
		;;
	-log-text*) #custom text to log to unl file
		LOG_TEXT=`echo $a | sed -e 's/-log-text=//' | tr "_" " "`
		;;
		
	-loop-10)
		LOOP_TIMES=10
		;;
	-loop-100)
		LOOP_TIMES=100
		;;
		
	-aubitrc-test)	#Use aubitrc in aubit4gltest directory to override local installation settings
		if test "$PLATFORM" = "MINGW"; then 
			#export A4GL_INIFILE="d:/cygwin/usr/src/aubit/aubit4gltest/etc/aubitrc-testing"
			echo "FIXME: On Windows DBMONEY ends up empty after reading A4GL_INIFILE"
			echo "FIXME: Try -show-config"
			unset A4GL_INIFILE
		else
			export A4GL_INIFILE="$CURR_DIR/etc/aubitrc-testing"
		fi
		if test "$A4GL_INIFILE" != ""; then 
			if test ! -f $A4GL_INIFILE; then 
				echo "ERROR: Aubit RC file ($A4GL_INIFILE) missing. Stop."
				exit 4
			fi
		fi
		;;
		
	-alldbrun)       #this script was invoked from alltests loop
        NO_ECHO=1; ALL_DB=1
        ;;

    -debug)         #set DEBUG=ALL
        export DEBUG=ALL
        ;;
    -show-time)     #Show timing results for each test
		MEASURE_TIME=1
		SHOW_TIME=1
        ;;
    -measure-time)     #time results for each test
		MEASURE_TIME=1
        ;;
	-db-features-report) #Show support status by db features for current db
		SHOW_DB_FEATURES_REPORT=1
		;;
	-disable-sql-features-check) #Do not skip tests with incompatible SQL features
		DISABLE_SQL_FEATURES_CHECK=1
		;;
	-disable-sql-features-skip) #Check, but do not skip incompatible SQL features
		DISABLE_SQL_FEATURES_SKIP=1
		;;
	-skip-only-impossible)
		SKIP_ONLY_IMPOSSIBLE=1
		;;
	-clean)         #clean and exit
		CLEAN=1
		;;

	-clean-all) 	#clean completely to CVS state and exit
		CLEAN_ALL=1
		CLEAN=1		
		;;
	-ignore-compat)	#Skip testing for test compatibility with no-aubit compilers
		IGNORE_COMPAT=1
		;;
	-ignore-conf-error) #Ignore configuration errors and continue
		IGNORE_CONF_ERR=1 
		;;
	-stop)          #stop on error
		ERROR_STOP=1
	    ;;
	-showerr) 		#Show compile errors in 4gl code for given test
		SHOW_4GL_ERROR=1
		;;
		
    -nodb)          #skip db dependent tests
		NO_DB=1
	    ;;

    -memdbg)        #Use 'valgrind' to perform memory checking ar run-time
		export DBG=valgrind
        ;;

	-gdb)			#use gdb to run programs with (not 4clc - just compiled programs)
		if test "$COMSPEC" = ""; then 
			export DBG="gdb --args "
		else
			export DBG="gdb "
		fi
		;;

	-itemised) 		#Show result for each executed test
		SHOW_ITEM_RESULT=1
		;;
		
    -onlydb)        #run only db based tests
		ONLY_DB=1
	    ;;
	-skip-unknown-trans) #Skip tests with explicit pref for trans, when cant 
						#determine state of trans in current RDBMS
		SKIP_UNKNOWN_TRANS=1
		;;
		
	-xterm)
		export TERM=xterm
		;;
		
	-skip-expectfail) #Skip tests expected to fail 
		SKIP_EXPECT_FAIL=1
		;;
		
    -onlytui)       #Run only TUI tests listed in TUI_TESTS
		ONLY_TUI=1
        ;;
	-show-passed)	#Show full list of tests that passed 
		SHOW_PASSED=1
		;;
	-norunec)       #don't run EC compiled programs
		export SKIP_EC_RUN=1
        ;;

	-silent)        #don't show ANY output of running test
                    #NOTE: this is NOT the same as -noecho
		SILENT=1
		SHOW_TIME=0
		#if ! test "$NO_ECHO"; then
		if test "$VERBOSE" = "1"; then
			echo "** "
			echo "** WARNING:"
			echo "** Some tests can't run in silent mode and will be skipped"
			echo "** "
        fi
		if test "$COMSPEC" != ""; then 
			#export A4GL_LINES=24
			#export A4GL_COLUMNS=80
			echo "Cant run in silent mode using PDcurses - 'LINES/COLUMNS too small' problem"
			exit 5
		fi
		
		;;
	-no-test-output) #silence output of running test - same as -silent?
		NO_TEST_OUTPUT=1
		;;
		
	-short)          #show only short summary
		SHORT_SUMMARY=1
        ;;

	-record) 	#record keystrokes to file while running program
		export A4GL_KEYLOG="keys.in"
		export A4GL_KEYFILE=
		echo "NOTE: recording keystrokes - DONT FORGET TO ADD keys.in TO CVS!"
		;;
		
	-retest-fail) 		#Run only tests that are expected to fail
		RETEST_FAIL=1
		;;
		
	-retest-invalid) #Run only tests that are flaged as invalid
		ALL_TESTS="$INVALID_TESTS"
		NO_SKIP=1
		;;

	-use-cache) 	#Use cached test descriptions to loop faster
		if test -f $CURR_DIR/etc/cache_IS_DB_TEST.txt ; then
			USE_CACHE=1
			IS_DB_TEST_CACHE="`cat $CURR_DIR/etc/cache_IS_DB_TEST.txt`"
		else
			echo "You need to create a cache file first to use -use-cache"
		fi
		;;
		
    -noskip)        #do not skip any tests whatever the reason is
        NO_SKIP=1
        ;;

	-compile-only) # Do not run any tests, just compile them
		ALL_COMPILE_ONLY=1
		;;

	-tuin)        #use HL_TUIN UI for tests
		if ! test -f $LIBS_DIR/libUI_HL_TUIN$SO_EXT; then
			if ! test "$NO_ECHO"; then
				echo "ERROR: cannot find HL_TUIN plug in"
            fi
            exit 9
        fi
        UI=HL_TUIN;	export A4GL_UI=$UI
        ;;

	-tuins)        #use HL_TUINs (statically linked TUIN) UI for tests
		if ! test -f $LIBS_DIR/libUI_HL_TUINs$SO_EXT; then
			if ! test "$NO_ECHO"; then
				echo "ERROR: cannot find HL_TUINs plug in"
            fi
            exit 9
        fi
        UI=HL_TUINs; export A4GL_UI=$UI
        ;;
		
	-hl_tui)        #use HL_TUI UI for tests
		if ! test -f $LIBS_DIR/libUI_HL_TUI$SO_EXT; then
			if ! test "$NO_ECHO"; then
				echo "ERROR: cannot find HL_TUI plug in"
            fi
            exit 9
        fi
        UI=HL_TUI;	export A4GL_UI=$UI
        ;;

	-console)        #use CONSOLE UI for tests
		UI=CONSOLE
		if ! test -f $LIBS_DIR/libUI_$UI$SO_EXT; then
			if ! test "$NO_ECHO"; then
				echo "ERROR: cannot find $UI plug in"
            fi
            exit 9
        fi
        export A4GL_UI=$UI
		if ! test "$NO_ECHO"; then
			echo "** "
			echo "** WARNING:"
			echo "** Some tests can't run in $UI mode and will be skipped"
			echo "** "
        fi
        ;;

	-gtk)			#Use GTK UI for running tests
		UI=HL_GTK
		if ! test -f $LIBS_DIR/libUI_$UI$SO_EXT; then
			if ! test "$NO_ECHO"; then
				echo "ERROR: cannot find $UI plug in"
            fi
            exit 9
        fi
		export A4GL_UI=$UI
		#What is this for?
		#export DISPLAY=:0
		if ! test "$NO_ECHO"; then
			echo "** "
			echo "** WARNING:"
			echo "** Some tests can't run in $UI mode and will be skipped"
			echo "** "
        fi
        ;;
	
	-sqlite)        #Use SQLite as database for db tests
		if ! test -f $LIBS_DIR/libSQL_sqlite$SO_EXT; then
			if ! test "$NO_ECHO"; then
				echo "ERROR: cannot find SQLite plug-in ($LIBS_DIR/libSQL_sqlite$SO_EXT)"
            fi
            exit 9
        fi
		USE_SQLITE=1; export SKIP_EC_RUN=1; export A4GL_SQLTYPE=sqlite
		export USE_ESQLI=0; export USE_ECI=0;export A4GL_LEXTYPE=C;
        ;;

	-sqlite-new)    #Create new SQLite database from scripts
		USE_SQLITE=1; NEW_SQLITE=1
        ;;

    -esqli)         #Use Informix ESQL/C plug-in for db tests
		if ! test -f $LIBS_DIR/libSQL_esql$SO_EXT; then
			if ! test "$NO_ECHO"; then
				echo "ERROR: cannot find ESQL/C plug in"
            fi
            exit 9
        fi
		USE_SQLITE=0; USE_ESQLI=1; export SKIP_EC_RUN=1; USE_ECI=0
		export A4GL_LEXTYPE=C; export A4GL_SQLTYPE=esql

        ;;

    -eci)   		#Use Informix ESQL/C EC output in for db tests
		USE_SQLITE=0; USE_ESQLI=1; USE_ECI=1; export SKIP_EC_RUN=0
		export A4GL_LEXTYPE=EC; export A4GL_LEXDIALECT=INFORMIX
        #this will be used only by 4glc/fcompile compilers:
		export A4GL_SQLTYPE=esql

		if ! test -f $LIBS_DIR/libSQL_$A4GL_SQLTYPE$SO_EXT; then
			if ! test "$NO_ECHO"; then
				echo "ERROR: cannot find plug-in $A4GL_SQLTYPE ($LIBS_DIR/libSQL_$A4GL_SQLTYPE$SO_EXT)"
            fi
			#It seems Cron on Windows runs ./configure in a way that it does not
			#detect ESQL/C
			make -C $AUBITDIR_UNIX/lib libSQL_$A4GL_SQLTYPE$SO_EXT
			if ! test -f $LIBS_DIR/libSQL_$A4GL_SQLTYPE$SO_EXT; then
				echo "Attempt to make it failed. Stop."
            	exit 9
			fi
        fi
		
		if ! test -f $LIBS_DIR/libESQL_INFORMIX$SO_EXT; then
			if ! test "$NO_ECHO"; then
				echo "ERROR: cannot find plug-in ESQL_INFORMIX ($LIBS_DIR/libESQL_INFORMIX$SO_EXT)"
            fi
			#It seems Cron on Windows runs ./configure in a way that it does not
			#detect ESQL/C
			make -C $AUBITDIR_UNIX/lib libESQL_INFORMIX$SO_EXT
			if ! test -f $LIBS_DIR/libESQL_INFORMIX$SO_EXT; then
				echo "Attempt to make it failed. Stop."
            	exit 9
			fi
        fi
		
		#***must*** make sure that A4GL_ESQL_UNLOAD=N for informix ec generation.
		export A4GL_ESQL_UNLOAD=N

		;;

    -ecs)   		#Use SAP DB ESQL/C EC output in for db tests
		USE_SQLITE=0; USE_ESQLI=0; USE_ECS=1; export SKIP_EC_RUN=0
		export A4GL_LEXTYPE=EC; export A4GL_LEXDIALECT=SAP
        #this will be used only by 4glc/fcompile compilers:
		export A4GL_SQLTYPE=esqlSAP


		if ! test -f $LIBS_DIR/libSQL_$A4GL_SQLTYPE$SO_EXT; then
			if ! test "$NO_ECHO"; then
				echo "ERROR: cannot find plug-in SQL_$A4GL_SQLTYPE"
            fi
            exit 9
        fi

		;;

    -ecp)   		#Use PostgreSQL ESQL/C EC output in for db tests
		USE_SQLITE=0; USE_ESQLI=0; USE_ECP=1; export SKIP_EC_RUN=0
		export A4GL_LEXTYPE=EC; export A4GL_LEXDIALECT=POSTGRES
		USE_PG=1
        #this will be used only by 4glc/fcompile compilers:

		if [ "$A4GL_SYSCOL_VAL" = "" ]
		then	
			A4GL_SYSCOL_VAL=a4gl_syscolval
			export A4GL_SYSCOL_VAL
		fi
		#export A4GL_SQLTYPE=esqlPG
		#export A4GL_SQLTYPE=c_ecpg
		#export A4GL_SQLTYPE=pgodbc
		export A4GL_SQLTYPE=pg
		# This "cascade" drops views when the tables they are based on are dropped
		export A4GL_USE_CASCADE=Y
		if ! test -f $LIBS_DIR/libSQL_$A4GL_SQLTYPE$SO_EXT; then
			if ! test "$NO_ECHO"; then
				echo "ERROR: cannot find plug-in SQL_$A4GL_SQLTYPE ($LIBS_DIR/libSQL_$A4GL_SQLTYPE$SO_EXT)"
            fi
            exit 9
        fi

		;;


    -ecq)   		#Use Querix EC output in for db tests
		USE_SQLITE=0; USE_ESQLI=0; USE_ECQ=1; export SKIP_EC_RUN=0
		export A4GL_LEXTYPE=EC; export A4GL_LEXDIALECT=QUERIX
        #this will be used only by 4glc/fcompile compilers:
		export A4GL_SQLTYPE=esqlQ

		if ! test -f $LIBS_DIR/libSQL_$A4GL_SQLTYPE$SO_EXT; then
			if ! test "$NO_ECHO"; then
				echo "ERROR: cannot find plug-in SQL_$A4GL_SQLTYPE ($LIBS_DIR/libSQL_$A4GL_SQLTYPE$SO_EXT)"
            fi
            exit 9
        fi
		;;
    -ecg)   		#Use Ingres EC output in for db tests
		USE_SQLITE=0; USE_ESQLI=0; USE_ECG=1; export SKIP_EC_RUN=0
		export A4GL_LEXTYPE=EC; export A4GL_LEXDIALECT=INGRES
        		#this will be used only by 4glc/fcompile compilers:
		export A4GL_SQLTYPE=ingres
		export FGLC=4glpc

		if ! test -f $LIBS_DIR/libSQL_$A4GL_SQLTYPE$SO_EXT; then
			if ! test "$NO_ECHO"; then
				echo "ERROR: cannot find plug-in SQL_$A4GL_SQLTYPE ($LIBS_DIR/libSQL_$A4GL_SQLTYPE$SO_EXT)"
            fi
            exit 9
        fi
		;;



    -informix-new) 	#Create new Informix database from scripts
		USE_ESQLI=1; NEW_IFMX=1
        ;;

    -pg)   			#Use PostgreSQL plug-in for db tests
		if ! test -f $LIBS_DIR/libSQL_pg$SO_EXT; then
			if ! test "$NO_ECHO"; then
				echo "ERROR: cannot find PostgreSQL plug in"
            fi
            exit 9
        fi
		USE_SQLITE=0; USE_ESQLI=0; USE_ECI=0; USE_PG=1
		export SKIP_EC_RUN=1; export A4GL_LEXTYPE=C; export A4GL_SQLTYPE=pg
		if ! test "$NO_ECHO"; then
			echo "** "
			echo "** WARNING:"
			echo "** PG native driver is not fully functional."
			echo "** "
        fi
		;;


    -pg-new)         	#Create new PostgreSQL database from scripts
		USE_PG=1; NEW_PG=1
        ;;

    -unixodbc)   		#Use UnixODBC plug-in for db tests
		if ! test -f $LIBS_DIR/libSQL_unixodbc$SO_EXT; then
			if ! test "$NO_ECHO"; then
				echo "ERROR: cannot find UnixODBC plug in"
            fi
            exit 9
        fi
		USE_SQLITE=0; USE_ESQLI=0; USE_ECI=0; USE_PG=0; USE_UNIXODBC=1
        IS_ODBC=1; IS_ODBC_MANAGER=1; export SKIP_EC_RUN=1;
		export A4GL_LEXTYPE=C; export A4GL_SQLTYPE=unixodbc
        ;;

    -iodbc)   			#Use iODBC plug-in for db tests
		if ! test -f $LIBS_DIR/libSQL_iodbc$SO_EXT; then
			if ! test "$NO_ECHO"; then
				echo "ERROR: cannot find iODBC plug in"
            fi
            exit 9
        fi
		USE_SQLITE=0; USE_ESQLI=0; USE_ECI=0; USE_PG=0; USE_UNIXODBC=0
        USE_IODBC=1; IS_ODBC=1; IS_ODBC_MANAGER=1; export SKIP_EC_RUN=1
		export A4GL_LEXTYPE=C; export A4GL_SQLTYPE=iodbc
        ;;

    -winodbc)   			#Use odbc32 plug-in for db tests
		if ! test -f $LIBS_DIR/libSQL_odbc32$SO_EXT; then
			if ! test "$NO_ECHO"; then
				echo "ERROR: cannot find Windows ODBC plug in"
            fi
            exit 9
        fi
		USE_SQLITE=0; USE_ESQLI=0; USE_ECI=0; USE_PG=0; USE_UNIXODBC=0
        USE_IODBC=0; USE_ODBC_32=1; IS_ODBC=1; IS_ODBC_MANAGER=1
		export SKIP_EC_RUN=1; export A4GL_LEXTYPE=C; export A4GL_SQLTYPE=odbc32
        ;;


    -ifxodbc)   		#Use Informix ODBC plug-in for db tests
		if ! test -f $LIBS_DIR/libSQL_ifxodbc$SO_EXT; then
			if ! test "$NO_ECHO"; then
				echo "ERROR: cannot find Informix ODBC plug in"
            fi
            exit 9
        fi
		USE_SQLITE=0; USE_ESQLI=0; USE_ECI=0; USE_PG=0; USE_UNIXODBC=0
        USE_IODBC=0; IS_ODBC=1; USE_IFXODBC=1; ODBC_USE_DB=IFX
		export SKIP_EC_RUN=1; export A4GL_LEXTYPE=C; export A4GL_SQLTYPE=ifxodbc
		BLACKLIST_TESTS="$BLACKLIST_TESTS $BLACKLIST_TESTS_IFXODBC"
        ;;

    -sqliteodbc)   		#Use SQLite ODBC plug-in for db tests
		if ! test -f $LIBS_DIR/libSQL_sqliteodbc$SO_EXT; then
			if ! test "$NO_ECHO"; then
				echo "ERROR: cannot find SQLite ODBC plug in"
            fi
            exit 9
        fi
		USE_SQLITE=0; USE_ESQLI=0; USE_ECI=0; USE_PG=0; USE_UNIXODBC=0
        USE_IODBC=0; IS_ODBC=1; USE_IFXODBC=0; USE_SQLITEODBC=1
        ODBC_USE_DB=SQLITE; export SKIP_EC_RUN=1; export A4GL_LEXTYPE=C
		export A4GL_SQLTYPE=sqliteodbc
        ;;


    -pgodbc)   			#Use PostgreSQL ODBC plug-in for db tests
		if ! test -f $LIBS_DIR/libSQL_pgodbc$SO_EXT; then
			if ! test "$NO_ECHO"; then
				echo "ERROR: cannot find PostgreSQL ODBC plug in"
            fi
            exit 9
        fi
		USE_SQLITE=0; USE_ESQLI=0; USE_ECI=0; USE_PG=0; USE_UNIXODBC=0
        USE_IODBC=0; IS_ODBC=1; USE_IFXODBC=0; USE_SQLITEODBC=0
        USE_PGODBC=1; ODBC_USE_DB=PG; export SKIP_EC_RUN=1; export A4GL_LEXTYPE=C
		export A4GL_SQLTYPE=pgodbc;
		if ! test "$NO_ECHO"; then
			echo "** "
			echo "** WARNING:"
			echo "** PG ODBC will fail unless you set up /etc/odbc.ini manually"
			echo '** because PG ODBC driver ignores $ODBCINI setting.'
			echo "** "
        fi
        ;;

    -err-with-log)      #Send stderr to same destination that logs stdout
        ERR_WITH_LOG=1
        ;;
	-fail-full) #Show full list of tests that failed, db/nondb (need -verbose-results)
		FAIL_FULL_LIST=1
		;;
	-pass-full) #Show full list of tests that passed, db/nondb (need -verbose-results)		
		PASS_FULL_LIST=1
		;;
		
    -sapodbc)   			#Use SAP ODBC ODBC plug-in for db tests
		if ! test -f $LIBS_DIR/libSQL_sapodbc$SO_EXT; then
			if ! test "$NO_ECHO"; then
				echo "ERROR: cannot find SAP DB ODBC plug in"
            fi
            exit 9
        fi
		USE_SQLITE=0; USE_ESQLI=0; USE_ECI=0; USE_PG=0; USE_UNIXODBC=0
        USE_IODBC=0; IS_ODBC=1; USE_IFXODBC=0; USE_SQLITEODBC=0; USE_PGODBC=0
		USE_SAP=1; ODBC_USE_DB=SAP; export SKIP_EC_RUN=1; export A4GL_LEXTYPE=C
		export A4GL_SQLTYPE=sapodbc; export SQLPWD=dba; export SQLUID=dba
        export LD_LIBRARY_PATH="$SAPDBROOT/indep_prog/runtime/7300/lib:$LD_LIBRARY_PATH"

		;;

    -sap-new)         	#Create new SAP DB database from scripts
		NEW_SAP=1; USE_SAP=1
		;;

	-log-unl)
		#unload rest result to .unl file
		date_stamp=`date +%d-%m-%Y_%H-%M-%S`
		U="_"
		if test "$VERBOSE" = "1"; then 
			echo "Logging results to file 'results_$HOSTNAME$U$date_stamp.unl'"
			echo "and 'test_run_$HOSTNAME$U$date_stamp.unl'"
		fi
		unl_file="$CURR_DIR/results_$HOSTNAME$U$date_stamp.unl"
		test_run_unl_file="$CURR_DIR/test_run_$HOSTNAME$U$date_stamp.unl"
		if test "1" = "2"; then 
			rm -f $unl_file $test_run_unl_file
			#rm -f results_*.unl test_run_*.unl
		fi
		UNL_LOG=1
		MEASURE_TIME=1
		;;
		
    -odbcdb-ifx)        #Use Informix RDBMS for ODBC manager connections
		ODBC_USE_DB=IFX
        ;;
    -odbcdb-pg)         #Use PostgreSQL RDBMS for ODBC manager connections
		if ! test "$NO_ECHO"; then
			echo "** "
			echo "** WARNING:"
			echo "** PG ODBC will fail unless you set up /etc/odbc.ini manually"
			echo '** because PG ODBC driver ignores $ODBCINI setting.'
			echo "** "
        fi
		ODBC_USE_DB=PG
        ;;
    -odbcdb-sqlite)    	#Use SQLite RDBMS for ODBC manager connections
		ODBC_USE_DB=SQLITE
        ;;

	-odbcdb-sap)    	#Use SAP DB RDBMS for ODBC manager connections
		ODBC_USE_DB=SAP; export SQLPWD=dba; export SQLUID=dba
		;;


    -noclean)           #Don't clean
        NO_CLEAN=1
        ;;

    -packed)            #use PACKED packer for resource files
		export A4GL_FORMTYPE=GENERIC; export A4GL_MENUTYPE=GENERIC
		export A4GL_PACKER=PACKED
        ;;

    -xml)            	#use XML packer for resource files
		export A4GL_FORMTYPE=GENERIC; export A4GL_MENUTYPE=GENERIC
		export A4GL_PACKER=XML
        ;;

    -xdr)               #Use Sun RCP XDR packer for resource files
		#There are two ways to do this test; are they different?
		if test 0 ; then
			export A4GL_FORMTYPE=GENERIC; export A4GL_MENUTYPE=GENERIC
			export A4GL_PACKER=XDR
        else
			export A4GL_FORMTYPE=XDR; export A4GL_MENUTYPE=XDR
        fi
        ;;

    -pcode)
			#This isn't strictly needed - but it generates smaller C code:
			export A4GL_FAKELEXTYPE=PCODE
			#$ 4glc mysrc.4gl
			#$ c2pcode_fgl mysrc.c
			#(Should generate mysrc.4pe.dat or .xml etc)
			#$ runner_fgl mysrc.4pe
    		#No .xml or .dat - thats added by the packer
            export A4GL_PRG=".4pe"
            export DBG="runner_fgl"
			#RUN_ONE=3
			export FGLC="$FGLC --verbose"
        ;;

    -ccode)         #default
            export A4GL_PRG=".4ae"
            unset A4GL_FAKELEXTYPE
			export A4GL_LEXTYPE=C
			unset A4GL_LEXDIALECT

        ;;

	-watch)		#kill tests that take more then 100 secconds to run
		WATCHIT=1
		;;
		
    -nospace)	#Ignore changes in the amount of white space when diff-ing
		export DIFF_FLAGS="$DIFF_FLAGS --ignore-space-change"
        ;;

    -nodosdiff)	#Ignore changes in DOS/UNIX file format when diff-ing
		export DIFF_FLAGS="$DIFF_FLAGS --strip-trailing-cr"
        ;;

    -nolong)           #Skip tests that take a long time to run
        SKIP_LONG=1
        ;;
		
	-skip-non-ansi) 	#Skip tests with ANSI SQL incompatible statements
		SKIP_NON_ANSI=1
		;;
	-ifx-p)				#Use Informix P-code compiler instead of Aubit compiler
		USE_COMP=ifx-p
		EXPECT_TO_FAIL_TESTS="$EXPECT_TO_FAIL_IFX"
		if test "$FAIL_NON_ANSI" = "1"; then
			#this is obsolete, use -skip-non-ansi
			#force Informix compiler to check all SQL for ANSI compliance
			#(tests 234 256 ...)
			#NOTE: fglpc will exit with exit code eqial to number of ANSI
			#warning, so all non-ANSI tests will fail
			#I4GL_PC_FLAGS variable used in i4gl.mk
			I4GL_PC_FLAGS="$I4GL_PC_FLAGS -ansi"
			export I4GL_PC_FLAGS
		fi
		if test -f "$IFX_RUNNER" ; then
			if test "$VERBOSE" = "1"; then
				echo "Note: using custom runner"
			fi
			RUNNER=$IFX_RUNNER
			FGLRUN=$IFX_RUNNER
			export FGLRUN RUNNER
		else
			create_runner informix
			if test -f "$IFX_RUNNER" ; then
				if test "$VERBOSE" = "1"; then
					echo "Note: using custom runner"
				fi
				RUNNER=$IFX_RUNNER
				FGLRUN=$IFX_RUNNER
				export FGLRUN RUNNER
			else
				echo "Note: creation of Informix custom runner failed."
				echo "All tests using dump_screen() will fail"
			fi
		fi
		#Indicate that we will use Informix RDBMS
		USE_SQLITE=0; USE_ESQLI=1
		
		#get version
		set `fglpc -v 2>/dev/null | head -1|sed -e 's/^INFORMIX-4GL Version //' -e 's/\./ /g'`
		if test "$1" != "" -a "$2" != ""; then
			I4GL_PCOMPILER_VER_MAJOR=$1
			I4GL_PCOMPILER_VER_MINOR=$2				
		else
			echo "ERROR: Cannot get fglpc version."
		fi
		;;
	-4js-p)				#Use FourJs P-code compiler instead of Aubit compiler
		USE_COMP=4js-p
		EXPECT_TO_FAIL_TESTS="$EXPECT_TO_FAIL_4JS"
		if test -f "$FJSRUNNER" ; then
			if test "$VERBOSE" = "1"; then		
				echo "Note: using custom runner"
			fi
			RUNNER=$FJSRUNNER
			FGLRUN=$FJSRUNNER
			export FGLRUN RUNNER
		else
			create_runner 4js
			if test -f "$FJSRUNNER" ; then
				if test "$VERBOSE" = "1"; then		
					echo "Note: using custom runner"
				fi
				RUNNER=$FJSRUNNER
				FGLRUN=$FJSRUNNER
				export FGLRUN RUNNER
			else
				echo "Note: creation of 4Js custom runner failed."
				echo "All tests using dump_screen() will fail"
			fi
		fi
		#Indicate that we will use Informix RDBMS
		USE_SQLITE=0; USE_ESQLI=1
		if ! test -f "./etc/$TEST_DB.sch"; then 
			#-c : Enable Database to 4GL data type conversion.
			#Database type          4GL type
			#--------------------------------------
			#BOOLEAN                CHAR(1)
			#INT8                   DECIMAL(19,0)
			#SERIAL8                DECIMAL(19,0)
			#Note- fglschema will fail without -c - not sure why
			# -c : Enable Database to 4GL data type conversion
			#Not sure if DBDELIMITER has anything to do with it, but
			#i had a case where fglschema failed with -c too
			#but it works from command line!!
			echo "$DBDELIMITER"
			#fglschema -c $TEST_DB
			fglschema $TEST_DB
			RET=$?
			if test "$RET" != "0"; then 
				rm -f ./etc/$TEST_DB.sch
			fi
			if ! test -f "./etc/$TEST_DB.sch"; then
				echo "ERROR: failed to create 4Js schema file for $TEST_DB"
				exit 8
			fi
		fi
		export FGLDBPATH=$CURR_DIR
		
		;;
	-querix)				#Use Querix compiler instead of Aubit compiler
		USE_COMP=querix
		EXPECT_TO_FAIL_TESTS="$EXPECT_TO_FAIL_QUERIX"
		#Force Querix compiler to check SQL for ANSI compliance
		#Q4GL_CC_FLAGS variable used in q4gl.mk
		Q4GL_CC_FLAGS="$Q4GL_CC_FLAGS -ansi"
		export Q4GL_CC_FLAGS
		#Indicate that we will use Informix RDBMS
		USE_SQLITE=0; USE_ESQLI=1
		;;

    -nographic)         #skip tests that use platform specific characters
		NO_GRAPHIC=1
        ;;

    -noprogress)         #do not show testing progress counter and other 
						#special characters (for outout to log file)
		NO_PROGRESS=1
		T_MD=
		T_ME=
        ;;

	-cron)		#passed when test is invoked as cron job
		CRON_JOB=1
		NO_PROGRESS=1
		T_MD=
		T_ME=
		;;
		
	-nodefaults)        #Do not use platform default settings
        #nothing to set; this is just to cause $@ not to be empty
        ;;

    -defaults)        	#Use platform default settings
        #nothing to set; this is intercepted earlier
        ;;

	-cert)	#Use settings for expected for certified tests
		#Nothing to do; this was intercepted earlier
		;;

	-compare)
		compare_settings
		exit
		;;
	
	-compare2)
		COMPARE_SETTINGS=1
		;;
	
	-t1)	#Time from start of this script to test invocation point
		TIME_SCRIPT=1
		;;

	-t2)	#Time from start of test loop to test invocation point
		TIME_LOOP=1
		;;
	-t3)	#Time from start of test loop to test invocation point
		TIME_LOOP2=1
		;;
		
	-described)         #run only described tests
        DESCRIBED_ONLY=1
		#if ! test "$NO_ECHO"; then
		if test "$VERBOSE" = "1"; then
			echo "** "
			echo "** WARNING:"
			echo "** Tests not described will be skipped"
			echo "** "
        fi
        ;;

	-help)
		echo "Aubit 4GL build testing script (run_tests)"
		echo ""
		echo "Usage: run_tests [flags] [x]"
		echo " x=number of the test to run (default=all tests):"

		echo "HELP BY GROUP:"
		echo " -help-general   General flags help"
		echo " -help-utility   Utility options"
		echo " -help-test      Selecting tests to run"
		echo " -help-debug     Debugging"
		echo " -help-db        Selecting database to run tests against"
		echo " -help-results   Output of test results"		
		echo " -help-other     Misc options" 
		echo " -help-examples  Examples of flags and options"
		echo " -help-short     Shortcuts (flags that expand to multiple flags)"
		echo " -help-all       Show ALL help sections at once"
		echo " -help           This help summary page"
		echo ""
		if test "$HELP_ALL" != "1"; then 
			exit 0
		fi
        ;;

	-help-general)		
		echo "GENERAL:"
		echo " -clean [x]  Clean all tests (or test x) and exit"
		echo " -clean-all  Clean completely to CVS state and exit (SLOW)"		
		echo " -noclean    Don't clean before running tests"
		echo " -stop       Stop on error"
		echo " -stop-after x Stop after running x tests (must be last)"
		echo " -stop-after-fail x Stop after x tests fail (must be last)"
		echo " -stop-after-pass x Stop after x tests pass (must be last)"
		echo " -stop-after-skip x Stop after x tests where skipped (must be last)"		
		echo " -nospace    Ignore changes in the amount of white space when diff-ing"
		echo " -nodefaults Do not use platform default settings"
		echo " -compile-only Do not run any tests, just compile them"
		echo " -ifx-p      Use Informix P-code compiler instead of Aubit compiler"
		echo " -4js-p      Use FourJs P-code compiler instead of Aubit compiler"
		echo " -querix     Use Querix compiler instead of Aubit compiler"
		echo " -aubitrc-test Use testing specific aubitrc to override local Aubit"
		echo "             settings settings"
		echo ""
		if test "$HELP_ALL" != "1"; then		
			exit 0
		fi
        ;;

	-help-short)
		echo "SHORTCUTS:"
		echo " -cert       Use settings expected by certified tests. Currently:"
		echo "   $CERT_DEFAULT_FLAGS"
		echo " -defaults   Use platform default settings. Currently:"
		echo "   $DEFAULT_FLAGS"
		echo "             NOTE: additional flags on command line take priority."
		echo " -cert-loop  Short for: '-cert -silent -verbose-results -log-unl'"
		echo ""		
		if test "$HELP_ALL" != "1"; then		
			exit 0
		fi
        ;;
		
	-help-debug)
		echo "DEBUGGING:"
		echo " -debug     Turn on DEBUG=ALL to produce debug.out"
		echo " -memdbg    Use 'valgrind' to perform memory checking ar run-time"
		echo " -gdb       Use gdb to run compiled programs with (not compiler)"
		echo " -shdbg     run_tests shell script debugging"
		echo ""		
		if test "$HELP_ALL" != "1"; then		
			exit 0
		fi
        ;;
		
	-help-test)
		echo "SELECTING TEST(S) TO RUN:"
		echo " -nographic  Skip tests that use platform specific characters"
		echo " -nolong     Skip tests that take a long time to run"
		echo " -onlytui    Run only TUI tests listed in TUI_TESTS"
		echo " -described  Skip all not desctibed tests"
		echo " -noskip     Do not skip any tests whatever the reason is"
		echo " -range x y  Run tests between x and y (inclusive)"
		echo " -retest-fail Run only tests that are expected to fail"
		echo " -retest-invalid Run only tests that are flaged as invalid"
		echo " -alltests[-db|-nodb] Run all available combinations of tests"
		echo " -console    Use CONSOLE UI for tests"
		echo " -gtk        Use GTK+ UI for running tests"		
		echo " -tuin       use HL_TUIN UI for tests"
		echo " -hl_tui     use HL_TUI UI for tests (default is TUI)"
		echo " -ignore-compat Skip testing for test compatibility with non-aubit compilers"
		echo " -ignore-conf-error Ignore configuration errors and continue"
		echo " -skip-expectfail Skip tests expected to fail"
		echo " -use-cache  Use cached test descriptions to loop faster"	
		echo ""
		if test "$HELP_ALL" != "1"; then
			exit 0
		fi
        ;;
		
    -help-db)
		echo "DATABASE:"
		echo " -nodb       Skip db dependent tests"
		echo " -onlydb     Run only db based tests"
		echo " -norunec    Don't run EC compiled programs"
		echo " -skip-unknown-trans Skip tests with explicit pref "
		echo "             for trans, when cant determine state of trans in current RDBMS"
		echo " -disable-sql-features-check Do not skip tests with incompatible SQL features"
		echo " -disable-sql-features-skip Check, but do not skip incompatible SQL features"
		echo " -db-features-report Show support status by db features for current db"
		echo " -skip-only-impossible Skip only db/SQL features known to be impossible on "
		echo "             current db, but NOT the ones that are possible but not working"
		echo " -sqlite     Use SQLite as database for db tests"
		echo " -esqli      Use Informix ESQL/C plug-in for db tests"
		echo " -ec[i|s|p|q] Use Informix/SAP/PG/Querix ESQL/C EC output in for db tests"
		echo " -pg         Use PostgreSQL plug-in for db tests"

		echo " -<x>odbc    Use <x> plug-in for db tests. <x> = "
		echo "             unix | i | ifx | sqlite | pg | sap | win"


		echo " -odbcdb-<x> Use <x> RDBMS for ODBC manager connections. <x>="
		echo "             ifx | pg | sqlite | sap "
        echo "             Note: this settings apply only to ODBC managers."
        echo "             Default is to use automaticaly detected RDBMS"


		echo " TEST DATABASE CREATION:"
		echo " -<x>-new    Create new database from scripts. <x>="
		echo "             sqlite | pg | informix | sap"

		echo ""
		if test "$HELP_ALL" != "1"; then
			exit 0
		fi
        ;;
		
	-help-results)
		echo "RESULTS DISPLAY OPTIONS:"	
		echo " -noprogress Do not show testing progress counter"		
		echo " -fail-full  Show full list of failed tests, db/nodb (need -verbose-results)"
		echo " -pass-full  Show full list of passed tests, db/nodb (need -verbose-results)"
        echo " -verbose-results Show more information about results"
		echo " -err-with-log Send stderr to same destination that logs stdout"
		echo " -short      Show only short summary"
		echo " -show-time  Show timing results for each test"
		echo " -itemised   Show result for each executed test"
		echo " -show-passed Show full list of tests that passed"
		
		echo ""
		if test "$HELP_ALL" != "1"; then
			exit 0
		fi
        ;;
		
	-help-utility)
		echo "UTILITY OPTIONS:"	
		echo " -info [x]   Show test x description, or list descriptions for all tests"
		echo " -catalogue  Create catalogue.txt file using -info flag"
		echo " -new x      Create new test x from files in template/, add to CVS"
		echo " -add-makefile Add makefile from template to tests that don't have one" 
		echo " -add-cvsignore Add .cvsignore from template to tests that don't have one"
		echo " -record     record keystrokes to file while running program"
		echo " -runner-[ifx|4js] Create p-code runner for specified compiler"		
		echo " -update     Update tests souce code from CVS"
		echo " -commit     commit changes to tests source code to CVS"
		echo " -certify	x  flage the test as certified in the makefile"
		echo " -showerr x  Show compile errors in 4gl code for given test"
		echo ""
		if test "$HELP_ALL" != "1"; then
			exit 0
		fi
        ;;

    -help-other)
		echo "OUTPUT:"
		echo " -silent     Don't show output of programs execution"
		echo " -noecho     Don't show any non-critical messages while running tests"
		echo " -verbose    Show more information about what is going on"
		echo " -watch      kill tests that take more then 100 secconds to run"
		echo " FORMATS (resource files):"
		echo " -packed     Use PACKED packer for resource files"
		echo " -xml        Use XML packer for resource files"
		echo " -xdr        Use Sun RCP XDR packer for resource files"

		echo ""
		if test "$HELP_ALL" != "1"; then
        	exit 0
		fi
        ;;

    -help-examples)
		echo "EXAMPLES:"
		echo " -default -debug 45"
		echo "   Run only test 45, apply defaults and turn on debugging"
		echo " -defaults -eci -range 5 50"
		echo "   Run tests between 5 and 50, apply defaults but use Informix ESQL/C generation"
		echo " -info 45"
		echo "   Show information about test 45"
		echo " -cert -short -silent"
		echo "   Set defaults as for testing ceritfied results, short summary, don't "
		echo "   show programs execution"
		echo ""		
        exit 0
        ;;

	-range) #run tests beween x and y 
		TEST_RANGE=1
		;;

	-stop-after) #Stop after running x tests
		STOP_AFTER="RUN"
		;;
	-stop-after-fail) #Stop after x tests fail
		STOP_AFTER="FAIL"
		;;
	-stop-after-pass) #Stop after x tests pass
		STOP_AFTER="PASS"
		;;
	-stop-after-skip) #Stop after x tests pass
		STOP_AFTER="SKIP"
		;;
		
	*)              #everything else should be a test number
		if test "$SHOW_4GL_ERROR" = "1"; then 
			#echo "a=$a"
			x=`eval $FIND $CURR_DIR/$a -name \'*.err\'`
			#echo $x
			#exit
			if test "$x" = ""; then
				echo "No .err files found in test $a"
			else
				echo "-----------------------------------------------------------------------"			
				grep -n -B 5 "^|" $x | head -20
				echo "-----------------------------------------------------------------------"
				echo "Above error(s) occured in file: `basename $x`"
			fi
			exit
		fi
	
		if test "$STOP_AFTER" != ""; then
			STOP_AFTER_NUM=$a
		elif test "$TEST_RANGE" = "1"; then
			if test "$TEST_RANGE_FROM" = ""; then 
				TEST_RANGE_FROM=$a
			else
				if test "$TEST_RANGE_TO" = ""; then 
					TEST_RANGE_TO=$a
					echo "Runing tests between $TEST_RANGE_FROM and $TEST_RANGE_TO" 
				else
					echo "ERROR: too many parameters after -range flag"
					exit 4
				fi
			fi
		else
			if test -d $a; then
    			RUN_ONE=$a
				SHOW_ITEM_RESULT=1
			else
            	echo ""
				echo "ERROR: unknown switch or test does not exist: $a"
				echo "Try -help. Stop."
				echo ""
				exit 4
			fi
		fi
		;;

  ####
  esac
  ####
####
done
####

if test "$A4GL_FORMTYPE" = "GENERIC" -a "$A4GL_PACKER" = "PACKED" -a "$PLATFORM" = "MINGW"; then
	EXPECT_TO_FAIL_TESTS="$EXPECT_TO_FAIL_TESTS $EXPECT_TO_FAIL_TESTS_MINGW_PACKED"
fi	

if test "$LOOP_TIMES" != ""; then 
	if test "$RUN_ONE" != ""; then
		ALL_TESTS=""
		CNT=0
		while [ "1" = "1" ] ; do
			let CNT=CNT + 1
			ALL_TESTS="$ALL_TESTS $RUN_ONE"
			if test "$CNT" = "$LOOP_TIMES"; then 
				break
			fi
		done
		echo "Looping test #$RUN_ONE $LOOP_TIMES times" 
		RUN_ONE=""
	else
		echo "Cant loop multiple tests"
		exit 5
	fi
fi


if test "$TEST_RANGE" = "1"; then
	if test "$TEST_RANGE_FROM" = "" -o "$TEST_RANGE_TO" = ""; then
		echo "ERROR: missing from or to value with -range"
		exit 5
	fi
fi

#Fixme - do we need to move this lower, if script decides to use IFX with unixODBC
#because rdbms was not specified?
if test "$A4GL_SQLTYPE" = "unixodbc" -a "$ODBC_USE_DB" = "IFX"; then  
	EXPECT_TO_FAIL_TESTS="$EXPECT_TO_FAIL_TESTS $EXPECT_TO_FAIL_TESTS_UNIXODBC_IFX"
fi	


##############################################################################
#                           Configure test(s) to run
##############################################################################

#####################
#Determine which datbase back-end we will use for ODBC managers, if user did not
#specify it using -odbcdb-xxx flag
if test "$IS_ODBC_MANAGER" = "1" && test "$ODBC_USE_DB" = ""; then
	if test "`dbaccess -V 2>/dev/null`" != ""; then
		ODBC_USE_DB=IFX
	elif test "`$PSQL -V 2>/dev/null`" != ""; then
		ODBC_USE_DB=PG
	elif test "`sqlite -version 2>/dev/null`" != ""; then
	    ODBC_USE_DB=SQLITE
	elif test "`echo quit | dbmcli -V 2>/dev/null`" != ""; then
	    ODBC_USE_DB=SAP
	else
		echo "ERROR: cannot determine RDBMS to use for ODBC. Stop."
	    exit 8
	fi
fi

#####################
#Show user a message which RDBMS is used when using ODBC manager
if test "$IS_ODBC_MANAGER" = "1"; then
    if test "$USE_UNIXODBC" = "1"; then
		if test "$SILENT" != "1"; then
			echo "Using $ODBC_USE_DB via UnixODBC"
        fi
    elif test "$USE_IODBC" = "1"; then
		if test "$SILENT" != "1"; then
			echo "Using $ODBC_USE_DB via iODBC"
        fi
    elif test "$USE_ODBC_32" = "1"; then
		if test "$SILENT" != "1"; then
			echo "Using $ODBC_USE_DB via ODBC32"
        fi
	else
        echo "ERROR: invalid USE_ setting for ODBC. Stop."
        exit 3
	fi
fi

#for now - don't delete the .c files - some of them are NOT generated
# but in the scripts
#watch for empty variables 
if test "$OUTPUT_LOG" = "" -o "$ERROR_LOG" = "" -o "$SO_EXT" = ""; then 
	echo "ERROR: variable used with asterix is empty. Stop"
	exit 4
fi
CLEAN_FIND_FILES='"(" -name "*.4ae" -o -name "*.afr" -o -name "*.afr.*" 
		-o -name "*.o" -o -name "*.ao" -o -name "*.out" -o -name "*.glb" 
		-o -name "*.err" -o -name "$OUTPUT_LOG" -o -name "$ERROR_LOG" 
		-o -name "*.tmp" -o -name "*.warn" -o -name "*.out" -o -name "*.cpc" 
		-o -name "*.ec" -o -name "*.h" -o -name "pcode.run" 
		-o -name "*.4pe.*" -o -name "*.4gi" -o -name "*.4go" -o -name "*$SO_EXT"
		-o -name "*.so" -o -name "*.dll" -o -name "*.iem"  -o -name "*.42f"
		-o -name "*.log" -o -name "*.4qe" -o -name "*.qo" -o -name "*.42r"
		-o -name "*.42m" -o -name "*.frm" -o -name "*.hlp" -o -name "*.pic"
		-o -name "*.4js" -o -name "*.querix"
		")"'

#######################
#Clean rubbish
if test "$CLEAN" = "1" -a "$RUN_ONE" = ""; then
	if test "$SILENT" != "1"; then
		echo "Cleaning all tests..."
	fi

	EXEC="$FIND . $CLEAN_FIND_FILES -exec rm {} \;"
	eval $EXEC

	if test "$CLEAN_ALL" = "1"; then
		for a in $ALL_TESTS
		do
			echo -e -n "\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\bCleaning $a..."
			$MAKE -C $a clean > /dev/null 2>&1
		done
		
		#editor's backup files
		EXEC='	$FIND . "(" -name "*~" -o -name "*.bak"
		-o -name ".#*"  -o -name ".*~"
		")" -exec rm  {} \;'
		
		eval $EXEC
	fi
	echo " "
	echo "Done."
	exit 0
fi

#######################
#General Settings:

#Make sure we all use same setting for DBDATE
export DBDATE=MDY4/

########################
#Set format for 'time' command
TIME_FILE="time.log"
TIME_TMPFILE="time.tmp"
#TIME_FORMAT="\t%E real,\t%U user,\t%S sys"
#Default format:
#TIME_FORMAT="%Uuser %Ssystem %Eelapsed %PCPU (%Xtext+%Ddata %Mmax)k %Iinputs+%Ooutputs (%Fmajor+%Rminor)pagefaults %Wswaps"
#Default output: 2.29user 0.35system 0:07.35elapsed 35%CPU (0text+0data 0max)k 0inputs+0outputs (3701major+2149minor)pagefaults 0swaps
#legend:    user system elapsed CPU text data max inputs outputs major minor swaps
#TIME_FORMAT="%U	%S	%E	%P	%X	%D	%M	%I	%O	%F	%R	%W"
#TIME_LEGEND="user system elapsed CPU text data max inputs outputs major minor swaps"
TIME_FORMAT="%U	%S	%E	%P	%X	%D	%I	%O	%F	%W"
TIME_LEGEND="user system elapsed CPU text data inputs outputs major swaps"
if test -f "/usr/bin/time$EXE_EXT"; then
	TIME_EXE="/usr/bin/time$EXE_EXT"
fi
if test "$TIME_EXE" != "" -a "$MEASURE_TIME" = "1"; then
	TIME_CMD='/usr/bin/time --format="$TIME_FORMAT" --output=$TIME_TMPFILE'
else
    #disable timing:
	MEASURE_TIME=0
	SHOW_TIME=0
fi
if test "$ALL_DB" = "1"; then
    #disable timing display:
	SHOW_TIME=0
fi

############
#UI default
if test "$A4GL_UI" = ""; then
	#Mike say that HL_TUI is still experimental
	#export A4GL_UI=HL_TUI
	export A4GL_UI=TUI
fi

export PATH="$AUBITDIR_UNIX/bin:$PATH"
if test "$COMSPEC" != ""; then
	#On windows dll's have to be in the PATH - there is no LD_LIBRARY_PATH
	#equivalent on Windows
	export PATH="$AUBITDIR_UNIX/lib:$PATH"
else
	export LD_LIBRARY_PATH=$AUBITDIR_UNIX/lib:$LD_LIBRARY_PATH
fi
LOGFILE=$CURR_DIR/build.log
RESLOGFILE=$CURR_DIR/resources.log
if test "$DEBUG" != ""; then
	echo "** "
	echo "** WARNING:"
	echo "** DEBUG is on; tests will run really slow now..."
	echo "** "
fi

############################################
#Include task specific shell script files:
#ODBC related processing"
. incl/odbc_inc.sh
#Database related processing"
. incl/db_inc.sh

if test "$SH_DBG" = "1"; then 
	echo "Entering 'Finalise settings' section"
fi

##############################################################################
#                           Finalise settings
##############################################################################

######################
#define which tests are expected to fail based on database/Aubit options used
if test "$USE_COMP" = "aubit"; then 
	#Must be after flags processing to prevent cummulation when overriding switches
	case $DB_TYPE in
		#IFX-SE)
		IFX-OL)
			if test "$USE_ESQLI" = "1" -a "$USE_ECI" = "0"; then
				EXPECT_TO_FAIL_TESTS="$EXPECT_TO_FAIL_TESTS $EXPECT_TO_FAIL_TESTS_ESQLI"
			fi
			if test "$USE_IFXODBC" = "1"; then		
				EXPECT_TO_FAIL_TESTS="$EXPECT_TO_FAIL_TESTS $EXPECT_TO_FAIL_TESTS_IFXODBC"
			fi
			#EXPECT_TO_FAIL_TESTS are actually EXPECT_TO_FAIL_TESTS_ECI, since 
			#-eci is part of -cert
			;;
		PG-IFX-74)
			if test "$USE_ECP" = "1"; then 
				EXPECT_TO_FAIL_TESTS="$EXPECT_TO_FAIL_TESTS $EXPECT_TO_FAIL_TESTS_ECP"
			#else
				#must be ODBC? (did that in ODBC section?)
			fi
			;;
		#PG-74)
		#PG-80)
		#*)	#Any other database back-end
	esac
fi

#Define list(s) of recognized SQL features
define_sql_features


if test "$RETEST_FAIL" = "1"; then
	ALL_TESTS="$EXPECT_TO_FAIL_TESTS"
fi


#######################
#initialise counters
COUNTER=0
FAIL_CNT=0
PASS_CNT=0
SKIP_CNT=0
SKIP_INVALID_CNT=0
SKIP_NON_ANSI_CNT=0
RUN_CNT=0
EXPECTED_TO_FAIL_CNT=0
NOT_EXPECTED_TO_FAIL_CNT=0
NOT_CERT_CNT=0

#######################
#Initialise results log file
echo "" > $LOGFILE
echo "============================== Test results ===============================" >> $LOGFILE
echo "" >> $LOGFILE
echo "Flags: $FLAGS" >> $LOGFILE
echo "Platform: $PLATFORM" >> $LOGFILE
if test "$ALL_DB" = "1"; then
	#remove irelevant flags, keep -sqlite -nospace -defaults -esqli
	#also remove ONE -sqlite, since it's a default added by -default switch
    #so we don't confuse the user:
	DISP_FLAGS=`echo $FLAGS | sed -e 's/-short//' -e 's/-silent//' -e 's/-alldbrun//' -e 's/-sqlite//' -e 's/-defaults//' -e 's/-cert//' -e 's/-described//' -e 's/-nospace//' -e 's/-noecho//'`
	echo "Flags: $DISP_FLAGS" >> $CURR_DIR/alldb.log
fi
if test "$VERBOSE" = "1"; then 
	echo "" >> $LOGFILE
	echo "Started at" >> $LOGFILE
	#we want exact time here - do not use $DATE
	date >> $LOGFILE
	echo "Aubit version/build:" >> $LOGFILE	
	$AUBITDIR/bin/4glc -v | grep Version >> $LOGFILE
	$AUBITDIR/bin/4glc -v | grep Build >> $LOGFILE
	#TODO: show versions of 4Js/Informix/Querix compiler - if used
fi

echo "" >> $LOGFILE
if test "$RUN_ONE" != ""; then
	echo "Running test: $RUN_ONE" >> $LOGFILE
	ALL_TESTS=$RUN_ONE
#else
#	if test "$NO_ECHO" != "1"; then
#		#echo "Running tests: $ALL_TESTS" >> $LOGFILE
#		#To get $ALL_TESTS expanded on Windows, must not have quotes:
#		echo "Running tests: $ALL_TESTS" >> $LOGFILE
#   fi
fi
echo "" >> $LOGFILE

rm -f $CURR_DIR/$TIME_FILE
rm -f $CURR_DIR/$OUTPUT_LOG
rm -f $CURR_DIR/$ERROR_LOG

##############################################################################
#							Run test(s)
##############################################################################

	TEMPLATE_COMMENT_CNT=0
	UNKNOWN_TEST_CNT=0			
	MIGRATE_DESC_CNT=0			
	HAS_DESC_TXT_CNT=0
	IS_REPORT_TEST_CNT=0
	NON_ZERO_EXIT_CNT=0
	COMPILE_ONLY_CNT=0
	IS_PCODE_ENABLED_CNT=0
	NOT_DESCRIBED_CNT=0
	IS_INVALID_CNT=0
	EXPECT_FAIL_CNT=0
	IS_DB_TEST_CNT=0
	IS_EC_TEST_CNT=0
	IS_NOSILENT_CNT=0
	IS_TUI_TEST_CNT=0
	IS_FORM_TEST_CNT=0
	IS_GRAPHIC_TEST_CNT=0
	IS_CONSOLE_PROMPT_CNT=0
	IS_DUMP_SCREEN_CNT=0
	IS_LONG_CNT=0
	IS_CERT_CNT=0
	IS_NO_CRON_CNT=0
	IS_OBSOLETE_CNT=0
	IS_COMPAT_CNT=0
	IS_UNKNOWN_CNT=0
	EXPECTED_TO_FAIL_PASSED_CNT=0
	IS_SE_REQUIRED_CNT=0
	FAIL_DB_CNT=0
	FAIL_NONDB_CNT=0
	PASS_DB_CNT=0
	PASS_NONDB_CNT=0
	KILL_CNT=0
	SKIP_INCOMPAT_SQL_CNT=0
#reset cache files:
if test "$USE_CACHE" != "1" -a "$RUN_ONE" = "" -a "$TEST_RANGE" != "1"; then
	#-a "$ONLY_DB" != "1" -a "$ONLY_TUI" != "1"; then
	#Full loop means we are going to loop troug ALL tests and read 
	#actuall descriptions for ALL tests, which will allow us to create 
	#new cache files. (Stalled on 478?)
	FULL_LOOP=1
	rm -f $CURR_DIR/etc/cache_IS_DB_TEST.txt
fi



if test "$SILENT" = "1" -a "$NO_ECHO" != "1"; then
	echo "Running test(s)..."
fi
#########################
for TEST_NO in $ALL_TESTS
#########################
do
	if test "$TIME_LOOP" = "1"; then 
		LOOP_START_TIME=`date +%s`
	fi

	#Make sure we are in tests root
	cd $CURR_DIR

	if test -f $CURR_DIR/$OUTPUT_LOG ; then 
		fsize=`ls -l $CURR_DIR/$OUTPUT_LOG | awk '{ print $5 }'`
		if test "$fsize" -gt "1000000"; then #1MB 
			echo "Error: log file size exceded the size limit"
			ls -lh $CURR_DIR/$OUTPUT_LOG | awk '{ print $5 }'
			exit 5
		fi
	fi
	
	
	if test "$TEST_RANGE" = "1"; then 
		if test "$TEST_NO" -lt "$TEST_RANGE_FROM"; then 
			continue
		fi
		if test "$TEST_NO" -gt "$TEST_RANGE_TO"; then 
			break
		fi
	fi

	case $STOP_AFTER in
		RUN)
			if test "$STOP_AFTER_NUM" = "$RUN_CNT"; then
				if test "$VERBOSE" = "1"; then 
					echo "Exiting after running $STOP_AFTER_NUM tests"
				fi
				break
			fi
		;;
		FAIL)
			if test "$STOP_AFTER_NUM" = "$FAIL_CNT"; then
				if test "$VERBOSE" = "1"; then 
					echo "Exiting after $STOP_AFTER_NUM tests failed"
				fi
				break
			fi
		;;
		PASS)
			if test "$STOP_AFTER_NUM" = "$PASS_CNT"; then
				if test "$VERBOSE" = "1"; then 
					echo "Exiting after $STOP_AFTER_NUM tests passed"
				fi
				break
			fi
		;;
		SKIP)
			if test "$STOP_AFTER_NUM" = "$SKIP_CNT"; then
				if test "$VERBOSE" = "1"; then 
					echo "Exiting after $STOP_AFTER_NUM tests where skipped"
				fi
				break
			fi
		;;
		
	esac
	
	if test "$SHOW_CONFIG" = "1"; then
		echo "A4GL_INIFILE=$A4GL_INIFILE"
		$AUBITDIR_UNIX/bin/aubit-config$EXE_EXT -a
		
		echo "aubit-config A4GL_AUBITRC returns :`aubit-config A4GL_AUBITRC`"
		echo "aubit-config DBMONEY returns      :`aubit-config DBMONEY`"
		echo "in environment: DBMONEY=$DBMONEY"
		
		unset A4GL_INIFILE
		echo "A4GL_INIFILE=$A4GL_INIFILE"
		
		echo "aubit-config A4GL_AUBITRC returns :`aubit-config A4GL_AUBITRC`"
		echo "aubit-config DBMONEY returns      :`aubit-config DBMONEY`"
		echo "in environment: DBMONEY=$DBMONEYc"
		
		exit 0
	fi
	
    #################################
	#Initialise counters and variables:
	let COUNTER=COUNTER+1
	IS_DB_TEST=0
	ec_test=0
	IS_NOSILENT_TEST=0
    IS_TUI_TEST=0
    IS_GRAPHIC_TEST=0
    IS_DESCRIBED=0
	IS_CONSOLE_PROMPT_TEST=0
	IS_DUMP_SCREEN_TEST=0
	IS_FORM_TEST=0
	IS_BLACKLIST_TEST=0
    IS_LONG_TEST=0
	IS_MAKE_ANSI_SQL_COMPAT=""
    IS_CERT_TEST=0
    IS_OBSOLETE_TEST=0
    IS_INVALID_TEST=0
    IS_PCODE_ENABLED=0
	IS_UNKNOWN_TEST=0
	IS_NO_CRON_TEST=0	
	TEMPLATE_COMMENT=0
	NEED_TRANSACTION=0
	IS_REPORT_TEST=0
	EXPECT_CODE=0
	COMPILE_ONLY=0
	IS_EXPECT_TO_FAIL_TEST=0
	compat_test=0
	NEED_IFX_VERSION=""
	SE_REQUIRED=0
	SKIP_REASON=""
	SKIP_REASON_CODES=""

    #################################
    #See if we should skip this test:
    if test "$RUN_ONE" != "" -a "$RUN_ONE" != "$TEST_NO"; then
		continue
    fi

	if test "$USE_CACHE" = "1"; then
		#Instead of reading descriptions for each test before we can determine
		#if this test should be skiped, use allready loaded cached descriptions
		check_cached_skip_reasons
		
		#decide if we WANT to skip it
		do_skip
		if test "$DO_SKIP" = "1"; then
			if test "$VERBOSE" = "1"; then
				echo "Skip $TEST_NO based on cached info"
			fi
			continue
		fi
	fi
	
	##################################
	#Colect information about this test
	###################################
	
	#Check if makefile is old or new type; sets IS_OLD_MAKEFILE
	check_makefile_type
	
	#see if Makefile contains description
	#sets desc_txt TEMPLATE_COMMENT IS_DESCRIBED ALL_DESCRIBED_TESTS
	check_desc_txt

	if test "$IS_OLD_MAKEFILE" = "0" ; then
		##############
		#get info about the test from makefile
		IS_DB_TEST=`$MAKE -s -C $TEST_NO db_test 2>/dev/null`
		if test "$IS_DB_TEST" = "1"; then
			#We are intereste in this features only if test is a db test,
			SE_REQUIRED=`$MAKE -s -C $TEST_NO se_required 2>/dev/null`
			NEED_IFX_VERSION=`$MAKE -s -C $TEST_NO need_ifx_version 2>/dev/null`
		else
			SE_REQUIRED=
			NEED_IFX_VERSION=
		fi
		ec_test=`$MAKE -s -C $TEST_NO ec_test 2>/dev/null`
		IS_NOSILENT_TEST=`$MAKE -s -C $TEST_NO nosilent_test 2>/dev/null`
		IS_TUI_TEST=`$MAKE -s -C $TEST_NO tui_test 2>/dev/null`
		IS_FORM_TEST=`$MAKE -s -C $TEST_NO form_test 2>/dev/null`
		IS_REPORT_TEST=`$MAKE -s -C $TEST_NO report_test 2>/dev/null`
		IS_GRAPHIC_TEST=`$MAKE -s -C $TEST_NO graphic_test 2>/dev/null`
		IS_CONSOLE_PROMPT_TEST=`$MAKE -s -C $TEST_NO console_prompt_test 2>/dev/null`
		IS_DUMP_SCREEN_TEST=`$MAKE -s -C $TEST_NO dump_screen_test 2>/dev/null`
		IS_LONG_TEST=`$MAKE -s -C $TEST_NO long_test 2>/dev/null`
		IS_CERT_TEST=`$MAKE -s -C $TEST_NO cert_test 2>/dev/null`
		IS_OBSOLETE_TEST=`$MAKE -s -C $TEST_NO obsolete_test 2>/dev/null`
		compat_test=`$MAKE -s -C $TEST_NO compat_test 2>/dev/null`
		IS_UNKNOWN_TEST=`$MAKE -s -C $TEST_NO unknown_test 2>/dev/null`
		EXPECT_CODE=`$MAKE -s -C $TEST_NO expect_code 2>/dev/null`
		if test "$EXPECT_CODE" = "" ; then
			EXPECT_CODE=0
		fi
		COMPILE_ONLY=`$MAKE -s -C $TEST_NO compile_only 2>/dev/null`
		NOPREFIX=`$MAKE -s -C $TEST_NO noprefix 2>/dev/null`
		if test "$NOPREFIX" = "1" ; then
			export A4GL_NAMESPACE=" "
		else
			unset A4GL_NAMESPACE
		fi

		NEED_COMPAT=`$MAKE -s -C $TEST_NO need_compat 2>/dev/null`

		if test "$NEED_COMPAT" = "1" ; then
			#test needs Aubit Informix compatibility support and headers
			export A4GL_COMPAT_MODE="Y"
			export CFLAGS="-I$AUBITDIR/incl -I$AUBITDIR/incl/compat "
		else
			unset A4GL_COMPAT_MODE
		fi

	else #old makefile - no descriptions in makefile
	
			#get info from this scripts variables (set in 
			#incl/legacy_descriptions_inc.sh) when test has 
			#old-style makefile
			
			#Do not have equivalent in script descriptions:
			#ec_test - DOES! EC_TESTS but it's not used 
			#compat_test

			for b in $REPORT_TESTS; do
				if test "$b" = "$TEST_NO"; then
					IS_REPORT_TEST=1
				fi
			done

			for b in $UNKNOWN_TESTS; do
				if test "$b" = "$TEST_NO"; then
					IS_UNKNOWN_TEST=1
				fi
			done
			for b in $DB_TESTS; do
				if test "$b" = "$TEST_NO"; then
					IS_DB_TEST=1
				fi
			done
			
			for b in $NOSILENT_TESTS; do
				if test "$b" = "$TEST_NO"; then
					IS_NOSILENT_TEST=1
				fi
			done
			
			for b in $TUI_TESTS; do
				if test "$b" = "$TEST_NO"; then
					IS_TUI_TEST=1
				fi
			done
			
			for b in $GRAPHIC_TESTS; do
				if test "$b" = "$TEST_NO"; then
					IS_GRAPHIC_TEST=1
				fi
			done
			
			for b in $ALL_DESCRIBED_TESTS; do
				if test "$b" = "$TEST_NO"; then
					IS_DESCRIBED=1
				fi
			done
			for b in $CONSOLE_PROMPT_TESTS; do
				if test "$b" = "$TEST_NO"; then
					IS_CONSOLE_PROMPT_TEST=1
				fi
			done
			for b in $DUMP_SCREEN_TESTS; do
				if test "$b" = "$TEST_NO"; then
					IS_DUMP_SCREEN_TEST=1
				fi
			done
			for b in $FORM_TESTS; do
				if test "$b" = "$TEST_NO"; then
					IS_FORM_TEST=1
				fi
			done
			for b in $LONG_TESTS; do
				if test "$b" = "$TEST_NO"; then
					IS_LONG_TEST=1
				fi
			done
			for b in $CERT_TESTS; do
				if test "$b" = "$TEST_NO"; then
					IS_CERT_TEST=1
				fi
			done
			for b in $OBSOLETE_TESTS; do
				if test "$b" = "$TEST_NO"; then
					IS_OBSOLETE_TEST=1
				fi
			done
			for b in $PCODE_ENABLED; do
				if test "$b" = "$TEST_NO"; then
					IS_PCODE_ENABLED=1
				fi
			done
			for b in $NO_CRON_TESTS; do
				if test "$b" = "$TEST_NO"; then
					IS_NO_CRON_TEST=1
				fi
			done
	fi #IS_OLD_MAKEILE
	
	#Both old and new makefiles may contain this targets, but they are 
	#relevant only for db tests
	if test "$IS_DB_TEST" = "1"; then 
		IS_MAKE_ANSI_SQL_COMPAT=`$MAKE -s -C $TEST_NO ansi_sql_compat 2>/dev/null`
		NEED_TRANSACTION=`$MAKE -s -C $TEST_NO transaction 2>/dev/null`
		SQL_FEATURES_USED=`$MAKE -s -C $TEST_NO sql_features_used 2>/dev/null`

		if test "$IS_MAKE_ANSI_SQL_COMPAT" = "0" -a "$SQL_FEATURES_USED" = ""; then 
			#echo "WARNING: #$TEST_NO is not compatible with ANSI SQL, but has no SQL features used description"
			NOT_ANSI_NO_SQL_FEATURES_DESC="$NOT_ANSI_NO_SQL_FEATURES_DESC $TEST_NO"
		else
			if test "$SQL_FEATURES_USED" = ""; then
				#echo "WARNING: #$TEST_NO is db test, but has no SQL features used description"			
				IS_DB_NO_SQL_FEATURES_DESC="$IS_DB_NO_SQL_FEATURES_DESC $TEST_NO"
			fi
		fi
	fi
	
		#################
		#Proces test information that is allways held only in this script, 
		#and NEVER in makefiles	
		for b in $EXPECT_TO_FAIL_TESTS; do
			if test "$b" = "$TEST_NO"; then
				IS_EXPECT_TO_FAIL_TEST=1
			fi
		done
		for b in $INVALID_TESTS; do
			if test "$b" = "$TEST_NO"; then
				IS_INVALID_TEST=1
			fi
		done
		for b in $BLACKLIST_TESTS; do
			if test "$b" = "$TEST_NO"; then
				IS_BLACKLIST_TEST=1
			fi
		done
		
		if test "$FULL_LOOP" = "1"; then
			#create test descriptions cache files, but only when 
			#running full test loop
			if test "$IS_DB_TEST" = "1"; then 
				echo " $TEST_NO" >> $CURR_DIR/etc/cache_IS_DB_TEST.txt
			fi
		fi
		
		if test "$INFO_TEST" = "1" -o "$RUN_AND_INFO" = "1"; then
			#Show test info
			show_test_info
		fi

	if test "$SH_DBG" = "1"; then 
		echo "Determining if we can/should run test $TEST_NO"
	fi
	
	#See if we can/should run this test
	check_skip
	
	#decide if we WANT to skip it
	do_skip
	if test "$DO_SKIP" = "1"; then 
		continue
	fi
	
	if test "$SILENT" != "1"; then
		echo " "
		echo "------------------------- Running test #$TEST_NO ---------------------------"
		if test "$desc_txt" != "" -a "$VERBOSE" = "1" ; then
			echo "Description: $desc_txt"
		fi
	else
		if test "$NO_PROGRESS" != "1"; then
		
			########################
			#calculate success percentage
			if test "$RUN_CNT" != "0"; then 
				VAR1=$PASS_CNT
				VAR2=$RUN_CNT
				RESULT=`perl -e '$X=shift @ARGV;$Y=shift @ARGV;;$Z=int($X*100/($Y));print "$Z";' $VAR1 $VAR2`
			else
				RESULT=0
			fi
			#echo -e -n "\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\bRunning test $TEST_NO..."
			echo -e -n "\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\bRunning test $TEST_NO...($RESULT %)  "
		fi
    fi

	if test "$ALL_COMPILE_ONLY" = "1"; then 
		COMPILE_ONLY=1
	fi
	
	#we will need that in make file
	export EXPECT_CODE
	export COMPILE_ONLY
	export USE_COMP
	#Exporting VERBOSE would propagate to 'aubit' and 'amake' too
	MAKE_VERBOSE=$VERBOSE
	export MAKE_VERBOSE

	#make never exits with exit code of the program that caused the error,
	#so we cannot expect EXPECT_CODE to be returned here
	MAKE_EXPECT_CODE=0

	##################################
    # No skip - clean first:

	if test "$NO_CLEAN" != "1"; then
		#Clean old run
		if test "$VERBOSE"; then
			echo "Cleaning $CURR_DIR/$TEST_NO ..."
		fi

		EXEC="$FIND $CURR_DIR/$TEST_NO $CLEAN_FIND_FILES -exec rm  {} \;"
		eval $EXEC

		if test "$VERBOSE" = "1"; then 
			$MAKE -C $CURR_DIR/$TEST_NO clean 
		else
			$MAKE -C $CURR_DIR/$TEST_NO clean  > /dev/null 2>&1
		fi
		RET=$?
		#Old makefiles do not have 'clean' target so this will allways fail
		if test "$RET" != "0"; then
			if test "$VERBOSE" = "1"; then
				echo "WARNING: make clean failed - old makefile? (no 'clean' target)"
			fi
		fi
		if test "$CLEAN" = "1" -a "$RUN_ONE" != ""; then
			echo "Clean only - done."
			exit 0
		fi
    fi
	
	if test "$WATCHIT" = "1"; then
		#Create watchdog script:
		echo 'RUN_CNT=0' > $WATCHIT_SH
		echo "TEST_NO=$TEST_NO" >> $WATCHIT_SH		
		echo "echo 'Begin, test $TEST_NO' > /tmp/watchit.log" >> $WATCHIT_SH		
		echo 'while [ "1" = "1" ] ; do' >> $WATCHIT_SH
		echo '	let RUN_CNT=RUN_CNT+1' >> $WATCHIT_SH
		echo '	if test "$RUN_CNT" = "10"; then' >> $WATCHIT_SH
		echo '		echo "Max loop 10 - exit" >> /tmp/watchit.log' >> $WATCHIT_SH
		echo "		MAKE_PID=\`ps -ef | grep -v 'grep' | grep 'make run' | head -1 | awk '{print \$2}' \` " >> $WATCHIT_SH		
		echo '		if test "$MAKE_PID" != "" -a "$MAKE_PID" != "0"; then' >> $WATCHIT_SH
		echo '			echo "Killing $MAKE_PID" >> /tmp/watchit.log' >> $WATCHIT_SH
		echo '			kill $MAKE_PID' >> $WATCHIT_SH
		echo '		else' >> $WATCHIT_SH
		echo '			echo "No PID ($MAKE_PID)" >> /tmp/watchit.log' >> $WATCHIT_SH		
		echo '		fi' >> $WATCHIT_SH
		echo '		break' >> $WATCHIT_SH
		echo '	fi' >> $WATCHIT_SH
		echo "#	ps -ef | grep -v 'grep' | grep 'make run' | head -1  >> /tmp/watchit.log " >> $WATCHIT_SH		
		echo "	MAKE_PID=\`ps -ef | grep -v 'grep' | grep 'make run' | head -1 | awk '{print \$2}' \` " >> $WATCHIT_SH		
		echo '	echo "Test $TEST_NO Loop $RUN_CNT , make pid=$MAKE_PID" >> /tmp/watchit.log' >> $WATCHIT_SH
		echo '	sleep 10' >> $WATCHIT_SH
		echo 'done' >> $WATCHIT_SH
		#exit
	
		#See this for explanation on how to silence kill:
		#http://www.experts-exchange.com/Programming/Programming_Platforms/Linux_Programming/Q_21078930.html
		#bash $WATCHIT_SH &
		(
		bash $WATCHIT_SH & > /dev/null &
		) 2>/dev/null
		
		#This $! will not work when we are starting watcher in another shell
		#by using ( )
		#PID1=$!
		#WATCH_PID=$!
		WATCH_PID=`ps -ef | grep -v "grep" | grep "bash $WATCHIT_SH" | head -1 | awk '{print $2}'`
		#if test "$WATCH_PID" = "$PID1"; then
		#	echo "same"
		#	exit
		#fi
		if test "$WATCH_PID" = ""; then
			echo "ERROR: no PID for watcher:"
			ps -ef | grep -v "grep" | grep "bash $WATCHIT_SH" | head -1
			exit 3
		fi
	fi #"$WATCHIT" = "1"
	
	##################################
    # run it:
	let RUN_CNT=RUN_CNT+1

	cd $CURR_DIR/$TEST_NO
    if test "$SILENT" = "1" -o "$NO_TEST_OUTPUT" = "1"; then
		if test "$ERR_WITH_LOG" != "1"; then
			echo "Test : " $TEST_NO   >> $CURR_DIR/$ERROR_LOG
            ERRLOG="2>$CURR_DIR/$ERROR_LOG"
        else
            ERRLOG="2>&1"
		fi
        RUN_CMD="$TIME_CMD $MAKE $MAKE_TARGET >> $CURR_DIR/$OUTPUT_LOG $ERRLOG"
	else
		if test "$ERR_WITH_LOG" != "1"; then
			echo "Test : " $TEST_NO   >> $CURR_DIR/$ERROR_LOG
            ERRLOG="2>> $CURR_DIR/$ERROR_LOG"
        else
            ERRLOG=
        fi
		RUN_CMD="$TIME_CMD $MAKE $MAKE_TARGET $ERRLOG"
	fi

	if test "$VERBOSE"; then
		echo "Running: $RUN_CMD"
	fi

	if test "$COMPARE_SETTINGS" = "1"; then
			compare_settings
			exit 0
	fi
	if test "$TIME_SCRIPT" = "1"; then
		EXIT_TIME=`date +%s`
		let TOOK_TIME=EXIT_TIME - START_TIME
		echo "Took $TOOK_TIME seconds from start of run_tests to execution point"
		if test "$TIME_LOOP" != "1"; then
			exit 0
		else
			TIME_SCRIPT=0
		fi
	fi
	if test "$TIME_LOOP" = "1"; then
		LOOP_EXIT_TIME=`date +%s`
		let LOOP_TOOK_TIME=LOOP_EXIT_TIME - LOOP_START_TIME
		echo "Took $LOOP_TOOK_TIME seconds from start of test loop to execution point"
		continue
	fi

	if test "$TIME_LOOP2" = "1"; then	
		LOOP_START_TIME2=`date +%s`
	else
		#############
		eval $RUN_CMD
		#############
		RET=$?
	fi

	if [ "$RET" != "$MAKE_EXPECT_CODE" ]; then
		if test "$SILENT" != "1"; then
			stty sane # Just it case it bombed...
		fi
	fi

	if test "$WATCHIT" = "1"; then
		TMP1=`grep "Killing" /tmp/watchit.log`
		if test "$TMP1" != ""; then
			if test "$VERBOSE" = "1" -o "$RUN_ONE" != ""; then
				echo
				echo "WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING!"
				echo "Had to kill test #$TEST_NO - took more then 100 seconds to run"
				echo "Probably an endless loop - investigate"			
				echo "WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING!"
			fi
			RET="kill"
			KILL_LIST="$KILL_LIST $TEST_NO"
			let KILL_CNT=KILL_CNT+1
		else
			#VERBOSE=1
			if test "$WATCH_PID" != "" -a "$WATCH_PID" != "0"; then
				echo "Killing watcher (pid $WATCH_PID)" >> /tmp/killwatch.log
				if test "$VERBOSE" = "1" ; then
					echo "Killing watcher (pid $WATCH_PID)"
				fi
				#kill $WATCH_PID > /dev/null 2>&1
				#/bin/kill $WATCH_PID  2> /dev/null > /dev/null
				
				#export $WATCH_PID
				#bash -c kill $WATCH_PID 2>&1 > /dev/null
				#See this for explanation on how to silence kill:
				#http://www.experts-exchange.com/Programming/Programming_Platforms/Linux_Programming/Q_21078930.html
				kill $WATCH_PID
				KILL_RET=$?
				if test "$KILL_RET" != "0"; then
					echo 
					echo "WARNING: Killing watcher (pid $WATCH_PID) returned code $KILL_RET"
					echo 
				else
					if test "$VERBOSE" = "1" ; then
						echo "Killing watcher (pid $WATCH_PID) returned code $KILL_RET"
					fi
				fi

				#Check again to make sure we don't have another one still running				
				NOW_WATCH_PID=`ps -ef | grep -v "grep" | grep "bash $WATCHIT_SH" | head -1 | awk '{print $2}'`
				if test "$NOW_WATCH_PID" != ""; then 
					echo "ERROR: still have one or more $WATCHIT_SH running:"
					ps -ef | grep -v "grep" | grep "bash $WATCHIT_SH"
					exit 6
				fi
			else
				echo "No pid for watcher"
			fi
			#exit
		fi
	fi
	
	if test -f $TIME_TMPFILE; then
		if test "$SHOW_TIME" = "1"; then
			#TIME_STRING=`cat $TIME_TMPFILE`
			set `cat $TIME_TMPFILE`
	        #echo $@

		    TIME_COUNTER=0
			for t in $TIME_LEGEND
			do
				#let TIME_COUNTER=TIME_COUNTER+1
	            #eval "TIME_$TIME_COUNTER=$t"
				echo -e -n "$t\t"
	        done
	        echo
			echo "______________________________________________________________________________"

			TIME_COUNTER=0
			for t in $@
			do
				let TIME_COUNTER=TIME_COUNTER+1
	            eval "TIME_$TIME_COUNTER=$t"
				echo -e -n "$t\t"
	        done
        fi
		cat $TIME_TMPFILE >> $CURR_DIR/$TIME_FILE
	fi

    ################################
    #Check the result
	if test "$VERBOSE" = "1" ; then 
		#almost meaningless - make does not return exit code of failed command
		echo "$MAKE returned code $RET"	
	fi
	
	if test "$RET" = "$MAKE_EXPECT_CODE"; then
		#Test passed
		RESULT=1
		if test "$IS_DB_TEST" = "1"; then
			PASS_DB_TESTS="$PASS_DB_TESTS $TEST_NO"
			let PASS_DB_CNT=PASS_DB_CNT+1
		else
			PASS_NONDB_TESTS="$PASS_NONDB_TESTS $TEST_NO"
			let PASS_NONDB_CNT=PASS_NONDB_CNT+1
		fi

		#Compile list of all working SQL features:
		if test "$COMPILE_ONLY" != "1" -a "$SQL_FEATURES_USED" != ""; then
			for used_feature in $SQL_FEATURES_USED ; do
				ALLREADY_LISTED=0
				for working_feature in $SQL_FEATURES_PASS_LIST ; do
					if test "$used_feature" = "$working_feature" ; then 
						ALLREADY_LISTED=1
						break
					fi
				done
				if test "$ALLREADY_LISTED" = "0"; then 
					SQL_FEATURES_PASS_LIST="$SQL_FEATURES_PASS_LIST $used_feature"
				fi
			done
		fi
		
		if test "$SKIP_REASON_NOTSKIP" != "" ; then
			#This test has what we expected to be incompatible SQL feature, 
			#but it passed
			#echo "WARNING: $TEST_NO passed, but has incompatible SQL feature(s):" 
			#echo "$SKIP_REASON_NOTSKIP"
			PASS_INCOMPAT_SQL="$PASS_INCOMPAT_SQL $TEST_NO=$SKIP_REASON_NOTSKIP"
			SKIP_REASON_NOTSKIP=
		fi
		
		if test "$compat_test" != "1" -a "$USE_COMP" != "aubit"; then
			#test is not described as compatible, but even using no-aubit compiler 
			#it passed, so it should be described as compatible
			NOT_COMPAT_BUT_PASSED="$NOT_COMPAT_BUT_PASSED $TEST_NO"
			#we do not want to automatically declare test compatible, just because
			#one compiler can do it. NB; Querix sometimes fails with error, but 
			#does not exit with error code
			#change_setting "compat_test" "1" "$TEST_NO"
		fi
	
		if test "$IS_EXPECT_TO_FAIL_TEST" = "1" ; then
			if test "$SHOW_ITEM_RESULT" = "1"; then 
				echo "NOTE: $TEST_NO was expected to fail, but passed!"  >> $LOGFILE
			fi
			EXPECTED_TO_FAIL_PASSED_LIST="$EXPECTED_TO_FAIL_PASSED_LIST $TEST_NO"
			let EXPECTED_TO_FAIL_PASSED_CNT=EXPECTED_TO_FAIL_PASSED_CNT+1
		fi
		let PASS_CNT=PASS_CNT+1
		PASS_LIST="$PASS_LIST $TEST_NO"
		if test "$IS_CERT_TEST" = "0"; then
			if test "$SHOW_ITEM_RESULT" = "1"; then
				echo "$TEST_NO Pass - NOT CERTIFIED" >> $LOGFILE
			fi
			let NOT_CERT_CNT=NOT_CERT_CNT+1
			NOT_CERT_LIST="$NOT_CERT_LIST $TEST_NO"
        else
			if test "$SHOW_ITEM_RESULT" = "1"; then		
				echo "$TEST_NO Pass" >> $LOGFILE
			fi
		fi
	else
		#test failed
		RESULT=0
		let FAIL_CNT=FAIL_CNT+1
		
		#Compile list of all failed SQL features:
		if test "$COMPILE_ONLY" != "1" -a "$SQL_FEATURES_USED" != ""; then
			#If test is not compile only and has SQL features described...
#echo 1		
			for used_feature in $SQL_FEATURES_USED ; do
				#...for every feature used in this failed test... 
				ALLREADY_LISTED=0
				for failed_feature in $SQL_FEATURES_FAIL_LIST ; do
					#...look for it in allready recorded failed features list
					if test "$used_feature" = "$failed_feature" ; then
						#Found, allreaddy got it listed as failed
						ALLREADY_LISTED=1
						break
					fi
				done
				if test "$ALLREADY_LISTED" = "0"; then
					#Did not find it, its a new feied feature, add it to the list
					#of all features used in failed tests
					SQL_FEATURES_FAIL_LIST="$SQL_FEATURES_FAIL_LIST $used_feature"
				fi
			done
		fi
#echo "SQL_FEATURES_FAIL_LIST $SQL_FEATURES_FAIL_LIST"

		if test "$SQL_FEATURES_COMPATIBLE" = "1" -a "$IS_DB_TEST" = "1" \
			-a "$SQL_FEATURES_USED" != ""; then 
			#This db test had what we expected to be compatible SQL
			#features, but it still failed. This does not mean in all cases
			#that we clasified it wrong, since it can fail for other reasons,
			#but it's worth knowing
			FAIL_COMPAT_SQL="$FAIL_COMPAT_SQL ($TEST_NO=$SQL_FEATURES_USED)"
		fi

		if test "$IS_DB_TEST" = "1"; then
			FAIL_DB_TESTS="$FAIL_DB_TESTS $TEST_NO"
			let FAIL_DB_CNT=FAIL_DB_CNT+1
		else
			FAIL_NONDB_TESTS="$FAIL_NONDB_TESTS $TEST_NO"
			let FAIL_NONDB_CNT=FAIL_NONDB_CNT+1
		fi
		if test "$compat_test" != "1" -a "$USE_COMP" != "aubit"; then
			IS_EXPECT_TO_FAIL_TEST=1
		fi
		
		if test "$IS_EXPECT_TO_FAIL_TEST" = "1" ; then 
			TMPNOTE="(expected)"
			EXPECTED_TO_FAIL_LIST="$EXPECTED_TO_FAIL_LIST $TEST_NO"
			let EXPECTED_TO_FAIL_CNT=EXPECTED_TO_FAIL_CNT+1
		else
			TMPNOTE=
			NOT_EXPECTED_TO_FAIL_LIST="$NOT_EXPECTED_TO_FAIL_LIST $TEST_NO"
			let NOT_EXPECTED_TO_FAIL_CNT=NOT_EXPECTED_TO_FAIL_CNT+1			
		fi
		
		if test "$IS_CERT_TEST" = "1" -a "$USE_ECI" = "1" ; then
			if test "$SHOW_ITEM_RESULT" = "1"; then
				echo "$TEST_NO Fail $TMPNOTE<<< WARNING - TEST WAS CERTIFIED TO RUN, BUT FAILED ($MAKE_EXPECT_CODE/$RET)" >> $LOGFILE
			fi

			if test "$NO_ECHO" != "1" -a "$SILENT" != "1"; then
				echo
				echo "WARNNING! WARNNING! WARNNING! WARNNING! WARNNING! WARNNING! WARNNING!"
	            echo        $TMPNOTE
				echo "  This test was certified to run, but now it failed - INVESTIGATE ($MAKE_EXPECT_CODE/$RET)"
	            echo
	            echo "WARNNING! WARNNING! WARNNING! WARNNING! WARNNING! WARNNING! WARNNING!"
	            echo
            fi
		else
			if test "$SHOW_ITEM_RESULT" = "1"; then
				if test "$IS_CERT_TEST" = "1" ; then 
					echo "$TEST_NO Fail $TMPNOTE($MAKE_EXPECT_CODE/$RET) (-eci certified) <<<" >> $LOGFILE			
				else
					echo "$TEST_NO Fail $TMPNOTE($MAKE_EXPECT_CODE/$RET) <<<" >> $LOGFILE
				fi
			fi
		fi
		if test "$ERROR_STOP" = "1"; then
			echo "Exiting after ERROR..." >> $LOGFILE
            break
        fi
	fi
	if test "$UNL_LOG" = "1"; then
		#test_no=$1 result=$2 skip_reason=$3 expect_fail=$4 test_version=$5 db_has_trans=$6
		result_unl $TEST_NO $RESULT "" $IS_EXPECT_TO_FAIL_TEST "" $DB_HAS_TRANSACTION
	fi
	
	if test "$TIME_LOOP2" = "1"; then
		LOOP_EXIT_TIME2=`date +%s`
		let LOOP_TOOK_TIME2=LOOP_EXIT_TIME2 - LOOP_START_TIME2
		echo "Took $LOOP_TOOK_TIME2 seconds from execution point to end of loop"
	fi
#####
done
#####

cd $CURR_DIR

	if test "$INFO_ALL" = "1" ; then
		#Show all tests summary statiscics
		echo "--------------------------------------------------------------"
		echo "Total tests: $COUNTER"
		echo "Still has template comment: $TEMPLATE_COMMENT_CNT ($TEMPLATE_COMMENT_LIST)"
		echo "Old makefile: $MIGRATE_DESC_CNT ($MIGRATE_DESC_LIST)"			
		echo "Not described: $NOT_DESCRIBED_CNT ($NOT_DESCRIBED_LIST)"
		echo "Invalid: $IS_INVALID_CNT ($IS_INVALID_LIST)"
		echo "Expected to fail (because of Aubit bug): $EXPECT_FAIL_CNT ($EXPECT_FAIL_LIST)"
		echo "Obsolete: $IS_OBSOLETE_CNT ($IS_OBSOLETE_LIST)"
		echo " "		
		echo "Has description text: $HAS_DESC_TXT_CNT"
		echo "Expect non-zero exit status: $NON_ZERO_EXIT_CNT"
		echo "Test is compile only: $COMPILE_ONLY_CNT"
		echo "P-code enabled: $IS_PCODE_ENABLED_CNT"
		echo "Needs database: $IS_DB_TEST_CNT"
		echo "EC only test: $IS_EC_TEST_CNT"
		echo "Cannot run silent: $IS_NOSILENT_CNT"
		echo "Uses TUI UI: $IS_TUI_TEST_CNT"
		echo "Uses forms: $IS_FORM_TEST_CNT"
		echo "Uses graphic characterts: $IS_GRAPHIC_TEST_CNT"
		echo "Expects manual input: $IS_CONSOLE_PROMPT_CNT"
		echo "Uses dump screen function: $IS_DUMP_SCREEN_CNT"
		echo "Long running: $IS_LONG_CNT"
		echo "Certified: $IS_CERT_CNT"
		echo "x4GL compatible: $IS_COMPAT_CNT"
		echo "Uses REPORT block: $IS_REPORT_TEST_CNT"
		echo "All other unsorted tests: $UNKNOWN_TEST_CNT"
		echo " "
		echo "End of -info (all) output"
		exit 0
	fi
	
	if test "$INFO_TEST" = "1" ; then
		exit 0
	fi
##############################################################################
#                           Finalise results & clean-up
##############################################################################

########################
#calculate success percentage
VAR1=$PASS_CNT
VAR2=$RUN_CNT
#VAR2=200
#VAR1=50
if test "$RUN_CNT" != "0"; then
	#RESULT1=`perl -e '$X=shift @ARGV;$Y=shift @ARGV;;$Z=int(100-($X/($Y/100)));print "$Z";' $VAR2 $VAR1`
	RESULT=`perl -e '$X=shift @ARGV;$Y=shift @ARGV;;$Z=int($X*100/($Y));print "$Z";' $VAR1 $VAR2`
	#echo "r1=$RESULT1 r2=$RESULT" >> $LOGFILE
else
	RESULT=0
fi

#####################
#Complete results log file

echo "" >> $LOGFILE
echo "Skipped: $SKIP_CNT Run: $RUN_CNT Passed: $PASS_CNT Failed: $FAIL_CNT ${T_MD}Success: $RESULT %${T_ME}" >> $LOGFILE
if test "$KILL_CNT" != "0"; then 
	echo "Had to kill $KILL_CNT tests: $KILL_LIST" >> $LOGFILE
fi
if test "$EXPECTED_TO_FAIL_CNT" != "0"; then 
	echo "Expected to fail: $EXPECTED_TO_FAIL_LIST ($EXPECTED_TO_FAIL_CNT)"  >> $LOGFILE
fi
if test "$NOT_EXPECTED_TO_FAIL_CNT" != "0"; then 
	echo "NOT expected to fail: $NOT_EXPECTED_TO_FAIL_LIST ($NOT_EXPECTED_TO_FAIL_CNT)" >> $LOGFILE
fi
if test "$NOT_CERT_CNT" != "0"; then 
	echo "NOT certified: $NOT_CERT_LIST ($NOT_CERT_CNT)" >> $LOGFILE
fi
if test "$SKIP_NODESC_LIST" != ""; then 
	echo "Skipped as not descsribed: $SKIP_NODESC_LIST" >> $LOGFILE
fi
if test "$EXPECTED_TO_FAIL_PASSED_CNT" != "0"; then 
	echo "Expected to fail, but passed: $EXPECTED_TO_FAIL_PASSED_CNT ($EXPECTED_TO_FAIL_PASSED_LIST)" >> $LOGFILE
fi
if test "$SKIP_INVALID_LIST" != "" ; then 
	echo "Skipped $SKIP_INVALID_CNT tests as invalid (PLEASE FIX OR OBSOLETE): $SKIP_INVALID_LIST" >> $LOGFILE
fi
if test "$SKIP_KEYS_IN_LIST" != ""; then
	echo "Skipped as use keys.in: $SKIP_KEYS_IN_LIST" >> $LOGFILE
fi
if test "$SKIP_OLD_MAKEFILE_LIST" != ""; then 
	echo "Skipped - has old makefile: $SKIP_OLD_MAKEFILE_LIST" >> $LOGFILE
fi
if test "$SKIP_DUMP_SCREEN" != ""; then 
	echo "Skipped dump_screen tests: $SKIP_DUMP_SCREEN" >> $LOGFILE
fi
	SKIP_OTHER_LIST="\
	$SKIP_PCODE_LIST $SKIP_TUI_LIST $SKIP_LONG_LIST $SKIP_CONSOLE_LIST \
	$SKIP_NONDB_LIST $SKIP_DB_LIST $SKIP_NOSILENT_LIST $SKIP_NOVERSION_LIST\
	$SKIP_GRAPHIC_LIST $SKIP_NOMAKEFILE_LIST $SKIP_NOCOMPAT_LIST $SKIP_NO_CRON_LIST \
	$SKIP_TRANS_LIST $SKIP_NO_SCRDUMP_PDCURSES_LIST $SKIP_BLACKLIST_LIST \
	$SKIP_DUMP_SCREEN_NOT_XTERM_LIST $SKIP_INCOMPAT_SQL_LIST $SKIP_NON_ANSI_LIST"
	#clipp it:
	SKIP_OTHER_LIST=`echo $SKIP_OTHER_LIST`
	
	VERBOSE_RESULTS_LOG="$CURR_DIR/verbose_results.log"
	SQLFEATURES_LOGFILE="$CURR_DIR/sql_features.log"
	rm -f $SQLFEATURES_LOGFILE $VERBOSE_RESULTS_LOG
	
	if test "$SKIP_DUMP_SCREEN_NOT_XTERM_LIST" != "" ; then 
		echo "Skipped DUMP_SCREEN - not xterm: $SKIP_DUMP_SCREEN_NOT_XTERM_LIST" >> $VERBOSE_RESULTS_LOG
	fi
	if test "$SKIP_NON_ANSI_LIST" != ""; then	
		echo "Skipped ANSI SQL incompatible: ($SKIP_NON_ANSI_CNT) $SKIP_NON_ANSI_LIST" >> $VERBOSE_RESULTS_LOG	
	fi
	if test "$SKIP_INCOMPAT_SQL_LIST" != "" ; then 
		echo "Skipped incompatible SQL ($SKIP_INCOMPAT_SQL_CNT): $SKIP_INCOMPAT_SQL_LIST" >> $LOGFILE
		echo "Skipped incompatible SQL: $SKIP_INCOMPAT_SQL_LIST_WITH_FEATURES"  >> $VERBOSE_RESULTS_LOG
	fi
	if test "$SKIP_PCODE_LIST" != "" ; then 
		echo "Skipped PCODE: $SKIP_PCODE_LIST" >> $VERBOSE_RESULTS_LOG
	fi
	if test "$SKIP_TUI_LIST" != "" ; then 
		echo "Skipped TUI: $SKIP_TUI_LIST" >> $VERBOSE_RESULTS_LOG
	fi 
	if test "$SKIP_LONG_LIST" != "" ; then 
		echo "Skipped long: $SKIP_LONG_LIST" >> $VERBOSE_RESULTS_LOG
	fi 
	if test "$SKIP_CONSOLE_LIST" != "" ; then 
		echo "Skipped console: $SKIP_CONSOLE_LIST" >> $VERBOSE_RESULTS_LOG
	fi
	if test "$SKIP_BLACKLIST_LIST" != "" ; then 
		echo "Skipped black-listed: $SKIP_BLACKLIST_LIST" >> $VERBOSE_RESULTS_LOG
	fi
	if test "$SKIP_NO_SCRDUMP_PDCURSES_LIST" != "" ; then 
		echo "Skipped screen_dump() with PDcurses: $SKIP_NO_SCRDUMP_PDCURSES_LIST" >> $VERBOSE_RESULTS_LOG
	fi
	if test "$VERBOSE" = "1"; then
		#usually very long lists, and not terribly usefull
		if test "$SKIP_NONDB_LIST" != "" ; then 
			echo "Skipped NODB: $SKIP_NONDB_LIST" >> $VERBOSE_RESULTS_LOG
		fi 
		if test "$SKIP_DB_LIST" != "" ; then 
			echo "Skipped DB: $SKIP_DB_LIST" >> $VERBOSE_RESULTS_LOG
		fi
	fi
	if test "$SKIP_NOSILENT_LIST" != "" ; then 
		echo "Skipped NOSILENT: $SKIP_NOSILENT_LIST" >> $VERBOSE_RESULTS_LOG
	fi 
	if test "$SKIP_NOVERSION_LIST" != "" ; then 
		echo "Skipped NOVERSION: $SKIP_NOVERSION_LIST" >> $VERBOSE_RESULTS_LOG
	fi
	if test "$SKIP_GRAPHIC_LIST" != "" ; then 
		echo "Skipped GRAPHIC: $SKIP_GRAPHIC_LIST" >> $VERBOSE_RESULTS_LOG
	fi 
	if test "$SKIP_NOMAKEFILE_LIST" != "" ; then 
		echo "Skipped NOMEAKEFILE: $SKIP_NOMAKEFILE_LIST" >> $VERBOSE_RESULTS_LOG
	fi 
	if test "$SKIP_NOCOMPAT_LIST" != "" ; then 
		echo "Skipped NOCOMPAT: $SKIP_NOCOMPAT_LIST" >> $VERBOSE_RESULTS_LOG
	fi
	if test "$SKIP_NO_CRON_LIST" != "" ; then 
		echo "Skipped NO_CRON: ($IS_NO_CRON_CNT) $SKIP_NO_CRON_LIST" >> $VERBOSE_RESULTS_LOG
	fi
	if test "$SKIP_TRANS_LIST" != "" ; then 
		echo "Skipped 'cant determine trans state' or 'cant swich trans mode': $SKIP_TRANS_LIST" >> $VERBOSE_RESULTS_LOG
	fi 
	
	if test "$PASS_FULL_LIST" = "1"; then 
		if test "$PASS_DB_TESTS" != "" ; then 
			echo "Pass db: ($PASS_DB_CNT) $PASS_DB_TESTS" >> $VERBOSE_RESULTS_LOG
		fi
		if test "$PASS_NONDB_TESTS" != "" ; then 
			echo "Pass non-db: ($PASS_NONDB_CNT) $PASS_NONDB_TESTS" >> $VERBOSE_RESULTS_LOG
		fi
	fi
	#if test "$VERBOSE_RESULTS" = "1"; then
		echo "Pass db: ($PASS_DB_CNT) Pass non-db: ($PASS_NONDB_CNT)" >> $VERBOSE_RESULTS_LOG
	#fi
	if test "$FAIL_FULL_LIST" = "1"; then	
		if test "$FAIL_DB_TESTS" != "" ; then 
			echo "Fail db: ($FAIL_DB_CNT) $FAIL_DB_TESTS" >> $VERBOSE_RESULTS_LOG
		fi
		if test "$FAIL_NONDB_TESTS" != "" ; then 
			echo "Fail non-db: ($FAIL_NONDB_CNT) $FAIL_NONDB_TESTS" >> $VERBOSE_RESULTS_LOG
		fi
	fi
	#if test "$VERBOSE_RESULTS" = "1"; then
		echo "Fail db: ($FAIL_DB_CNT) Fail non-db: ($FAIL_NONDB_CNT)" >> $VERBOSE_RESULTS_LOG
	#fi
	ALL_FAILED="$FAIL_DB_TESTS $FAIL_NONDB_TESTS"
	if test "$ALL_FAILED" != " " -a "$SHOW_FAIL_DESC" = "1"; then 
		echo "------------------------- Failed tests descriptions ---------------------------" >> $VERBOSE_RESULTS_LOG
		for TEST_NO in $ALL_FAILED; do
			desc_txt=`$MAKE -s -C $TEST_NO desc 2>/dev/null`
			echo "#$TEST_NO : $desc_txt" >> $VERBOSE_RESULTS_LOG
		done
		echo "-------------------------------------------------------------------------------" >> $VERBOSE_RESULTS_LOG
	fi

	if test "$IS_DB_NO_SQL_FEATURES_DESC" != ""; then
		#This is bad; DB tests should have SQL/db features used described
		echo "ERROR: DB tests but have no features description : $IS_DB_NO_SQL_FEATURES_DESC" >> $LOGFILE
	fi
	if test "$NOT_ANSI_NO_SQL_FEATURES_DESC" != ""; then 
		#This is bad; DB tests should have SQL/db features used described	
		echo "ERROR: Not ANSI compatible but have no features description : $NOT_ANSI_NO_SQL_FEATURES_DESC" >> $LOGFILE
	fi
	
	if test "$PASS_INCOMPAT_SQL" != ""; then
		#This is certanly wrong; need to change feature status; test cannot\
		#possibly pass if feature is incompatible
		echo "" >> $LOGFILE
		echo "ERROR: Passed, but SQL features used are listed as incompatible:" >> $LOGFILE
		echo "$PASS_INCOMPAT_SQL" >> $LOGFILE
		echo "" >> $LOGFILE
	fi
	
	if test "$FAIL_COMPAT_SQL" != ""; then
		#This is not nececeraly an error - test can fail for some other reason,
		#even when sql/db features are compatible
		echo "" >> $SQLFEATURES_LOGFILE
		echo "WARNING: Failed, but SQL features used are listed as compatible:" >> $SQLFEATURES_LOGFILE
		echo "$FAIL_COMPAT_SQL" >> $SQLFEATURES_LOGFILE
		echo "" >> $SQLFEATURES_LOGFILE
	fi	
	
	if test "$FEATURE_NOT_EXPECTED" != ""; then
		#This is an error - correct the feature description in makefile or
		#in array of feature descriptions
		echo "" >> $LOGFILE
		echo "ERROR: SQL features used not expected by compatiblity check:" >> $LOGFILE
		echo "$FEATURE_NOT_EXPECTED" >> $LOGFILE
		echo "" >> $LOGFILE
	fi

	#Eliminate working features from failed features list, test that contains
	#them must have failed for some other reason, since feature is also
	#present in test(s) that passed
	if test "$SQL_FEATURES_PASS_LIST" != ""; then
		#If pass list is not empty...
		for failed_feature in $SQL_FEATURES_FAIL_LIST; do
			#...for every featre found in failed tests...
			HAS_MATCH=0
			for working_feature in $SQL_FEATURES_PASS_LIST; do	
			#...look for that feature in pass list...
				if test "$working_feature" = "$failed_feature"; then
					#Found feature from failed test in passed test, so ignore it
					#echo "feature $working_feature appears on both PASS nad FAIL lists"
					HAS_MATCH=1
					break
				fi
			done
			if test "$HAS_MATCH" = "0"; then 
				#Not found, store it in filteres list
				FILTERED_SQL_FEATURES_FAIL_LIST="$FILTERED_SQL_FEATURES_FAIL_LIST $failed_feature"
			else
				#found, store it in filtered-out list
				ELIMINATED_SQL_FEATURES_FAIL_LIST="$ELIMINATED_SQL_FEATURES_FAIL_LIST $failed_feature"
			fi
		done
	else
		#no pass list - nothing to filter out
		FILTERED_SQL_FEATURES_FAIL_LIST="$SQL_FEATURES_FAIL_LIST"
	fi
	if test "$SH_DBG" = "1"; then 
		echo ""	
		echo "SQL_FEATURES_PASS_LIST=$SQL_FEATURES_PASS_LIST"
		echo ""
		echo "SQL_FEATURES_FAIL_LIST=$SQL_FEATURES_FAIL_LIST"
		echo "---------------------------------------------------------"
		echo "ELIMINATED_SQL_FEATURES_FAIL_LIST=$ELIMINATED_SQL_FEATURES_FAIL_LIST"
		echo ""
		echo "FILTERED_SQL_FEATURES_FAIL_LIST=$FILTERED_SQL_FEATURES_FAIL_LIST"
		echo ""
	fi
	
	if test "$SQL_FEATURES_PASS_LIST" != ""; then
		#This is 100% correct
		echo "" >> $SQLFEATURES_LOGFILE
		echo "All working DB features:"  >> $SQLFEATURES_LOGFILE
		echo "$SQL_FEATURES_PASS_LIST"  >> $SQLFEATURES_LOGFILE		
		echo "" >> $SQLFEATURES_LOGFILE
	fi
	if test "$FILTERED_SQL_FEATURES_FAIL_LIST" != ""; then
		#This is potentially not 100% correct, since we can have here listed
		#an feature that did not fail, but the test in which it appeared did 
		#for some other reason, and the same feature did not appear in any
		#of the tests that passed, so we could not eliminate it from fail list
		echo "" >> $SQLFEATURES_LOGFILE
		echo "DB features used in failed tests (and possibly/probably not working):" >> $SQLFEATURES_LOGFILE
		echo "$FILTERED_SQL_FEATURES_FAIL_LIST" >> $SQLFEATURES_LOGFILE		
		echo "" >> $SQLFEATURES_LOGFILE		
	fi
	
if test "$VERBOSE_RESULTS" = "1"; then
	echo ""	 >> $LOGFILE
	cat "$VERBOSE_RESULTS_LOG"  >> $LOGFILE
	echo ""	 >> $LOGFILE
else
	#if test "$SKIP_OTHER_LIST" != "" ; then 
	#	echo "Other skipped tests: $SKIP_OTHER_LIST" >> $LOGFILE
	#fi
	echo ""	 >> $LOGFILE
	echo "See `basename $VERBOSE_RESULTS_LOG` for details of skipped tests" >> $LOGFILE
fi 

	echo "See `basename $SQLFEATURES_LOGFILE` for detailed SQL features analisys" >> $LOGFILE
	echo ""	 >> $LOGFILE
	
if test "$NOT_COMPAT_BUT_PASSED" != ""; then 
	#test is not described as compatible, but even using non-aubit compiler 
	#it passed, so it should be described as compatible
	echo "TODO-add non-Aubit compilers compatible descriptor to: $NOT_COMPAT_BUT_PASSED" >> $LOGFILE
fi
if test "$PASS_LIST" != "" -a "$SHOW_PASSED" = "1"; then 
	echo "Passed: $PASS_LIST" >> $LOGFILE
fi
if test "$FAIL_CNT" = "$EXPECTED_TO_FAIL_CNT" -o "$FAIL_CNT" -lt "$EXPECTED_TO_FAIL_CNT" ; then
	echo "RESULT: EXPECTED" >> $LOGFILE
	RESULT=0
else
	#"$FAIL_CNT" is more then "$EXPECTED_TO_FAIL_CNT"
	echo "*********** RESULT: UNEXPECTED ******************" >> $LOGFILE
	RESULT=1
fi
if test "$VERBOSE" = "1"; then 
	echo "" >> $LOGFILE
	echo "see `basename $RESLOGFILE` and $TIME_FILE" >> $LOGFILE
fi	
echo "----------------------------- aubit-config -a ------------------------------" > $RESLOGFILE
$AUBITDIR_UNIX/bin/aubit-config$EXE_EXT -a  >> $RESLOGFILE 2>&1
if test "$VERBOSE" = "1"; then
	echo "" >> $LOGFILE
	echo "Finished at:" >> $LOGFILE
	#we want exact time here - do not use $DATE
	date >> $LOGFILE
	echo "" >> $LOGFILE
fi

#####################
#Show results to the user
if test "$SHORT_SUMMARY" != "1"; then
	cat $LOGFILE
else
    if test "$ALL_DB" = "1"; then
		echo "Skipped: $SKIP_CNT Passed: $PASS_CNT Failed: $FAIL_CNT" >> $CURR_DIR/alldb.log
		echo "" >> $CURR_DIR/alldb.log

        FAIL_CNT_TOT=`cat $CURR_DIR/fail.cnt`
        PASS_CNT_TOT=`cat $CURR_DIR/pass.cnt`

		let FAIL_CNT_NEW=FAIL_CNT+FAIL_CNT_TOT
		let PASS_CNT_NEW=PASS_CNT+PASS_CNT_TOT

		echo "$FAIL_CNT_NEW" > $CURR_DIR/fail.cnt
        echo "$PASS_CNT_NEW" > $CURR_DIR/pass.cnt
	fi
	if test "$NO_ECHO" != "1"; then
		echo "Skipped: $SKIP_CNT Passed: $PASS_CNT Failed: $FAIL_CNT"
    	echo "See $LOGFILE for details."
    fi

fi
if test "$UNL_LOG" = "1"; then 
	FINISH_ALL_TIME=`date +%s`
	test_run_unl
	echo ""
	echo "Logging files closed:"
	echo "  results_$HOSTNAME$U$date_stamp.unl"
	echo "  test_run_$HOSTNAME$U$date_stamp.unl"
fi
echo ""
cd $CURR_DIR
#Exit 
exit $RESULT

# =================================== EOF =================================


